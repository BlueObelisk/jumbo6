package org.xmlcml.cml.base;

/**
 * 
 * <p>
 * supports XSD and derived types generated by software and only instantiated as
 * singletons
 * </p>
 * 
 * @author Peter Murray-Rust
 * @version 5.0
 * 
 */
public class CMLType implements CMLConstants {

    protected String summary = "";

    protected String description = "";

    protected String base = null;

    protected String name = null;

    protected String id = null;

    protected boolean isList = false;

    protected String pattern = null;

    protected int listLength = Integer.MIN_VALUE;

    protected int iMinInclusive = Integer.MIN_VALUE;

    protected int iMinExclusive = Integer.MIN_VALUE;

    protected int iMaxInclusive = Integer.MAX_VALUE;

    protected int iMaxExclusive = Integer.MAX_VALUE;

    protected double dMinInclusive = Double.NaN;

    protected double dMinExclusive = Double.NaN;

    protected double dMaxInclusive = Double.NaN;

    protected double dMaxExclusive = Double.NaN;

    protected CMLType[] subTypes = new CMLType[0];

    protected String[] sEnumerationValues = new String[0];

    protected int[] iEnumerationValues = new int[0];

    protected double[] dEnumerationValues = new double[0];

    /**
     * default.
     */
    public CMLType() {
    }

    /**
     * default.
     * 
     * @param st
     */
    public CMLType(CMLType st) {
    }

    /**
     * checks value of simpleType. throws CMLRuntime if value does not check
     * against SimpleType or is a list currently only uses pattern. fails if
     * type is int or double
     * 
     * @param s
     *            the string
     * @throws CMLRuntimeException
     *             wrong type or pattern fails
     */
    public void checkValue(String s) throws CMLRuntimeException {
        if (subTypes.length > 0) {
            for (int j = 0; j < subTypes.length; j++) {
                (subTypes[j]).checkValue(s);
            }
        } else {
            if (!base.equals(XSD_STRING)) {
                throw new CMLRuntimeException("Cannot accept String for type: " + base);
            }
            if (isList) {
                throw new CMLRuntimeException(
                        "cannot accept single String for String[] list");
            }
            checkPattern(s);
            checkEnumeration(s);
        }
    }

    /**
     * checks value of simpleType. throws CMLRuntime if value does not check
     * against SimpleType or is not a list currently only uses pattern. fails if
     * type is int or double
     * 
     * @param ss
     *            the strings
     * @throws CMLRuntimeException
     *             wrong type or pattern fails
     */
    public void checkValue(String ss[]) throws CMLRuntimeException {
        if (subTypes.length > 0) {
            for (int j = 0; j < subTypes.length; j++) {
                (subTypes[j]).checkValue(ss);
            }
        } else {
            if (!base.equals(XSD_STRING)) {
                throw new CMLRuntimeException("Cannot accept String for type: " + base);
            }
            if (!isList) {
                throw new CMLRuntimeException(
                        "cannot accept a list String[] for single String");
            }
            checkListLength(ss.length);
            int i = 0;
            try {
                while (i < ss.length) {
                    checkPattern(ss[i]);
                    checkEnumeration(ss[i]);
                    i++;
                }
            } catch (CMLRuntimeException e) {
                throw new CMLRuntimeException("String (" + i + ")(" + ss[i]
                        + ") fails: " + e);
            }
        }
    }

    private void checkListLength(int l) throws CMLRuntimeException {
        // in many cases there is no set list length...
        // assume negative list length implies this?
        // if (listLength < Integer.MAX_VALUE && listLength != l) {
        if (listLength > 0 && listLength != l) {
            throw new CMLRuntimeException("listLength required (" + listLength
                    + ") incompatible with: " + l);
        }
    }

    /**
     * checks value of simpleType. throws CMLRuntime if value does not check
     * against SimpleType or is a list currently uses min/max/In/Exclusive fails
     * if type is String or double
     * 
     * @param i
     *            the int
     * @throws CMLRuntimeException
     *             wrong type or value fails
     */
    public void checkValue(int i) throws CMLRuntimeException {
        if (subTypes.length > 0) {
            for (int j = 0; j < subTypes.length; j++) {
                (subTypes[j]).checkValue(i);
            }
        } else {
            if (!base.equals(XSD_INTEGER)) {
                throw new CMLRuntimeException("Cannot accept int for type: " + base);
            }
            if (isList) {
                throw new CMLRuntimeException("cannot accept single int for int[] list");
            }
            checkMinMax(i);
            checkEnumeration(i);
        }
    }

    /**
     * checks value of simpleType. throws CMLRuntime if value does not check
     * against SimpleType or is not a list currently uses min/max/In/Exclusive
     * fails if type is String or double
     * 
     * @param ii
     *            the int
     * @throws CMLRuntimeException
     *             wrong type or value fails
     */
    public void checkValue(int ii[]) throws CMLRuntimeException {
        if (subTypes.length > 0) {
            for (int j = 0; j < subTypes.length; j++) {
                (subTypes[j]).checkValue(ii);
            }
        } else {
            if (!base.equals(XSD_INTEGER)) {
                throw new CMLRuntimeException("Cannot accept int for type: " + base);
            }
            if (!isList) {
                throw new CMLRuntimeException(
                        "cannot accept a list int[] for single int");
            }
            checkListLength(ii.length);
            int i = 0;
            try {
                while (i < ii.length) {
                    checkMinMax(ii[i]);
                    checkEnumeration(ii[i]);
                    i++;
                }
            } catch (CMLRuntimeException e) {
                throw new CMLRuntimeException("int[] (" + i + ")(" + ii[i] + ") fails: "
                        + e);
            }
        }
    }

    /**
     * checks value of simpleType. throws CMLRuntime if value does not check
     * against SimpleType or is a list currently uses min/max/In/Exclusive fails
     * if type is String or int
     * 
     * @param d
     *            the double
     * @throws CMLRuntimeException
     *             wrong type or value fails
     */
    public void checkValue(double d) throws CMLRuntimeException {
        if (subTypes.length > 0) {
            for (int j = 0; j < subTypes.length; j++) {
                (subTypes[j]).checkValue(d);
            }
        } else {
            if (!base.equals(XSD_DOUBLE)) {
                throw new CMLRuntimeException("Cannot accept double for type: " + base);
            }
            if (isList) {
                throw new CMLRuntimeException(
                        "cannot accept single double for double[] list");
            }
            checkMinMax(d);
            checkEnumeration(d);
        }
    }

    /**
     * checks value of simpleType. throws CMLRuntime if value does not check
     * against SimpleType or is not a list currently uses min/max/In/Exclusive
     * fails if type is String or int
     * 
     * @param dd
     *            the double
     * @throws CMLRuntimeException
     *             wrong type or value fails
     */
    public void checkValue(double dd[]) throws CMLRuntimeException {
        if (subTypes.length > 0) {
            for (int j = 0; j < subTypes.length; j++) {
                (subTypes[j]).checkValue(dd);
            }
        } else {
            if (!base.equals(XSD_DOUBLE)) {
                throw new CMLRuntimeException("Cannot accept String for type: " + base);
            }
            if (!isList) {
                throw new CMLRuntimeException(
                        "cannot accept a list double[] for single double");
            }
            checkListLength(dd.length);
            int i = 0;
            try {
                while (i < dd.length) {
                    checkMinMax(dd[i]);
                    checkEnumeration(dd[i]);
                    i++;
                }
            } catch (CMLRuntimeException e) {
                throw new CMLRuntimeException("double[] (" + i + ")(" + dd[i]
                        + ") fails: " + e);
            }
        }
    }

    /**
     * checks value of simpleType. throws CMLRuntime if value does not check
     * against SimpleType or is a list fails if type is not boolean
     * 
     * @param b
     *            the boolean
     * @throws CMLRuntimeException
     *             wrong type or value fails
     */
    public void checkValue(boolean b) throws CMLRuntimeException {
        if (subTypes.length > 0) {
            for (int j = 0; j < subTypes.length; j++) {
                (subTypes[j]).checkValue(b);
            }
        } else {
            if (!base.equals(XSD_BOOLEAN)) {
                throw new CMLRuntimeException("Cannot accept boolean for type: " + base);
            }
            if (isList) {
                throw new CMLRuntimeException(
                        "cannot accept single boolean for boolean[] list");
            }
        }
    }

    /**
     * checks value of simpleType. throws CMLRuntime if value does not check
     * against SimpleType or is not a list fails if type is not boolean
     * 
     * @param bb
     *            the boolean array
     * @throws CMLRuntimeException
     *             wrong type or value fails
     */
    public void checkValue(boolean bb[]) throws CMLRuntimeException {
        if (subTypes.length > 0) {
            for (int j = 0; j < subTypes.length; j++) {
                (subTypes[j]).checkValue(bb);
            }
        } else {
            if (!base.equals(XSD_BOOLEAN)) {
                throw new CMLRuntimeException("Cannot accept boolean for type: " + base);
            }
            if (!isList) {
                throw new CMLRuntimeException(
                        "cannot accept a list boolean[] for single boolean");
            }
            checkListLength(bb.length);
        }
    }

    /**
     * get name.
     * 
     * @return name
     */
    public String getName() {
        return this.name;
    }

    /**
     * set name.
     * 
     * @param name
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * get Base.
     * 
     * @return base
     */
    public String getBase() {
        return this.base;
    }

    /**
     * set base.
     * 
     * @param base
     */
    public void setBase(String base) {
        this.base = base;
    }

    /**
     * set id.
     * 
     * @param id
     */
    public void setId(String id) {
        this.id = id;
    }

    /**
     * returns whether ST uses a list.
     * 
     * @return true if list.
     */
    public boolean getIsList() {
        return isList;
    }

    /**
     * set is list.
     * 
     * @param b
     */
    public void setIsList(boolean b) {
        this.isList = b;
    }

    /**
     * set pattern.
     * 
     * @param p
     */
    public void setPattern(String p) {
        this.pattern = p;
    }

    /**
     * get pattern.
     * 
     * @return pattern
     */
    public String getPattern() {
        return this.pattern;
    }

    /**
     * get list length.
     * 
     * @return length
     */
    public int getListLength() {
        return this.listLength;
    }

    /**
     * set list length.
     * 
     * @param l
     */
    public void setListLength(int l) {
        this.listLength = l;
    }

    /**
     * set min inclusive.
     * 
     * @param i
     */
    public void setMinInclusive(int i) {
        this.iMinInclusive = i;
    }

    /**
     * set min exclusive.
     * 
     * @param i
     */
    public void setMinExclusive(int i) {
        this.iMinExclusive = i;
    }

    /**
     * set max inclusive.
     * 
     * @param i
     */
    public void setMaxInclusive(int i) {
        this.iMaxInclusive = i;
    }

    /**
     * set max exclusive.
     * 
     * @param i
     */
    public void setMaxExclusive(int i) {
        this.iMaxExclusive = i;
    }

    /**
     * set min exclusive.
     * 
     * @param d
     */

    public void setMinInclusive(double d) {
        this.dMinInclusive = d;
    }

    /**
     * set min exclusive.
     * 
     * @param d
     */
    public void setMinExclusive(double d) {
        this.dMinExclusive = d;
    }

    /**
     * set max inclusive.
     * 
     * @param d
     */
    public void setMaxInclusive(double d) {
        this.dMaxInclusive = d;
    }

    /**
     * set max exclusive.
     * 
     * @param d
     */
    public void setMaxExclusive(double d) {
        this.dMaxExclusive = d;
    }

    /**
     * get int min inclusive.
     * 
     * @return min
     */
    public int getIntMinInclusive() {
        return this.iMinInclusive;
    }

    /**
     * get int min exclusive.
     * 
     * @return min
     */
    public int getIntMinExclusive() {
        return this.iMinExclusive;
    }

    /**
     * get int max inclusive.
     * 
     * @return max
     */
    public int getIntMaxInclusive() {
        return this.iMaxInclusive;
    }

    /**
     * get int max exclusive.
     * 
     * @return int
     */
    public int getIntMaxExclusive() {
        return this.iMaxExclusive;
    }

    /**
     * get double min inclusive.
     * 
     * @return min
     */
    public double getDoubleMinInclusive() {
        return this.dMinInclusive;
    }

    /**
     * get double min exclusive.
     * 
     * @return min
     */
    public double getDoubleMinExclusive() {
        return this.dMinExclusive;
    }

    /**
     * get double max inclusive.
     * 
     * @return max
     */
    public double getDoubleMaxInclusive() {
        return this.dMaxInclusive;
    }

    /**
     * get double max exclusive.
     * 
     * @return max
     */
    public double getDoubleMaxExclusive() {
        return this.dMaxExclusive;
    }

    /**
     * set subtypes.
     * 
     * @param st
     */
    public void setSubTypes(CMLType[] st) {
        this.subTypes = new CMLType[st.length];
        for (int i = 0; i < st.length; i++) {
            subTypes[i] = st[i];
        }
    }

    // protected Elements subTypes = null;

    /**
     * set enumeration.
     * 
     * @param ss
     */
    public void setEnumeration(String[] ss) {
        this.sEnumerationValues = ss;
    }

    /**
     * set enumeration.
     * 
     * @param ii
     */
    public void setEnumeration(int[] ii) {
        this.iEnumerationValues = ii;
    }

    /**
     * set enumeration.
     * 
     * @param dd
     */
    public void setEnumeration(double[] dd) {
        this.dEnumerationValues = dd;
    }

    /**
     * get string enumeration.
     * 
     * @return enumeration
     */
    public String[] getStringEnumeration() {
        return this.sEnumerationValues;
    }

    /**
     * get int enumeration.
     * 
     * @return enumeration
     */
    public int[] getIntEnumeration() {
        return this.iEnumerationValues;
    }

    /**
     * get double enumeration.
     * 
     * @return enumeration
     */
    public double[] getDoubleEnumeration() {
        return this.dEnumerationValues;
    }

    private void checkPattern(String s) throws CMLRuntimeException {
        if (s == null) {
            throw new CMLRuntimeException("Null strings not allowed");
        }
        if (pattern != null && !s.matches(pattern)) {
            throw new CMLRuntimeException("String (" + s + ") does not match pattern ("
                    + pattern + ") for " + name);
        }
    }

    private void checkMinMax(int i) throws CMLRuntimeException {
        if (iMinInclusive > Integer.MIN_VALUE && i < iMinInclusive) {
            throw new CMLRuntimeException("int (" + i + ") less than " + iMinInclusive);
        }
        if (iMaxInclusive < Integer.MAX_VALUE && i > iMaxInclusive) {
            throw new CMLRuntimeException("int (" + i + ") greater than "
                    + iMaxInclusive);
        }
        if (iMinExclusive > Integer.MIN_VALUE && i <= iMinExclusive) {
            throw new CMLRuntimeException("int (" + i + ") less than equals "
                    + iMinExclusive);
        }
        if (iMaxExclusive < Integer.MAX_VALUE && i >= iMaxExclusive) {
            throw new CMLRuntimeException("int (" + i + ") greater than equals "
                    + iMaxExclusive);
        }
    }

    private void checkMinMax(double d) throws CMLRuntimeException {
        if (!Double.isNaN(dMinInclusive) && d < dMinInclusive) {
            throw new CMLRuntimeException("double (" + d + ") less than "
                    + dMinInclusive);
        }
        if (!Double.isNaN(dMaxInclusive) && d > dMaxInclusive) {
            throw new CMLRuntimeException("double (" + d + ") greater than "
                    + dMaxInclusive);
        }
        if (!Double.isNaN(dMinExclusive) && d <= dMinExclusive) {
            throw new CMLRuntimeException("double (" + d + ") less than equals "
                    + dMinExclusive);
        }
        if (!Double.isNaN(dMaxExclusive) && d >= dMaxExclusive) {
            throw new CMLRuntimeException("double (" + d + ") greater than equals "
                    + dMaxExclusive);
        }
    }

    private void checkEnumeration(int i) throws CMLRuntimeException {
        if (iEnumerationValues.length != 0) {
            boolean ok = false;
            for (int j = 0; j < iEnumerationValues.length; j++) {
                if (i == iEnumerationValues[j]) {
                    ok = true;
                    break;
                }
            }
            if (!ok) {
                throw new CMLRuntimeException("int (" + i
                        + ") not contained in enumeration");
            }
        }
    }

    private void checkEnumeration(double d) throws CMLRuntimeException {
        if (dEnumerationValues.length != 0) {
            boolean ok = false;
            for (int j = 0; j < dEnumerationValues.length; j++) {
                if (d == dEnumerationValues[j]) {
                    ok = true;
                    break;
                }
            }
            if (!ok) {
                throw new CMLRuntimeException("double (" + d
                        + ") not contained in enumeration");
            }
        }
    }

    private void checkEnumeration(String s) throws CMLRuntimeException {
        if (s == null) {
            throw new CMLRuntimeException(
                    "Null String cannot be checked against enumeration");
        }
        if (dEnumerationValues.length != 0) {
            boolean ok = false;
            for (int j = 0; j < sEnumerationValues.length; j++) {
                if (s.equals(sEnumerationValues[j])) {
                    ok = true;
                    break;
                }
            }
            if (!ok) {
                throw new CMLRuntimeException("String (" + s
                        + ") not contained in enumeration");
            }
        }
    }

    /**
     * compares schemaType. uses name only as we expect to have singleton
     * CMLTypes null values of any component return -1
     * 
     * @param type
     *            to compare
     * @return 0 if all content is identical, -1 if this less than att, 1 if
     *         greater value
     * 
     */
    public int compareTo(CMLType type) {
        return name.compareTo(type.name);
    }

    /**
     * get summary.
     * 
     * @return summary
     */
    public String getSummary() {
        return summary;
    }

    /**
     * set summary.
     * 
     * @param s
     */
    public void setSummary(String s) {
        summary = s.trim();
        if (summary.length() != 0 && !summary.endsWith(S_PERIOD)) {
            summary += S_PERIOD;
        }
    }

    /**
     * get description.
     * 
     * @return description
     */
    public String getDescription() {
        return description;
    }

    /**
     * get full description.
     * 
     * @return description
     */
    public String getFullDescription() {
        String desc = "";
        if (!summary.trim().equals("")) {
            desc += "\n" + summary;
        }
        if (!description.equals("")) {
            desc += "\n" + description;
        }
        if (pattern != null) {
            desc += "\nPattern: " + pattern;
        }
        if (listLength != Integer.MIN_VALUE) {
            desc += "\nLength: " + listLength;
        }
        boolean min = false;
        if (iMinInclusive != Integer.MIN_VALUE) {
            desc += "\nMinInclusive: " + iMinInclusive;
            min = true;
        }
        if (iMinExclusive != Integer.MIN_VALUE) {
            desc += "\nMinExclusive: " + iMinExclusive;
            min = true;
        }
        if (!Double.isNaN(dMinInclusive)) {
            desc += "\nMinInclusive: " + dMinInclusive;
            min = true;
        }
        if (!Double.isNaN(dMinExclusive)) {
            desc += "\nMinExclusive: " + dMinExclusive;
            min = true;
        }

        if (iMaxInclusive != Integer.MAX_VALUE) {
            desc += ((min) ? "" : "\n") + "MaxInclusive: " + iMaxInclusive;
        }
        if (iMaxExclusive != Integer.MAX_VALUE) {
            desc += ((min) ? "" : "\n") + "MaxExclusive: " + iMaxExclusive;
        }
        if (!Double.isNaN(dMaxInclusive)) {
            desc += ((min) ? "" : "\n") + "MaxInclusive: " + dMaxInclusive;
        }
        if (!Double.isNaN(dMaxExclusive)) {
            desc += ((min) ? "" : "\n") + "MaxExclusive: " + dMaxExclusive;
        }
        /*--
         protected String[] sEnumerationValues = new String[0];
         protected int[] iEnumerationValues = new int[0];
         protected double[] dEnumerationValues = new double[0];
         --*/
        if (sEnumerationValues.length > 0) {
            desc += "\nPermitted values:";
            for (int i = 0; i < sEnumerationValues.length; i++) {
                desc += "\n  " + sEnumerationValues[i];
            }
        }
        if (iEnumerationValues.length > 0) {
            desc += "\nPermitted values:";
            for (int i = 0; i < iEnumerationValues.length; i++) {
                desc += "\n  " + iEnumerationValues[i];
            }
        }
        if (dEnumerationValues.length > 0) {
            desc += "\nPermitted values:";
            for (int i = 0; i < dEnumerationValues.length; i++) {
                desc += "\n  " + dEnumerationValues[i];
            }
        }
        return desc;
    }

    /**
     * set description.
     * 
     * @param d
     */
    public void setDescription(String d) {
        description = d;
    }

}
