package org.xmlcml.cml.element;

import nu.xom.Attribute;
import org.xmlcml.cml.base.*;
import nu.xom.Elements;
import java.util.HashMap;
import java.util.Map;
import org.xmlcml.cml.element.CMLAlternative;
import org.xmlcml.cml.element.CMLRelatedEntry;
import org.xmlcml.cml.element.CMLAnnotation;
import org.xmlcml.cml.element.CMLMetadataList;
import org.xmlcml.cml.element.CMLDescription;
import org.xmlcml.cml.element.CMLDefinition;
import org.xmlcml.cml.element.CMLEnumeration;

/** A dictionary entry.
*
* 
* 
* 
* NON-MOFIFIABLE class autogenerated from schema
* DO NOT EDIT; ADD FUNCTIONALITY TO SUBCLASS

*/
public abstract class AbstractEntry extends CMLElement {

// fields;
    /** table mapping attribute names to attributegroup names*/
    public static Map<String, String> attributeGroupNameTable = new HashMap<String, String>();
    /** local name*/
    public final static String TAG = "entry";
    /** default constructor.
    *
    * creates element initially without parent


    */

    public AbstractEntry() {
        super("entry");
    }
    /** copy constructor.
    *
    * deep copy using XOM copy()

    * @param old AbstractEntry to copy

    */

    public AbstractEntry(AbstractEntry old) {
        super((CMLElement) old);
    }

    static {
        attributeGroupNameTable.put("title", "title");
        attributeGroupNameTable.put("id", "id");
        attributeGroupNameTable.put("convention", "convention");
        attributeGroupNameTable.put("dataType", "dataType");
        attributeGroupNameTable.put("rows", "rows");
        attributeGroupNameTable.put("columns", "columns");
        attributeGroupNameTable.put("unitType", "unitType");
        attributeGroupNameTable.put("minExclusive", "minExclusive");
        attributeGroupNameTable.put("minInclusive", "minInclusive");
        attributeGroupNameTable.put("maxExclusive", "maxExclusive");
        attributeGroupNameTable.put("maxInclusive", "maxInclusive");
        attributeGroupNameTable.put("totalDigits", "totalDigits");
        attributeGroupNameTable.put("fractionDigits", "fractionDigits");
        attributeGroupNameTable.put("length", "length");
        attributeGroupNameTable.put("minLength", "minLength");
        attributeGroupNameTable.put("maxLength", "maxLength");
        attributeGroupNameTable.put("units", "units");
        attributeGroupNameTable.put("whiteSpace", "whiteSpace");
        attributeGroupNameTable.put("pattern", "pattern");
        attributeGroupNameTable.put("term", "term");
    };
    /** get attributeGroupName from attributeName.
    *
    * @param attributeName attribute name
    * @return String
    */
    public String getAttributeGroupName(String attributeName) {
            return attributeGroupNameTable.get(attributeName);
    }
    /** A title on an element.
    *
    * No controlled value.

    * @return CMLAttribute
    */
    public CMLAttribute getTitleAttribute() {
        return (CMLAttribute) getAttribute("title");
    }
    /** A title on an element.
    *
    * No controlled value.

    * @return String
    */
    public String getTitle() {
        CMLAttribute _att_title = (CMLAttribute) getAttribute("title");
        if (_att_title == null) {
            return null;
        }
        return ((StringAttribute)_att_title).getString();
    }
    /** A title on an element.
    *
    * No controlled value.

    * @param value title value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setTitle(String value) throws CMLRuntimeException {
            CMLAttribute _att_title = null;
            try {
        		_att_title = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("title"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_title == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : title; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_title);
        ((StringAttribute)_att_title).setCMLValue(value);
    }
    /** A unique ID for an element.
    *
    * Id is used for machine identification of elements and
    *  in general should not have application semantics. It is similar to the XML ID type
    *  as containing only alphanumerics, '_', ',' and '-' and and must start with an
    *  alphabetic character. Ids are case sensitive. Ids should be unique within local scope,
    *  thus all atoms within a molecule should have unique ids, but separated molecules within a 
    * document (such as a published article) might have identical ids. Software
    *  should be able to search local scope (e.g. all atoms within a molecule). 
    * However this is under constant review.
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @return CMLAttribute
    */
    public CMLAttribute getIdAttribute() {
        return (CMLAttribute) getAttribute("id");
    }
    /** A unique ID for an element.
    *
    * Id is used for machine identification of elements and
    *  in general should not have application semantics. It is similar to the XML ID type
    *  as containing only alphanumerics, '_', ',' and '-' and and must start with an
    *  alphabetic character. Ids are case sensitive. Ids should be unique within local scope,
    *  thus all atoms within a molecule should have unique ids, but separated molecules within a 
    * document (such as a published article) might have identical ids. Software
    *  should be able to search local scope (e.g. all atoms within a molecule). 
    * However this is under constant review.
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @return String
    */
    public String getId() {
        CMLAttribute _att_id = (CMLAttribute) getAttribute("id");
        if (_att_id == null) {
            return null;
        }
        return ((StringAttribute)_att_id).getString();
    }
    /** A unique ID for an element.
    *
    * Id is used for machine identification of elements and
    *  in general should not have application semantics. It is similar to the XML ID type
    *  as containing only alphanumerics, '_', ',' and '-' and and must start with an
    *  alphabetic character. Ids are case sensitive. Ids should be unique within local scope,
    *  thus all atoms within a molecule should have unique ids, but separated molecules within a 
    * document (such as a published article) might have identical ids. Software
    *  should be able to search local scope (e.g. all atoms within a molecule). 
    * However this is under constant review.
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @param value id value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setId(String value) throws CMLRuntimeException {
            CMLAttribute _att_id = null;
            try {
        		_att_id = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("id"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_id == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : id; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_id);
        ((StringAttribute)_att_id).setCMLValue(value);
    }
    /** A reference to a convention.
    *
    * There is no controlled vocabulary for conventions, but the author must ensure that the semantics are openly available and that there are mechanisms for implementation. The convention is inherited by all the subelements, 
    * so that a convention for molecule would by default extend to its bond and atom children. This can be overwritten
    *  if necessary by an explicit convention.
    *  It may be useful to create conventions with namespaces (e.g. iupac:name).
    *  Use of convention will normally require non-STMML semantics, and should be used with
    *  caution. We would expect that conventions prefixed with "ISO" would be useful,
    *  such as ISO8601 for dateTimes.
    *  There is no default, but the conventions of STMML or the related language (e.g. CML) will be assumed.
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @return CMLAttribute
    */
    public CMLAttribute getConventionAttribute() {
        return (CMLAttribute) getAttribute("convention");
    }
    /** A reference to a convention.
    *
    * There is no controlled vocabulary for conventions, but the author must ensure that the semantics are openly available and that there are mechanisms for implementation. The convention is inherited by all the subelements, 
    * so that a convention for molecule would by default extend to its bond and atom children. This can be overwritten
    *  if necessary by an explicit convention.
    *  It may be useful to create conventions with namespaces (e.g. iupac:name).
    *  Use of convention will normally require non-STMML semantics, and should be used with
    *  caution. We would expect that conventions prefixed with "ISO" would be useful,
    *  such as ISO8601 for dateTimes.
    *  There is no default, but the conventions of STMML or the related language (e.g. CML) will be assumed.
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @return String
    */
    public String getConvention() {
        CMLAttribute _att_convention = (CMLAttribute) getAttribute("convention");
        if (_att_convention == null) {
            return null;
        }
        return ((StringAttribute)_att_convention).getString();
    }
    /** A reference to a convention.
    *
    * There is no controlled vocabulary for conventions, but the author must ensure that the semantics are openly available and that there are mechanisms for implementation. The convention is inherited by all the subelements, 
    * so that a convention for molecule would by default extend to its bond and atom children. This can be overwritten
    *  if necessary by an explicit convention.
    *  It may be useful to create conventions with namespaces (e.g. iupac:name).
    *  Use of convention will normally require non-STMML semantics, and should be used with
    *  caution. We would expect that conventions prefixed with "ISO" would be useful,
    *  such as ISO8601 for dateTimes.
    *  There is no default, but the conventions of STMML or the related language (e.g. CML) will be assumed.
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @param value convention value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setConvention(String value) throws CMLRuntimeException {
            CMLAttribute _att_convention = null;
            try {
        		_att_convention = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("convention"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_convention == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : convention; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_convention);
        ((StringAttribute)_att_convention).setCMLValue(value);
    }
    /** The data type of the object.
    *
    * Normally applied to scalar/array 
    * objects but may extend to more complex one.
    * --type info--
    * 
    * an enumerated type for all dataTypes in STM.
    * Note: the attribute xsi:type might be used to enforce the type-checking but I haven't worked this through yet.

    * @return CMLAttribute
    */
    public CMLAttribute getDataTypeAttribute() {
        return (CMLAttribute) getAttribute("dataType");
    }
    /** The data type of the object.
    *
    * Normally applied to scalar/array 
    * objects but may extend to more complex one.
    * --type info--
    * 
    * an enumerated type for all dataTypes in STM.
    * Note: the attribute xsi:type might be used to enforce the type-checking but I haven't worked this through yet.

    * @return String
    */
    public String getDataType() {
        CMLAttribute _att_dataType = (CMLAttribute) getAttribute("dataType");
        if (_att_dataType == null) {
            return null;
        }
        return ((StringAttribute)_att_dataType).getString();
    }
    /** The data type of the object.
    *
    * Normally applied to scalar/array 
    * objects but may extend to more complex one.
    * --type info--
    * 
    * an enumerated type for all dataTypes in STM.
    * Note: the attribute xsi:type might be used to enforce the type-checking but I haven't worked this through yet.

    * @param value dataType value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setDataType(String value) throws CMLRuntimeException {
            CMLAttribute _att_dataType = null;
            try {
        		_att_dataType = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("dataType"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_dataType == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : dataType; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_dataType);
        ((StringAttribute)_att_dataType).setCMLValue(value);
    }
    /** Number of rows.
    *
    * 
    * --type info--
    * 
    * The size of an array.
    * The size of an array. Redundant, but serves as a check for processing software (useful if delimiters are used).
    * MinInclusive: 0

    * @return CMLAttribute
    */
    public CMLAttribute getRowsAttribute() {
        return (CMLAttribute) getAttribute("rows");
    }
    /** Number of rows.
    *
    * 
    * --type info--
    * 
    * The size of an array.
    * The size of an array. Redundant, but serves as a check for processing software (useful if delimiters are used).
    * MinInclusive: 0

    * @return int
    */
    public int getRows() {
        CMLAttribute _att_rows = (CMLAttribute) getAttribute("rows");
        if (_att_rows == null) {
            CMLUtil.BUG("unset attribute: rows");
        }
        return ((IntAttribute)_att_rows).getInt();
    }
    /** Number of rows.
    *
    * 
    * --type info--
    * 
    * The size of an array.
    * The size of an array. Redundant, but serves as a check for processing software (useful if delimiters are used).
    * MinInclusive: 0

    * @param value rows value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setRows(int value) throws CMLRuntimeException {
            CMLAttribute _att_rows = null;
            try {
        		_att_rows = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("rows"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_rows == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : rows; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_rows);
        ((IntAttribute)_att_rows).setCMLValue(value);
    }
    /** Number of rows.
    *
    * 
    * --type info--
    * 
    * The size of an array.
    * The size of an array. Redundant, but serves as a check for processing software (useful if delimiters are used).
    * MinInclusive: 0

    * @param value rows value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setRows(String value) throws CMLRuntimeException {
            CMLAttribute _att_rows = new IntAttribute((IntAttribute)CMLAttributeList.getAttribute("rows"));
            if (_att_rows == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : rows; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_rows);
        ((IntAttribute)_att_rows).setCMLValue(value);
    }
    /** Number of columns.
    *
    * 
    * --type info--
    * 
    * The size of an array.
    * The size of an array. Redundant, but serves as a check for processing software (useful if delimiters are used).
    * MinInclusive: 0

    * @return CMLAttribute
    */
    public CMLAttribute getColumnsAttribute() {
        return (CMLAttribute) getAttribute("columns");
    }
    /** Number of columns.
    *
    * 
    * --type info--
    * 
    * The size of an array.
    * The size of an array. Redundant, but serves as a check for processing software (useful if delimiters are used).
    * MinInclusive: 0

    * @return int
    */
    public int getColumns() {
        CMLAttribute _att_columns = (CMLAttribute) getAttribute("columns");
        if (_att_columns == null) {
            CMLUtil.BUG("unset attribute: columns");
        }
        return ((IntAttribute)_att_columns).getInt();
    }
    /** Number of columns.
    *
    * 
    * --type info--
    * 
    * The size of an array.
    * The size of an array. Redundant, but serves as a check for processing software (useful if delimiters are used).
    * MinInclusive: 0

    * @param value columns value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setColumns(int value) throws CMLRuntimeException {
            CMLAttribute _att_columns = null;
            try {
        		_att_columns = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("columns"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_columns == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : columns; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_columns);
        ((IntAttribute)_att_columns).setCMLValue(value);
    }
    /** Number of columns.
    *
    * 
    * --type info--
    * 
    * The size of an array.
    * The size of an array. Redundant, but serves as a check for processing software (useful if delimiters are used).
    * MinInclusive: 0

    * @param value columns value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setColumns(String value) throws CMLRuntimeException {
            CMLAttribute _att_columns = new IntAttribute((IntAttribute)CMLAttributeList.getAttribute("columns"));
            if (_att_columns == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : columns; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_columns);
        ((IntAttribute)_att_columns).setCMLValue(value);
    }
    /** A reference to the type of a unit.
    *
    * Used in defining the unit and doing 
    * symbolic algebra on the dimensionality.

    * @return CMLAttribute
    */
    public CMLAttribute getUnitTypeAttribute() {
        return (CMLAttribute) getAttribute("unitType");
    }
    /** A reference to the type of a unit.
    *
    * Used in defining the unit and doing 
    * symbolic algebra on the dimensionality.

    * @return String
    */
    public String getUnitType() {
        CMLAttribute _att_unitType = (CMLAttribute) getAttribute("unitType");
        if (_att_unitType == null) {
            return null;
        }
        return ((StringAttribute)_att_unitType).getString();
    }
    /** A reference to the type of a unit.
    *
    * Used in defining the unit and doing 
    * symbolic algebra on the dimensionality.

    * @param value unitType value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setUnitType(String value) throws CMLRuntimeException {
            CMLAttribute _att_unitType = null;
            try {
        		_att_unitType = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("unitType"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_unitType == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : unitType; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_unitType);
        ((StringAttribute)_att_unitType).setCMLValue(value);
    }
    /** minimum exclusive value.
    *
    * by analogy with xsd:schema.

    * @return CMLAttribute
    */
    public CMLAttribute getMinExclusiveAttribute() {
        return (CMLAttribute) getAttribute("minExclusive");
    }
    /** minimum exclusive value.
    *
    * by analogy with xsd:schema.

    * @return double
    */
    public double getMinExclusive() {
        CMLAttribute _att_minExclusive = (CMLAttribute) getAttribute("minExclusive");
        if (_att_minExclusive == null) {
            return Double.NaN;
        }
        return ((DoubleAttribute)_att_minExclusive).getDouble();
    }
    /** minimum exclusive value.
    *
    * by analogy with xsd:schema.

    * @param value minExclusive value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setMinExclusive(double value) throws CMLRuntimeException {
            CMLAttribute _att_minExclusive = null;
            try {
        		_att_minExclusive = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("minExclusive"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_minExclusive == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : minExclusive; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_minExclusive);
        ((DoubleAttribute)_att_minExclusive).setCMLValue(value);
    }
    /** minimum exclusive value.
    *
    * by analogy with xsd:schema.

    * @param value minExclusive value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setMinExclusive(String value) throws CMLRuntimeException {
            CMLAttribute _att_minExclusive = new DoubleAttribute((DoubleAttribute)CMLAttributeList.getAttribute("minExclusive"));
            if (_att_minExclusive == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : minExclusive; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_minExclusive);
        ((DoubleAttribute)_att_minExclusive).setCMLValue(value);
    }
    /** minimum inclusive value.
    *
    * by analogy with xsd:schema.

    * @return CMLAttribute
    */
    public CMLAttribute getMinInclusiveAttribute() {
        return (CMLAttribute) getAttribute("minInclusive");
    }
    /** minimum inclusive value.
    *
    * by analogy with xsd:schema.

    * @return double
    */
    public double getMinInclusive() {
        CMLAttribute _att_minInclusive = (CMLAttribute) getAttribute("minInclusive");
        if (_att_minInclusive == null) {
            return Double.NaN;
        }
        return ((DoubleAttribute)_att_minInclusive).getDouble();
    }
    /** minimum inclusive value.
    *
    * by analogy with xsd:schema.

    * @param value minInclusive value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setMinInclusive(double value) throws CMLRuntimeException {
            CMLAttribute _att_minInclusive = null;
            try {
        		_att_minInclusive = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("minInclusive"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_minInclusive == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : minInclusive; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_minInclusive);
        ((DoubleAttribute)_att_minInclusive).setCMLValue(value);
    }
    /** minimum inclusive value.
    *
    * by analogy with xsd:schema.

    * @param value minInclusive value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setMinInclusive(String value) throws CMLRuntimeException {
            CMLAttribute _att_minInclusive = new DoubleAttribute((DoubleAttribute)CMLAttributeList.getAttribute("minInclusive"));
            if (_att_minInclusive == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : minInclusive; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_minInclusive);
        ((DoubleAttribute)_att_minInclusive).setCMLValue(value);
    }
    /** maximum exclusive value.
    *
    * by analogy with xsd:schema.

    * @return CMLAttribute
    */
    public CMLAttribute getMaxExclusiveAttribute() {
        return (CMLAttribute) getAttribute("maxExclusive");
    }
    /** maximum exclusive value.
    *
    * by analogy with xsd:schema.

    * @return double
    */
    public double getMaxExclusive() {
        CMLAttribute _att_maxExclusive = (CMLAttribute) getAttribute("maxExclusive");
        if (_att_maxExclusive == null) {
            return Double.NaN;
        }
        return ((DoubleAttribute)_att_maxExclusive).getDouble();
    }
    /** maximum exclusive value.
    *
    * by analogy with xsd:schema.

    * @param value maxExclusive value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setMaxExclusive(double value) throws CMLRuntimeException {
            CMLAttribute _att_maxExclusive = null;
            try {
        		_att_maxExclusive = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("maxExclusive"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_maxExclusive == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : maxExclusive; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_maxExclusive);
        ((DoubleAttribute)_att_maxExclusive).setCMLValue(value);
    }
    /** maximum exclusive value.
    *
    * by analogy with xsd:schema.

    * @param value maxExclusive value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setMaxExclusive(String value) throws CMLRuntimeException {
            CMLAttribute _att_maxExclusive = new DoubleAttribute((DoubleAttribute)CMLAttributeList.getAttribute("maxExclusive"));
            if (_att_maxExclusive == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : maxExclusive; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_maxExclusive);
        ((DoubleAttribute)_att_maxExclusive).setCMLValue(value);
    }
    /** minimum inclusive value.
    *
    * by analogy with xsd:schem.

    * @return CMLAttribute
    */
    public CMLAttribute getMaxInclusiveAttribute() {
        return (CMLAttribute) getAttribute("maxInclusive");
    }
    /** minimum inclusive value.
    *
    * by analogy with xsd:schem.

    * @return double
    */
    public double getMaxInclusive() {
        CMLAttribute _att_maxInclusive = (CMLAttribute) getAttribute("maxInclusive");
        if (_att_maxInclusive == null) {
            return Double.NaN;
        }
        return ((DoubleAttribute)_att_maxInclusive).getDouble();
    }
    /** minimum inclusive value.
    *
    * by analogy with xsd:schem.

    * @param value maxInclusive value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setMaxInclusive(double value) throws CMLRuntimeException {
            CMLAttribute _att_maxInclusive = null;
            try {
        		_att_maxInclusive = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("maxInclusive"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_maxInclusive == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : maxInclusive; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_maxInclusive);
        ((DoubleAttribute)_att_maxInclusive).setCMLValue(value);
    }
    /** minimum inclusive value.
    *
    * by analogy with xsd:schem.

    * @param value maxInclusive value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setMaxInclusive(String value) throws CMLRuntimeException {
            CMLAttribute _att_maxInclusive = new DoubleAttribute((DoubleAttribute)CMLAttributeList.getAttribute("maxInclusive"));
            if (_att_maxInclusive == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : maxInclusive; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_maxInclusive);
        ((DoubleAttribute)_att_maxInclusive).setCMLValue(value);
    }
    /** total digits in a scalar.
    *
    * based on xsd:schema.
    * --type info--
    * 
    * MinExclusive: 0

    * @return CMLAttribute
    */
    public CMLAttribute getTotalDigitsAttribute() {
        return (CMLAttribute) getAttribute("totalDigits");
    }
    /** total digits in a scalar.
    *
    * based on xsd:schema.
    * --type info--
    * 
    * MinExclusive: 0

    * @return int
    */
    public int getTotalDigits() {
        CMLAttribute _att_totalDigits = (CMLAttribute) getAttribute("totalDigits");
        if (_att_totalDigits == null) {
            CMLUtil.BUG("unset attribute: totalDigits");
        }
        return ((IntAttribute)_att_totalDigits).getInt();
    }
    /** total digits in a scalar.
    *
    * based on xsd:schema.
    * --type info--
    * 
    * MinExclusive: 0

    * @param value totalDigits value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setTotalDigits(int value) throws CMLRuntimeException {
            CMLAttribute _att_totalDigits = null;
            try {
        		_att_totalDigits = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("totalDigits"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_totalDigits == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : totalDigits; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_totalDigits);
        ((IntAttribute)_att_totalDigits).setCMLValue(value);
    }
    /** total digits in a scalar.
    *
    * based on xsd:schema.
    * --type info--
    * 
    * MinExclusive: 0

    * @param value totalDigits value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setTotalDigits(String value) throws CMLRuntimeException {
            CMLAttribute _att_totalDigits = new IntAttribute((IntAttribute)CMLAttributeList.getAttribute("totalDigits"));
            if (_att_totalDigits == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : totalDigits; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_totalDigits);
        ((IntAttribute)_att_totalDigits).setCMLValue(value);
    }
    /** Number of digits after the point.
    *
    * This is used in dictionaries to define precision. However it might be replaced by xsd:facet.
    * --type info--
    * 
    * MinInclusive: 0

    * @return CMLAttribute
    */
    public CMLAttribute getFractionDigitsAttribute() {
        return (CMLAttribute) getAttribute("fractionDigits");
    }
    /** Number of digits after the point.
    *
    * This is used in dictionaries to define precision. However it might be replaced by xsd:facet.
    * --type info--
    * 
    * MinInclusive: 0

    * @return int
    */
    public int getFractionDigits() {
        CMLAttribute _att_fractionDigits = (CMLAttribute) getAttribute("fractionDigits");
        if (_att_fractionDigits == null) {
            CMLUtil.BUG("unset attribute: fractionDigits");
        }
        return ((IntAttribute)_att_fractionDigits).getInt();
    }
    /** Number of digits after the point.
    *
    * This is used in dictionaries to define precision. However it might be replaced by xsd:facet.
    * --type info--
    * 
    * MinInclusive: 0

    * @param value fractionDigits value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setFractionDigits(int value) throws CMLRuntimeException {
            CMLAttribute _att_fractionDigits = null;
            try {
        		_att_fractionDigits = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("fractionDigits"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_fractionDigits == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : fractionDigits; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_fractionDigits);
        ((IntAttribute)_att_fractionDigits).setCMLValue(value);
    }
    /** Number of digits after the point.
    *
    * This is used in dictionaries to define precision. However it might be replaced by xsd:facet.
    * --type info--
    * 
    * MinInclusive: 0

    * @param value fractionDigits value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setFractionDigits(String value) throws CMLRuntimeException {
            CMLAttribute _att_fractionDigits = new IntAttribute((IntAttribute)CMLAttributeList.getAttribute("fractionDigits"));
            if (_att_fractionDigits == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : fractionDigits; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_fractionDigits);
        ((IntAttribute)_att_fractionDigits).setCMLValue(value);
    }
    /** Length of a scalar.
    *
    * Probably will be replaced with xsd:schema tool.
    * --type info--
    * 
    * MinInclusive: 0

    * @return CMLAttribute
    */
    public CMLAttribute getLengthAttribute() {
        return (CMLAttribute) getAttribute("length");
    }
    /** Length of a scalar.
    *
    * Probably will be replaced with xsd:schema tool.
    * --type info--
    * 
    * MinInclusive: 0

    * @return int
    */
    public int getLength() {
        CMLAttribute _att_length = (CMLAttribute) getAttribute("length");
        if (_att_length == null) {
            CMLUtil.BUG("unset attribute: length");
        }
        return ((IntAttribute)_att_length).getInt();
    }
    /** Length of a scalar.
    *
    * Probably will be replaced with xsd:schema tool.
    * --type info--
    * 
    * MinInclusive: 0

    * @param value length value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setLength(int value) throws CMLRuntimeException {
            CMLAttribute _att_length = null;
            try {
        		_att_length = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("length"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_length == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : length; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_length);
        ((IntAttribute)_att_length).setCMLValue(value);
    }
    /** Length of a scalar.
    *
    * Probably will be replaced with xsd:schema tool.
    * --type info--
    * 
    * MinInclusive: 0

    * @param value length value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setLength(String value) throws CMLRuntimeException {
            CMLAttribute _att_length = new IntAttribute((IntAttribute)CMLAttributeList.getAttribute("length"));
            if (_att_length == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : length; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_length);
        ((IntAttribute)_att_length).setCMLValue(value);
    }
    /** minimum length of a scalar.
    *
    * by analogy with xsd:schema.
    * --type info--
    * 
    * MinInclusive: 0

    * @return CMLAttribute
    */
    public CMLAttribute getMinLengthAttribute() {
        return (CMLAttribute) getAttribute("minLength");
    }
    /** minimum length of a scalar.
    *
    * by analogy with xsd:schema.
    * --type info--
    * 
    * MinInclusive: 0

    * @return int
    */
    public int getMinLength() {
        CMLAttribute _att_minLength = (CMLAttribute) getAttribute("minLength");
        if (_att_minLength == null) {
            CMLUtil.BUG("unset attribute: minLength");
        }
        return ((IntAttribute)_att_minLength).getInt();
    }
    /** minimum length of a scalar.
    *
    * by analogy with xsd:schema.
    * --type info--
    * 
    * MinInclusive: 0

    * @param value minLength value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setMinLength(int value) throws CMLRuntimeException {
            CMLAttribute _att_minLength = null;
            try {
        		_att_minLength = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("minLength"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_minLength == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : minLength; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_minLength);
        ((IntAttribute)_att_minLength).setCMLValue(value);
    }
    /** minimum length of a scalar.
    *
    * by analogy with xsd:schema.
    * --type info--
    * 
    * MinInclusive: 0

    * @param value minLength value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setMinLength(String value) throws CMLRuntimeException {
            CMLAttribute _att_minLength = new IntAttribute((IntAttribute)CMLAttributeList.getAttribute("minLength"));
            if (_att_minLength == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : minLength; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_minLength);
        ((IntAttribute)_att_minLength).setCMLValue(value);
    }
    /** maximum length of a scalar.
    *
    * by analogy with xsd:schem.
    * --type info--
    * 
    * MinExclusive: 0

    * @return CMLAttribute
    */
    public CMLAttribute getMaxLengthAttribute() {
        return (CMLAttribute) getAttribute("maxLength");
    }
    /** maximum length of a scalar.
    *
    * by analogy with xsd:schem.
    * --type info--
    * 
    * MinExclusive: 0

    * @return int
    */
    public int getMaxLength() {
        CMLAttribute _att_maxLength = (CMLAttribute) getAttribute("maxLength");
        if (_att_maxLength == null) {
            CMLUtil.BUG("unset attribute: maxLength");
        }
        return ((IntAttribute)_att_maxLength).getInt();
    }
    /** maximum length of a scalar.
    *
    * by analogy with xsd:schem.
    * --type info--
    * 
    * MinExclusive: 0

    * @param value maxLength value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setMaxLength(int value) throws CMLRuntimeException {
            CMLAttribute _att_maxLength = null;
            try {
        		_att_maxLength = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("maxLength"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_maxLength == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : maxLength; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_maxLength);
        ((IntAttribute)_att_maxLength).setCMLValue(value);
    }
    /** maximum length of a scalar.
    *
    * by analogy with xsd:schem.
    * --type info--
    * 
    * MinExclusive: 0

    * @param value maxLength value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setMaxLength(String value) throws CMLRuntimeException {
            CMLAttribute _att_maxLength = new IntAttribute((IntAttribute)CMLAttributeList.getAttribute("maxLength"));
            if (_att_maxLength == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : maxLength; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_maxLength);
        ((IntAttribute)_att_maxLength).setCMLValue(value);
    }
    /** Scientific units on an element.
    *
    * These must be taken from a dictionary 
    * of units. There should be some mechanism for validating the type 
    * of the units against the possible values of the element.
    * --type info--
    * 
    * Scientific units.
    * These will be linked to dictionaries of 
    * units with conversion information, using namespaced references 
    * (e.g. si:m). Distinguish carefully from _unitType_ 
    * which is an element describing a type of a unit in a 
    * _unitList_.

    * @return CMLAttribute
    */
    public CMLAttribute getUnitsAttribute() {
        return (CMLAttribute) getAttribute("units");
    }
    /** Scientific units on an element.
    *
    * These must be taken from a dictionary 
    * of units. There should be some mechanism for validating the type 
    * of the units against the possible values of the element.
    * --type info--
    * 
    * Scientific units.
    * These will be linked to dictionaries of 
    * units with conversion information, using namespaced references 
    * (e.g. si:m). Distinguish carefully from _unitType_ 
    * which is an element describing a type of a unit in a 
    * _unitList_.

    * @return String
    */
    public String getUnits() {
        CMLAttribute _att_units = (CMLAttribute) getAttribute("units");
        if (_att_units == null) {
            return null;
        }
        return ((StringAttribute)_att_units).getString();
    }
    /** Scientific units on an element.
    *
    * These must be taken from a dictionary 
    * of units. There should be some mechanism for validating the type 
    * of the units against the possible values of the element.
    * --type info--
    * 
    * Scientific units.
    * These will be linked to dictionaries of 
    * units with conversion information, using namespaced references 
    * (e.g. si:m). Distinguish carefully from _unitType_ 
    * which is an element describing a type of a unit in a 
    * _unitList_.

    * @param value units value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setUnits(String value) throws CMLRuntimeException {
            CMLAttribute _att_units = null;
            try {
        		_att_units = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("units"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_units == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : units; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_units);
        ((StringAttribute)_att_units).setCMLValue(value);
    }
    /** Whitespace.
    *
    * Attached to entry. This may be obsolete.

    * @return CMLAttribute
    */
    public CMLAttribute getWhiteSpaceAttribute() {
        return (CMLAttribute) getAttribute("whiteSpace");
    }
    /** Whitespace.
    *
    * Attached to entry. This may be obsolete.

    * @return String
    */
    public String getWhiteSpace() {
        CMLAttribute _att_whiteSpace = (CMLAttribute) getAttribute("whiteSpace");
        if (_att_whiteSpace == null) {
            return null;
        }
        return ((StringAttribute)_att_whiteSpace).getString();
    }
    /** Whitespace.
    *
    * Attached to entry. This may be obsolete.

    * @param value whiteSpace value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setWhiteSpace(String value) throws CMLRuntimeException {
            CMLAttribute _att_whiteSpace = null;
            try {
        		_att_whiteSpace = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("whiteSpace"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_whiteSpace == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : whiteSpace; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_whiteSpace);
        ((StringAttribute)_att_whiteSpace).setCMLValue(value);
    }
    /** Pattern constraint.
    *
    * Based on xsd:schema.

    * @return CMLAttribute
    */
    public CMLAttribute getPatternAttribute() {
        return (CMLAttribute) getAttribute("pattern");
    }
    /** Pattern constraint.
    *
    * Based on xsd:schema.

    * @return String
    */
    public String getPattern() {
        CMLAttribute _att_pattern = (CMLAttribute) getAttribute("pattern");
        if (_att_pattern == null) {
            return null;
        }
        return ((StringAttribute)_att_pattern).getString();
    }
    /** Pattern constraint.
    *
    * Based on xsd:schema.

    * @param value pattern value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setPattern(String value) throws CMLRuntimeException {
            CMLAttribute _att_pattern = null;
            try {
        		_att_pattern = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("pattern"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_pattern == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : pattern; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_pattern);
        ((StringAttribute)_att_pattern).setCMLValue(value);
    }
    /** A term in a dictionary.
    *
    * The term should be a noun or nounal phrase, with a separate definition and further description.

    * @return CMLAttribute
    */
    public CMLAttribute getTermAttribute() {
        return (CMLAttribute) getAttribute("term");
    }
    /** A term in a dictionary.
    *
    * The term should be a noun or nounal phrase, with a separate definition and further description.

    * @return String
    */
    public String getTerm() {
        CMLAttribute _att_term = (CMLAttribute) getAttribute("term");
        if (_att_term == null) {
            return null;
        }
        return ((StringAttribute)_att_term).getString();
    }
    /** A term in a dictionary.
    *
    * The term should be a noun or nounal phrase, with a separate definition and further description.

    * @param value term value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setTerm(String value) throws CMLRuntimeException {
            CMLAttribute _att_term = null;
            try {
        		_att_term = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("term"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_term == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : term; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_term);
        ((StringAttribute)_att_term).setCMLValue(value);
    }
    /** add entry element.
    *
    * @param alternative alternative child to add

    */
    public void addAlternative(AbstractAlternative alternative) {
        alternative.detach();
        this.appendChild(alternative);
    }
    /** get entry child elements .
    *
    * @return CMLElements<CMLAlternative>
    */
    public CMLElements<CMLAlternative> getAlternativeElements() {
        Elements elements = this.getChildElements("alternative", CML_NS);
        return new CMLElements<CMLAlternative>(elements);
    }
    /** add entry element.
    *
    * @param relatedEntry relatedEntry child to add

    */
    public void addRelatedEntry(AbstractRelatedEntry relatedEntry) {
        relatedEntry.detach();
        this.appendChild(relatedEntry);
    }
    /** get entry child elements .
    *
    * @return CMLElements<CMLRelatedEntry>
    */
    public CMLElements<CMLRelatedEntry> getRelatedEntryElements() {
        Elements elements = this.getChildElements("relatedEntry", CML_NS);
        return new CMLElements<CMLRelatedEntry>(elements);
    }
    /** add entry element.
    *
    * @param annotation annotation child to add

    */
    public void addAnnotation(AbstractAnnotation annotation) {
        annotation.detach();
        this.appendChild(annotation);
    }
    /** get entry child elements .
    *
    * @return CMLElements<CMLAnnotation>
    */
    public CMLElements<CMLAnnotation> getAnnotationElements() {
        Elements elements = this.getChildElements("annotation", CML_NS);
        return new CMLElements<CMLAnnotation>(elements);
    }
    /** add entry element.
    *
    * @param metadataList metadataList child to add

    */
    public void addMetadataList(AbstractMetadataList metadataList) {
        metadataList.detach();
        this.appendChild(metadataList);
    }
    /** get entry child elements .
    *
    * @return CMLElements<CMLMetadataList>
    */
    public CMLElements<CMLMetadataList> getMetadataListElements() {
        Elements elements = this.getChildElements("metadataList", CML_NS);
        return new CMLElements<CMLMetadataList>(elements);
    }
    /** add entry element.
    *
    * @param description description child to add

    */
    public void addDescription(AbstractDescription description) {
        description.detach();
        this.appendChild(description);
    }
    /** get entry child elements .
    *
    * @return CMLElements<CMLDescription>
    */
    public CMLElements<CMLDescription> getDescriptionElements() {
        Elements elements = this.getChildElements("description", CML_NS);
        return new CMLElements<CMLDescription>(elements);
    }
    /** add entry element.
    *
    * @param definition definition child to add

    */
    public void addDefinition(AbstractDefinition definition) {
        definition.detach();
        this.appendChild(definition);
    }
    /** get entry child elements .
    *
    * @return CMLElements<CMLDefinition>
    */
    public CMLElements<CMLDefinition> getDefinitionElements() {
        Elements elements = this.getChildElements("definition", CML_NS);
        return new CMLElements<CMLDefinition>(elements);
    }
    /** add entry element.
    *
    * @param enumeration enumeration child to add

    */
    public void addEnumeration(AbstractEnumeration enumeration) {
        enumeration.detach();
        this.appendChild(enumeration);
    }
    /** get entry child elements .
    *
    * @return CMLElements<CMLEnumeration>
    */
    public CMLElements<CMLEnumeration> getEnumerationElements() {
        Elements elements = this.getChildElements("enumeration", CML_NS);
        return new CMLElements<CMLEnumeration>(elements);
    }
    /** overrides addAttribute(Attribute).
    *
    * reroutes calls to setFoo()

    * @param att  attribute

    */
    public void addAttribute(Attribute att) {
        String name = att.getLocalName();
        String value = att.getValue();
        if (name == null) {
        } else if (name.equals("title")) {
            setTitle(value);
        } else if (name.equals("id")) {
            setId(value);
        } else if (name.equals("convention")) {
            setConvention(value);
        } else if (name.equals("dataType")) {
            setDataType(value);
        } else if (name.equals("rows")) {
            setRows(value);
        } else if (name.equals("columns")) {
            setColumns(value);
        } else if (name.equals("unitType")) {
            setUnitType(value);
        } else if (name.equals("minExclusive")) {
            setMinExclusive(value);
        } else if (name.equals("minInclusive")) {
            setMinInclusive(value);
        } else if (name.equals("maxExclusive")) {
            setMaxExclusive(value);
        } else if (name.equals("maxInclusive")) {
            setMaxInclusive(value);
        } else if (name.equals("totalDigits")) {
            setTotalDigits(value);
        } else if (name.equals("fractionDigits")) {
            setFractionDigits(value);
        } else if (name.equals("length")) {
            setLength(value);
        } else if (name.equals("minLength")) {
            setMinLength(value);
        } else if (name.equals("maxLength")) {
            setMaxLength(value);
        } else if (name.equals("units")) {
            setUnits(value);
        } else if (name.equals("whiteSpace")) {
            setWhiteSpace(value);
        } else if (name.equals("pattern")) {
            setPattern(value);
        } else if (name.equals("term")) {
            setTerm(value);
        } else {
            super.addAttribute(att);
        }
    }
}
