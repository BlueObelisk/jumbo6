package org.xmlcml.cml.element;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

import nu.xom.Element;
import nu.xom.Elements;
import nu.xom.Node;

import org.xmlcml.cml.base.CMLElement;
import org.xmlcml.cml.base.CMLElements;

/**
 * user-modifiable class supporting propertyList. * autogenerated from schema
 * use as a shell which can be edited
 * 
 */
public class CMLPropertyList extends AbstractPropertyList {

    /**
     * constructor.
     */
    public CMLPropertyList() {
    }

    /**
     * constructor.
     * 
     * @param old
     */
    public CMLPropertyList(CMLPropertyList old) {
        super((AbstractPropertyList) old);

    }

    /**
     * copy node .
     * 
     * @return Node
     */
    public Node copy() {
        return new CMLPropertyList(this);

    }

    /**
     * create new instance in context of parent, overridable by subclasses.
     * 
     * @param parent
     *            parent of element to be constructed (ignored by default)
     * @return CMLPropertyList
     */
    public static CMLPropertyList makeElementInContext(Element parent) {
        return new CMLPropertyList();

    }

    /**
     * gets all nested property descendants of arbitrary CMLElement.
     * 
     * recurses through all propertyList and property children, adding the
     * latter to the list. Order is not preserved.
     * 
     * @return list of all descendants
     */
    public List<CMLProperty> getPropertyDescendants() {
        List<CMLProperty> mList = new ArrayList<CMLProperty>();
        CMLElements<CMLPropertyList> propertyLists = this
                .getPropertyListElements();
        for (CMLPropertyList ml : propertyLists) {
            mList.addAll(ml.getPropertyDescendants());
        }
        CMLElements<CMLProperty> propertys = this.getPropertyElements();
        for (CMLProperty m : propertys) {
            mList.add(m);
        }
        return mList;
    }

    /**
     * gets all nested property descendants of arbitrary CMLElement.
     * 
     * recurses through all propertyList and property children, adding the
     * latter to the list. Order is not preserved.
     * 
     * @param parent
     *            with property(List) children
     * @return list of all descendants
     */
    public static List<CMLProperty> getPropertyDescendants(CMLElement parent) {
        List<CMLProperty> mList = new ArrayList<CMLProperty>();
        Elements propertyLists = parent
                .getChildCMLElements(CMLPropertyList.TAG);
        for (int i = 0; i < propertyLists.size(); i++) {
            CMLPropertyList propertyList = (CMLPropertyList) propertyLists
                    .get(i);
            mList.addAll(propertyList.getPropertyDescendants());
        }
        // generally property should be under propertyList parent
        Elements propertys = parent.getChildCMLElements(CMLProperty.TAG);
        for (int i = 0; i < propertys.size(); i++) {
            mList.add((CMLProperty) propertys.get(i));
        }
        return mList;
    }

    /**
     * gets property elements with a given dictRef. if either param is null,
     * returns empty list
     * 
     * @param propertyList
     *            list to filter
     * @param dictRef
     *            value of dictRef attribute
     * @return filtered list
     */
    public static List<CMLProperty> getPropertyDescendantsByDictRef(
            List<CMLProperty> propertyList, String dictRef) {
        List<CMLProperty> newPropertyList = new ArrayList<CMLProperty>();
        if (dictRef != null && propertyList != null) {
            for (CMLProperty property : propertyList) {
                if (dictRef.equals(property.getDictRef())) {
                    newPropertyList.add(property);
                }
            }
        }
        return newPropertyList;
    }

    /**
     * gets property elements with a given dictRef. if dictRef is null returns
     * empty list
     * 
     * @param dictRef
     *            value of dictRef attribute
     * @return filtered list
     */
    public List<CMLProperty> getPropertyDescendantsByName(String dictRef) {
        return getPropertyDescendantsByDictRef(this.getPropertyDescendants(),
                dictRef);
    }

    /**
     * checks a file for valid dictRefs. checks that all dictRefs in a file
     * resolve. ? Not used?
     * 
     * @param file
     *            to check
     * @param dictionaryMap
     * @return list of errors (empty if none)
     */
    public static List<String> checkPropertyNames(File file,
            DictionaryMap dictionaryMap) {
        List<String> errorList = new ArrayList<String>();

        CMLCml cml = null;
        try {
            cml = (CMLCml) new CMLBuilder().build(file).getRootElement();
        } catch (Exception e) {
            e.printStackTrace();
            errorList.add("should not throw " + e);
        }
        if (errorList.size() == 0) {
            // scalars
            List<CMLElement> propertys = cml.getElements(".//cml:property");
            for (CMLElement property : propertys) {
                DictRefAttribute dictRefAttribute = (DictRefAttribute) ((CMLProperty) property)
                        .getDictRefAttribute();
                // System.out.println("N"+dictRefAttribute);
                if (dictRefAttribute == null) {
                    errorList.add("NULL NAME: " + "[" + property.toXML() + "]");
                } else {
                    CMLEntry entry = (CMLEntry) dictionaryMap
                            .getEntry(dictRefAttribute);
                    if (entry == null) {
                        errorList.add("NOTFOUND "
                                + dictRefAttribute.getQualifiedName() + "["
                                + property.toXML() + "]");
                    } else {
                        // System.out.println("FOUND "+dictRefAttribute);
                    }
                }
            }
        }
        return errorList;
    }
}
