// /*======AUTOGENERATED FROM SCHEMA; DO NOT EDIT BELOW THIS LINE ======*/
package org.xmlcml.cml.element;

import nu.xom.Element;
import nu.xom.Node;

import org.xmlcml.cml.base.CMLElements;
import org.xmlcml.cml.base.CMLRuntimeException;
import org.xmlcml.cml.base.CMLUtil;

/**
 * Unmarked content of a table.
 * 
 * 
 * \n Metadata for rows must be defined in tableHeader. The elements of the\n
 * table are ASCII strings in this content. They can be separated by
 * whitespace\n or by a defined single character delimiter (see array for more
 * information).\n \n
 * 
 * user-modifiable class autogenerated from schema if no class exists use as a
 * shell which can be edited the autogeneration software will not overwrite an
 * existing class file
 * 
 */
public class CMLTableContent extends AbstractTableContent {

    /**
     * must give simple documentation.
     * 
     * 
     */

    public CMLTableContent() {
    }

    /**
     * must give simple documentation.
     * 
     * @param old
     *            CMLTableContent to copy
     * 
     */

    public CMLTableContent(CMLTableContent old) {
        super((AbstractTableContent) old);
    }

    /**
     * copy node .
     * 
     * @return Node
     */
    public Node copy() {
        return new CMLTableContent(this);
    }

    /**
     * create new instance in context of parent, overridable by subclasses.
     * 
     * @param parent
     *            parent of element to be constructed (ignored by default)
     * @return CMLTableContent
     */
    public static CMLTableContent makeElementInContext(Element parent) {
        return new CMLTableContent();
    }

    /** sets delimiter if non-nul or non-whitespace.
     * if delim is null or whitespace removes the attribute
     * @param delim 
     */
    public void setDelimiter(String delim) {
        if (delim == null || S_EMPTY.equals(delim.trim())) {
            this.removeAttribute("delimiter");
        } else {
            super.setDelimiter(delim);
        }
    }
    
    /**
     * get content as strings. not yet edited for delimiters
     * 
     * @return strings
     */
    public String[] getStrings() {
        String content = this.getStringContent().trim();
        String delimiter = (this.getDelimiterAttribute() == null) 
            ? S_WHITEREGEX : this.getDelimiter();
        // trim leading and trailing delimiters
        if (content.startsWith(delimiter)) {
            content = content.substring(1);
        }
        if (content.startsWith(delimiter)) {
            content = content.substring(0, content.length()-1);
        }
        return content.split(delimiter);
    }

    /** create populated tableRowList.
     * 
     * @param rowCount
     * @param columnCount
     * @return tableRowList (may be empty)
     */
    public CMLTableRowList createTableRowList(int rowCount, int columnCount) {
        CMLTableRowList tableRowList = new CMLTableRowList();
        String[] strings = this.getStrings();
        checkRectangular(rowCount, columnCount, strings.length);
        int count = 0;
        for (int i = 0; i < rowCount; i++) {
            CMLTableRow tableRow = new CMLTableRow();
            tableRowList.appendChild(tableRow);
            for (int j = 0; j < columnCount; j++) {
                CMLTableCell tableCell = new CMLTableCell();
                CMLUtil.setXMLContent(tableCell, strings[count++]);
                tableRow.appendChild(tableCell);
            }
        }
        return tableRowList;
    }

    private void checkRectangular(int rowCount, int columnCount, int total) {
        if (rowCount * columnCount != total) {
            throw new CMLRuntimeException("non rectangular table: " +
                    +rowCount +" * "+ columnCount +" != "+total);
        }
    }

    /** create populated arrayList.
     * 
     * @param rowCount
     * @param columnCount
     * @param tableHeader
     * @return arrayList may be empty
     */
    public CMLArrayList createArrayList(
            int rowCount, int columnCount, CMLTableHeader tableHeader) {
        CMLArrayList arrayList = new CMLArrayList();
        String[] strings = this.getStrings();
        checkRectangular(rowCount, columnCount, strings.length);
        CMLElements<CMLTableHeaderCell> tableHeaderCells = 
            tableHeader.getTableHeaderCellElements();
        int headerColumnCount = tableHeaderCells.size();
        if (headerColumnCount != columnCount) {
            throw new CMLRuntimeException(
                "inconsistent column count ("+columnCount+" != "+headerColumnCount);
        }
        for (int j = 0; j < columnCount; j++) {
            CMLArray array = new CMLArray(tableHeaderCells.get(j), this.getDelimiter());
            String dataType = tableHeaderCells.get(j).getDataType();
            arrayList.appendChild(array);
            for (int i = 0; i < rowCount; i++) {
                addToArray(array, dataType, strings[j + i * columnCount]);
            }
        }
        return arrayList;
    }
    
    private void addToArray(CMLArray array, String dataType, String s) {
        try {
            if (XSD_DOUBLE.equals(dataType)) {
                double d = new Double(s).doubleValue();
                array.append(d);
            } else if (XSD_INTEGER.equals(dataType)) {
                int i = Integer.parseInt(s);
                array.append(i);
            } else {
                array.append(s);
            }
        } catch (Exception e) {
            throw new CMLRuntimeException(
                    "wrong data type ["+s+"]["+dataType+S_RSQUARE+e.getMessage());
        }
    }
     
    StringBuilder sb = null;
    void append(String s, String delimiter) {
        String dd = (delimiter == null || 
                S_EMPTY.equals(delimiter.trim())) ? S_SPACE : delimiter;
        if (sb == null) {
            sb = new StringBuilder();
        } else {
            sb.append(dd);
        }
        sb.append(s);
    }
    
    void finishAppendingStrings(String delimiter) {
        if (sb != null) {
            if (delimiter != null) {
                sb.append(delimiter);
            }
            this.setXMLContent(sb.toString());
        }
        sb = null;
    }
}
