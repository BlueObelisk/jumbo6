// /*======AUTOGENERATED FROM SCHEMA; DO NOT EDIT BELOW THIS LINE ======*/
package org.xmlcml.cml.element;

import java.util.ArrayList;
import java.util.List;

import nu.xom.Element;
import nu.xom.Elements;
import nu.xom.Node;

import org.xmlcml.cml.base.CMLElements;
import org.xmlcml.cml.base.CMLRuntimeException;
import org.xmlcml.cml.base.CMLUtil;
import org.xmlcml.cml.tools.FragmentTool;

/** A container for one or more fragments and joins.
*
* 
* \n \nfragmentList can contain several fragments and joins. \nThe normal content model is\n \njoin fragment join fragment...\n \n
* 
* user-modifiable class autogenerated from schema if no class exists
* use as a shell which can be edited
* the autogeneration software will not overwrite an existing class file

*/
public class CMLFragmentList extends org.xmlcml.cml.element.AbstractFragmentList {

    /** must give simple documentation.
    *

    */

    public CMLFragmentList() {
    }
    /** must give simple documentation.
    *
    * @param old CMLFragmentList to copy

    */

    public CMLFragmentList(CMLFragmentList old) {
        super((org.xmlcml.cml.element.AbstractFragmentList) old);
    }

    /** copy node .
    *
    * @return Node
    */
    public Node copy() {
        return new CMLFragmentList(this);
    }
    /** create new instance in context of parent, overridable by subclasses.
    *
    * @param parent parent of element to be constructed (ignored by default)
    * @return CMLFragmentList
    */
    public static CMLFragmentList makeElementInContext(Element parent) {
        return new CMLFragmentList();
    }

    /** recursive process joins.
     * 
     * @param parent
     */
    public void recursivelyCreateAtomsRefs2OnJoins(CMLMolecule parent) {
//      <fragment>
//          <molecule ref="g:benzene" id="m1" />
//          <fragmentList>
//              <join id="j1" order="1" moleculeRefs2="PARENT NEXT" atomRefs2="r1 r1">
//                  <length>1.4</length>
//                  <angle id="l2.1.1" atomRefs3="a2 r1 r1">115</angle>
//              </join>
//              <fragment>
//                  <molecule ref="g:po" id="m3" />
//              </fragment>
          
        Elements childs = this.getChildElements();
        for (int i = 0; i < childs.size(); i++) {
            Element child = childs.get(i);
            if (child instanceof CMLJoin) {
                CMLJoin join = (CMLJoin)child;
                join.dereferenceMoleculeRefs2AndAtomRefs2(parent);
            } else if (child instanceof CMLFragment) {
                FragmentTool fragmentTool = new FragmentTool((CMLFragment)child);
                fragmentTool.recursivelyCreateAtomsRefs2OnJoins(parent);
            }
        }
    }
    
    /** flatten recursively.
     */
    public void flattenFragmentDescendants() {
        CMLElements<CMLFragment> fragments = this.getFragmentElements();
        for (CMLFragment fragment : fragments) {
            FragmentTool fragmentTool = new FragmentTool(fragment);
            fragmentTool.flattenFragmentListDescendants();
            CMLUtil.transferChildren(fragment, this);
        }
    }
    
    /** clone content of element with CountExpression and append.
     * clones the element content and appends to original element content
     * significant children can only be join-fragment-join-fragment...join
     * if FragmentLIst occurs only once (either explicitly or after application of
     * countExpression its contents are interpreted as
     * [J*1-F1-J12-F2-J23-F3] and any trailing join is ignored
     * if count is greater that one
     * syntax should be [JP1-F1-J12-F2-J21]n
     * 
     * @param element to process
     * @throws CMLRuntimeException null element or bad attribute
     */
    public void processCountExpression() throws CMLRuntimeException {
        CountExpressionAttribute cea = (CountExpressionAttribute) 
            this.getAttribute(CountExpressionAttribute.NAME);
        int count = cea.calculateCountExpression();
        int nChild = this.getChildCount();
        if (nChild %2 != 1) {
            throw new CMLRuntimeException("Must have odd number of join-frag-join children");
        }
        List<CMLJoin> joinList = new ArrayList<CMLJoin>();
        List<CMLFragment> fragList = new ArrayList<CMLFragment>();
        // make lists of Join and Fragment children; check they alternate JFJF...J
        int nsig = 0;
        for (int j = 0; j < nChild; j++) {
            Node newChild = this.getChild(j).copy();
            if (newChild instanceof CMLJoin) {
                if (nsig %2 != 0) {
                    throw new CMLRuntimeException("unexpected JOIN after: "+nsig+" significant children");
                } 
                joinList.add((CMLJoin) newChild);
                nsig++;
            } else if (newChild instanceof CMLFragment) {
                if (nsig %2 != 1) {
                    throw new CMLRuntimeException("unexpected FRAG after: "+nsig+" significant children");
                } 
                fragList.add((CMLFragment) newChild);
                nsig++;
            }
        }
        for (int i = 1; i < count; i++) {
            for (int j = 0; j < nChild; j++) {
                Node newChild = this.getChild(j).copy();
                if (nsig %2 == 0) {
                    if (!(newChild instanceof CMLJoin)) {
                        throw new CMLRuntimeException("expected JOIN found: "+newChild);
                    }
                    CMLJoin join = (CMLJoin) newChild;
                    String[] att = join.getMoleculeRefs2();
                    att[0] = "PREVIOUS";
                    join.setMoleculeRefs2(att);
                }
                this.appendChild(newChild);
            }
        }
        cea.detach();
    }

}
