package org.xmlcml.cml.element;

import java.io.IOException;
import java.io.Writer;

import nu.xom.Element;
import nu.xom.Node;

import org.xmlcml.cml.base.CMLElements;
import org.xmlcml.cml.base.CMLRuntimeException;

/**
 * user-modifiable class supporting unitType. * autogenerated from schema use as
 * a shell which can be edited
 * 
 */
public class CMLUnitType extends AbstractUnitType implements GenericEntry {

	/** namespaced element name.*/
	public final static String NS = C_E+TAG;
	
    /**
     * unit without valis CMLUnitType.
     * 
     */
    public static CMLUnitType UNKNOWN_PARENT = null;

    static {
        UNKNOWN_PARENT = new CMLUnitType();
        UNKNOWN_PARENT.setId("unknownParentSI");
        UNKNOWN_PARENT.setTitle("unknown parentSI");
    };

    /**
     * contructor.
     */
    public CMLUnitType() {
        this.setParentSI("si:unknown");
    }

    /**
     * contructor.
     * 
     * @param old
     */
    public CMLUnitType(CMLUnitType old) {
        super((AbstractUnitType) old);

    }

    /**
     * copy node .
     * 
     * @return Node
     */
    public Node copy() {
        return new CMLUnitType(this);

    }

    /**
     * create new instance in context of parent, overridable by subclasses.
     * 
     * @param parent
     *            parent of element to be constructed (ignored by default)
     * @return CMLUnitType
     */
    public static CMLUnitType makeElementInContext(Element parent) {
        return new CMLUnitType();
    }

    /**
     * writes table header for units dictionary as HTML.
     * 
     * @param w
     *            writer
     * @throws IOException
     */
    static void writeHTMLTableHeader(Writer w) throws IOException {
        w.write("<tr>" + "<th>id</th>" + "<th>name</th>" + "<th>abbrev</th>"
                + "<th>type</th>" + "<th>title</th>" + "<th>multSI</th>"
                + "<th>SI</th>" + "<th>description</th>" + "</tr>\n");
    }

    /**
     * writes units dictionary as HTML.
     * 
     * @param w
     *            writer
     * @throws IOException
     */
    public void writeHTML(Writer w) throws IOException {
        CMLElements<CMLDefinition> definitions = this.getDefinitionElements();
        CMLDefinition definition = (definitions.size() > 0) ? definitions
                .get(0) : null;
        String def = (definition == null) ? "" : definition.getStringContent();
        w.write("<tr>" + "<td><b>" + this.getId() + "</b></td>" + "<td><b>"
                + this.getName() + "</b></td>" + "<td>"
                + this.getAbbreviation() + "</td>" + "<td>" + this.getTitle()
                + "</td>" + "<td>" + this.getParentSI() + "</td>" + "<td>"
                + def + "</td>" + "</tr>\n");
    }

    /**
     * gets id. traps missing id and throws runtime.
     * 
     * @return id
     * @throws CMLRuntimeException
     *             missing id
     */
    public String getId() {
        String id = super.getId();
        if (id == null) {
            throw new CMLRuntimeException("unit must have id: " + this.toXML());
        }
        return id;
    }

    /** gets containing CMLUnitTypeList.
     * 
     * @return parent unitList
     * @throws CMLRuntimeException does not have a parent list
     */
    public CMLUnitTypeList getParentCMLUnitTypeList() {
        Node parent = this.getParent();
        CMLUnitTypeList parentUnitTypeList = (
                parent != null && parent instanceof CMLUnitTypeList) ?
                        (CMLUnitTypeList) parent
                : null;
        if (parentUnitTypeList == null) {
            throw new CMLRuntimeException("unit " + this.getId()
                    + " must be contained within a unitTypeList");
        }
        return (parent instanceof CMLUnitTypeList) ? (CMLUnitTypeList) parent : null;
    }

    /**
     * adds dimensions from another unitType. normally 'this' is a new UnitType
     * to which dimensions are added when units are composed.
     * 
     * @param unitType
     *            to provide dimensions
     * @param power
     *            to multiply unitType dimensions
     */
    public void composeDimensionsFrom(CMLUnitType unitType, int power) {
        if (unitType != null) {
            CMLElements<CMLDimension> dimensions = unitType
                    .getDimensionElements();
            for (CMLDimension dimension : dimensions) {
                this.composeDimensionsFrom(dimension, power);
            }
        }
    }

    /**
     * incorporate dimension into dimensions of this. if dimension has name 'dd'
     * and this has a dimenesion of the same name with power pp, the power will
     * be incremented to pp+(dimension.getPower()*power) and re-stored. If there
     * is no dimension, then a new child is added with power
     * dimension.getPower()*power
     * 
     * @param dimension
     *            to compose
     * @param power
     *            of composed dimension. This multiplies the power in
     *            dimension.getPower();
     */
    public void composeDimensionsFrom(CMLDimension dimension, int power) {
        if (dimension == null) {
            throw new CMLRuntimeException("dimension must not be null");
        }
        String newName = dimension.getName();
        if (newName == null) {
            throw new CMLRuntimeException("dimension " + dimension.getId()
                    + " must have name");
        }
        CMLElements<CMLDimension> thisDimensions = this.getDimensionElements();
        boolean found = false;
        for (CMLDimension thisDimension : thisDimensions) {
            if (newName.equals(thisDimension.getName())) {
                int pp = (int) Math.round(thisDimension.getPower() + power);
                thisDimension.setPower(pp);
                found = true;
                break;
            }
        }
        if (!found) {
            CMLDimension newDimension = new CMLDimension(dimension);
            int pp = (int) Math.round(dimension.getPower() * power);
            newDimension.setPower(pp);
            this.appendChild(newDimension);
        }
    }
}
