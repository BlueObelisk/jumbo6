package org.xmlcml.cml.element;

import nu.xom.Attribute;
import org.xmlcml.cml.base.*;
import java.util.HashMap;
import java.util.Map;

/** An internal or external link to other objects.
*
* 
* \n \nSemantics are similar to XLink, but simpler and only a subset is implemented.\n This is intended to make the instances easy to create and read, and software \nrelatively easy to implement. The architecture is:\n \n\nA single element (link) used for all linking purposes.\n \nThe link types are determined by the type attribute and can be:. \n\nlocator. This points to a single target and must carry either a ref or href attribute. \nlocator links are usually children of an extended link.\n arc. This is a 1:1 link with both ends (from and to) defined.\n \nextended. This is usually a parent of several locator links and serves\n to create a grouping of link ends (i.e. a list of references in documents).\n Many-many links can be built up from arcs linking extended elements\n \nAll links can have optional role attributes. The semantics of this are not defined;\n you are encouraged to use a URI as described in the XLink specification.\n There are two address spaces: \n\nThe href attribute on locators behaves in the same way as href in\n HTML and is of type xsd:anyURI. Its primary use is to use XPointer to reference\n elements outside the document.\n The ref attribute on locators and the from and to\n attributes on arcs refer to IDs (without the '#' syntax).\n \n\nNote: several other specific linking mechanisms are defined elsewhere in STM. relatedEntry should be used in dictionaries, and dictRef\n should be used to link to dictionaries. There are no required uses of link in STMML\n but we have used it to map atoms, electrons and bonds in reactions in CML\n \n\n\nRelation to XLink.\n At present (2002) we are not aware of generic XLink\n processors from which we would benefit, so the complete implementation brings little\n extra value. \nAmong the simplifications from Xlink are:\n \n\ntype supports only extended, locator and arc\n \n\nlabel is not supported and ids are used as targets of links.\n \nshow and actuate are not supported.\n \nxlink:title is not supported (all STM elements can have a title\n attribute).\n \nxlink:role supports any string (i.e. does not have to be a namespaced resource).\n This mechanism can, of course, still be used and we shall promote it where STM \nbenefits from it\n The to and from attributes point to IDs rather than labels\n The xlink namespace is not used\n It is not intended to create independent linkbases, although some collections of\n links may have this property and stand outside the documents they link to\n 
* 
* NON-MOFIFIABLE class autogenerated from schema
* DO NOT EDIT; ADD FUNCTIONALITY TO SUBCLASS

*/
public abstract class AbstractLink extends CMLElement {

// fields;
    /** table mapping attribute names to attributegroup names*/
    public static Map<String, String> attributeGroupNameTable = new HashMap<String, String>();
    /** local name*/
    public final static String TAG = "link";
    /** default constructor.
    *
    * creates element initially without parent


    */

    public AbstractLink() {
        super("link");
    }
    /** copy constructor.
    *
    * deep copy using XOM copy()

    * @param old AbstractLink to copy

    */

    public AbstractLink(AbstractLink old) {
        super((CMLElement) old);
    }

    static {
        attributeGroupNameTable.put("title", "title");
        attributeGroupNameTable.put("id", "id");
        attributeGroupNameTable.put("convention", "convention");
        attributeGroupNameTable.put("dictRef", "dictRef");
        attributeGroupNameTable.put("from", "from");
        attributeGroupNameTable.put("to", "to");
        attributeGroupNameTable.put("ref", "ref");
        attributeGroupNameTable.put("fromType", "fromType");
        attributeGroupNameTable.put("toType", "toType");
        attributeGroupNameTable.put("fromSet", "fromSet");
        attributeGroupNameTable.put("toSet", "toSet");
        attributeGroupNameTable.put("fromContext", "fromContext");
        attributeGroupNameTable.put("toContext", "toContext");
        attributeGroupNameTable.put("role", "role");
        attributeGroupNameTable.put("href", "href");
        attributeGroupNameTable.put("linkType", "linkType");
    };
    /** get attributeGroupName from attributeName.
    *
    * @param attributeName attribute name
    * @return String
    */
    public String getAttributeGroupName(String attributeName) {
            return attributeGroupNameTable.get(attributeName);
    }
    /** A title on an element.
    *
    * No controlled value.

    * @return CMLAttribute
    */
    public CMLAttribute getTitleAttribute() {
        return (CMLAttribute) getAttribute("title");
    }
    /** A title on an element.
    *
    * No controlled value.

    * @return String
    */
    public String getTitle() {
        CMLAttribute _att_title = (CMLAttribute) getAttribute("title");
        if (_att_title == null) {
            return null;
        }
        return ((StringAttribute)_att_title).getString();
    }
    /** A title on an element.
    *
    * No controlled value.

    * @param value title value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setTitle(String value) throws CMLRuntimeException {
            CMLAttribute _att_title = null;
            try {
        		_att_title = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("title"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_title == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : title; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_title);
        ((StringAttribute)_att_title).setCMLValue(value);
    }
    /** A unique ID for an element.
    *
    * Id is used for machine identification of elements and
    *  in general should not have application semantics. It is similar to the XML ID type
    *  as containing only alphanumerics, '_', ',' and '-' and and must start with an
    *  alphabetic character. Ids are case sensitive. Ids should be unique within local scope,
    *  thus all atoms within a molecule should have unique ids, but separated molecules within a 
    * document (such as a published article) might have identical ids. Software
    *  should be able to search local scope (e.g. all atoms within a molecule). 
    * However this is under constant review.
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @return CMLAttribute
    */
    public CMLAttribute getIdAttribute() {
        return (CMLAttribute) getAttribute("id");
    }
    /** A unique ID for an element.
    *
    * Id is used for machine identification of elements and
    *  in general should not have application semantics. It is similar to the XML ID type
    *  as containing only alphanumerics, '_', ',' and '-' and and must start with an
    *  alphabetic character. Ids are case sensitive. Ids should be unique within local scope,
    *  thus all atoms within a molecule should have unique ids, but separated molecules within a 
    * document (such as a published article) might have identical ids. Software
    *  should be able to search local scope (e.g. all atoms within a molecule). 
    * However this is under constant review.
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @return String
    */
    public String getId() {
        CMLAttribute _att_id = (CMLAttribute) getAttribute("id");
        if (_att_id == null) {
            return null;
        }
        return ((StringAttribute)_att_id).getString();
    }
    /** A unique ID for an element.
    *
    * Id is used for machine identification of elements and
    *  in general should not have application semantics. It is similar to the XML ID type
    *  as containing only alphanumerics, '_', ',' and '-' and and must start with an
    *  alphabetic character. Ids are case sensitive. Ids should be unique within local scope,
    *  thus all atoms within a molecule should have unique ids, but separated molecules within a 
    * document (such as a published article) might have identical ids. Software
    *  should be able to search local scope (e.g. all atoms within a molecule). 
    * However this is under constant review.
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @param value id value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setId(String value) throws CMLRuntimeException {
            CMLAttribute _att_id = null;
            try {
        		_att_id = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("id"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_id == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : id; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_id);
        ((StringAttribute)_att_id).setCMLValue(value);
    }
    /** A reference to a convention.
    *
    * There is no controlled vocabulary for conventions, but the author must ensure that the semantics are openly available and that there are mechanisms for implementation. The convention is inherited by all the subelements, 
    * so that a convention for molecule would by default extend to its bond and atom children. This can be overwritten
    *  if necessary by an explicit convention.
    *  It may be useful to create conventions with namespaces (e.g. iupac:name).
    *  Use of convention will normally require non-STMML semantics, and should be used with
    *  caution. We would expect that conventions prefixed with "ISO" would be useful,
    *  such as ISO8601 for dateTimes.
    *  There is no default, but the conventions of STMML or the related language (e.g. CML) will be assumed.
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @return CMLAttribute
    */
    public CMLAttribute getConventionAttribute() {
        return (CMLAttribute) getAttribute("convention");
    }
    /** A reference to a convention.
    *
    * There is no controlled vocabulary for conventions, but the author must ensure that the semantics are openly available and that there are mechanisms for implementation. The convention is inherited by all the subelements, 
    * so that a convention for molecule would by default extend to its bond and atom children. This can be overwritten
    *  if necessary by an explicit convention.
    *  It may be useful to create conventions with namespaces (e.g. iupac:name).
    *  Use of convention will normally require non-STMML semantics, and should be used with
    *  caution. We would expect that conventions prefixed with "ISO" would be useful,
    *  such as ISO8601 for dateTimes.
    *  There is no default, but the conventions of STMML or the related language (e.g. CML) will be assumed.
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @return String
    */
    public String getConvention() {
        CMLAttribute _att_convention = (CMLAttribute) getAttribute("convention");
        if (_att_convention == null) {
            return null;
        }
        return ((StringAttribute)_att_convention).getString();
    }
    /** A reference to a convention.
    *
    * There is no controlled vocabulary for conventions, but the author must ensure that the semantics are openly available and that there are mechanisms for implementation. The convention is inherited by all the subelements, 
    * so that a convention for molecule would by default extend to its bond and atom children. This can be overwritten
    *  if necessary by an explicit convention.
    *  It may be useful to create conventions with namespaces (e.g. iupac:name).
    *  Use of convention will normally require non-STMML semantics, and should be used with
    *  caution. We would expect that conventions prefixed with "ISO" would be useful,
    *  such as ISO8601 for dateTimes.
    *  There is no default, but the conventions of STMML or the related language (e.g. CML) will be assumed.
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @param value convention value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setConvention(String value) throws CMLRuntimeException {
            CMLAttribute _att_convention = null;
            try {
        		_att_convention = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("convention"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_convention == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : convention; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_convention);
        ((StringAttribute)_att_convention).setCMLValue(value);
    }
    /** A reference to a dictionary entry.
    *
    * Elements in data instances such as _scalar_ may have a dictRef attribute to point to an entry in a dictionary. To avoid excessive use of (mutable) filenames and URIs we recommend a namespace prefix, mapped to a namespace URI in the normal manner. In this case, of course, the namespace URI must point to a real XML document containing _entry_ elements and validated against STMML Schema.
    *  Where there is concern about the dictionary becoming separated from the document the dictionary entries can be physically included as part of the data instance and the normal XPointer addressing mechanism can be used.
    *  This attribute can also be used on _dictionary_ elements to define the namespace prefix
    * --type info--
    * 
    * An XML QName with required prefix.
    * 
    *  The namespace prefix must start with an alpha character
    *  and can only contain alphanumeric and '_'. The suffix can 
    * have characters from the XML ID specification 
    * (alphanumeric, '_', '.' and '-'
    * Pattern: [A-Za-z][A-Za-z0-9_]*:[A-Za-z][A-Za-z0-9_\.\-]*

    * @return CMLAttribute
    */
    public CMLAttribute getDictRefAttribute() {
        return (CMLAttribute) getAttribute("dictRef");
    }
    /** A reference to a dictionary entry.
    *
    * Elements in data instances such as _scalar_ may have a dictRef attribute to point to an entry in a dictionary. To avoid excessive use of (mutable) filenames and URIs we recommend a namespace prefix, mapped to a namespace URI in the normal manner. In this case, of course, the namespace URI must point to a real XML document containing _entry_ elements and validated against STMML Schema.
    *  Where there is concern about the dictionary becoming separated from the document the dictionary entries can be physically included as part of the data instance and the normal XPointer addressing mechanism can be used.
    *  This attribute can also be used on _dictionary_ elements to define the namespace prefix
    * --type info--
    * 
    * An XML QName with required prefix.
    * 
    *  The namespace prefix must start with an alpha character
    *  and can only contain alphanumeric and '_'. The suffix can 
    * have characters from the XML ID specification 
    * (alphanumeric, '_', '.' and '-'
    * Pattern: [A-Za-z][A-Za-z0-9_]*:[A-Za-z][A-Za-z0-9_\.\-]*

    * @return String
    */
    public String getDictRef() {
        CMLAttribute _att_dictRef = (CMLAttribute) getAttribute("dictRef");
        if (_att_dictRef == null) {
            return null;
        }
        return ((StringAttribute)_att_dictRef).getString();
    }
    /** A reference to a dictionary entry.
    *
    * Elements in data instances such as _scalar_ may have a dictRef attribute to point to an entry in a dictionary. To avoid excessive use of (mutable) filenames and URIs we recommend a namespace prefix, mapped to a namespace URI in the normal manner. In this case, of course, the namespace URI must point to a real XML document containing _entry_ elements and validated against STMML Schema.
    *  Where there is concern about the dictionary becoming separated from the document the dictionary entries can be physically included as part of the data instance and the normal XPointer addressing mechanism can be used.
    *  This attribute can also be used on _dictionary_ elements to define the namespace prefix
    * --type info--
    * 
    * An XML QName with required prefix.
    * 
    *  The namespace prefix must start with an alpha character
    *  and can only contain alphanumeric and '_'. The suffix can 
    * have characters from the XML ID specification 
    * (alphanumeric, '_', '.' and '-'
    * Pattern: [A-Za-z][A-Za-z0-9_]*:[A-Za-z][A-Za-z0-9_\.\-]*

    * @param value dictRef value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setDictRef(String value) throws CMLRuntimeException {
            CMLAttribute _att_dictRef = null;
            try {
        		_att_dictRef = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("dictRef"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_dictRef == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : dictRef; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_dictRef);
        ((StringAttribute)_att_dictRef).setCMLValue(value);
    }
    /** The base of one or more links.
    *
    * On link elements the value is the single id of an element within the document or context specified in map@fromRef attributes. It must identify the element uniquely. The reserved value 'null' implies that no mapping has been provided for the object(s) in the 'to' attribute. This implies no semantics but may be used by software to keep count of which elements have been mapped. For multiple targets use 'fromSet'.
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @return CMLAttribute
    */
    public CMLAttribute getFromAttribute() {
        return (CMLAttribute) getAttribute("from");
    }
    /** The base of one or more links.
    *
    * On link elements the value is the single id of an element within the document or context specified in map@fromRef attributes. It must identify the element uniquely. The reserved value 'null' implies that no mapping has been provided for the object(s) in the 'to' attribute. This implies no semantics but may be used by software to keep count of which elements have been mapped. For multiple targets use 'fromSet'.
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @return String
    */
    public String getFrom() {
        CMLAttribute _att_from = (CMLAttribute) getAttribute("from");
        if (_att_from == null) {
            return null;
        }
        return ((StringAttribute)_att_from).getString();
    }
    /** The base of one or more links.
    *
    * On link elements the value is the single id of an element within the document or context specified in map@fromRef attributes. It must identify the element uniquely. The reserved value 'null' implies that no mapping has been provided for the object(s) in the 'to' attribute. This implies no semantics but may be used by software to keep count of which elements have been mapped. For multiple targets use 'fromSet'.
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @param value from value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setFrom(String value) throws CMLRuntimeException {
            CMLAttribute _att_from = null;
            try {
        		_att_from = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("from"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_from == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : from; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_from);
        ((StringAttribute)_att_from).setCMLValue(value);
    }
    /** On link elements the value is the single id of an element within the document or context specified in map@toContext attributes. It must identify the element uniquely. The reserved value 'null' implies that no mapping has been provided for the object(s) in the 'from' attribute. This implies no semantics but may be used by software to keep count of which elements have been mapped. For multiple targets use 'toSet'.
    *
    * 
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @return CMLAttribute
    */
    public CMLAttribute getToAttribute() {
        return (CMLAttribute) getAttribute("to");
    }
    /** On link elements the value is the single id of an element within the document or context specified in map@toContext attributes. It must identify the element uniquely. The reserved value 'null' implies that no mapping has been provided for the object(s) in the 'from' attribute. This implies no semantics but may be used by software to keep count of which elements have been mapped. For multiple targets use 'toSet'.
    *
    * 
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @return String
    */
    public String getTo() {
        CMLAttribute _att_to = (CMLAttribute) getAttribute("to");
        if (_att_to == null) {
            return null;
        }
        return ((StringAttribute)_att_to).getString();
    }
    /** On link elements the value is the single id of an element within the document or context specified in map@toContext attributes. It must identify the element uniquely. The reserved value 'null' implies that no mapping has been provided for the object(s) in the 'from' attribute. This implies no semantics but may be used by software to keep count of which elements have been mapped. For multiple targets use 'toSet'.
    *
    * 
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @param value to value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setTo(String value) throws CMLRuntimeException {
            CMLAttribute _att_to = null;
            try {
        		_att_to = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("to"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_to == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : to; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_to);
        ((StringAttribute)_att_to).setCMLValue(value);
    }
    /** A reference to an element of given type.
    *
    * ref modifies an element into a reference to an existing element of that type within the document. This is similar to a pointer and it can be thought of a strongly typed hyperlink. It may also be used for "subclassing" or "overriding" elements.
    *  When referring to an element most of the "data" such as attribute values and element content will be on the full instantiated element. Therefore ref (and possibly id) will normally be the only attributes on the pointing element. However there may be some attributes (title, count, etc.) which have useful semantics, but these are element-specific
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @return CMLAttribute
    */
    public CMLAttribute getRefAttribute() {
        return (CMLAttribute) getAttribute("ref");
    }
    /** A reference to an element of given type.
    *
    * ref modifies an element into a reference to an existing element of that type within the document. This is similar to a pointer and it can be thought of a strongly typed hyperlink. It may also be used for "subclassing" or "overriding" elements.
    *  When referring to an element most of the "data" such as attribute values and element content will be on the full instantiated element. Therefore ref (and possibly id) will normally be the only attributes on the pointing element. However there may be some attributes (title, count, etc.) which have useful semantics, but these are element-specific
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @return String
    */
    public String getRef() {
        CMLAttribute _att_ref = (CMLAttribute) getAttribute("ref");
        if (_att_ref == null) {
            return null;
        }
        return ((StringAttribute)_att_ref).getString();
    }
    /** A reference to an element of given type.
    *
    * ref modifies an element into a reference to an existing element of that type within the document. This is similar to a pointer and it can be thought of a strongly typed hyperlink. It may also be used for "subclassing" or "overriding" elements.
    *  When referring to an element most of the "data" such as attribute values and element content will be on the full instantiated element. Therefore ref (and possibly id) will normally be the only attributes on the pointing element. However there may be some attributes (title, count, etc.) which have useful semantics, but these are element-specific
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @param value ref value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setRef(String value) throws CMLRuntimeException {
            CMLAttribute _att_ref = null;
            try {
        		_att_ref = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("ref"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_ref == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : ref; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_ref);
        ((StringAttribute)_att_ref).setCMLValue(value);
    }
    /** The type of the base of a link.
    *
    * The local tagname of the referenced element (e.g. 'molecule' or 'peakGroup'). This acts as a partial check on the integrity of the link. Software can assume that the referenced element is of a given tytpe and can create an object supporting that type. 
    * This attribute can be attached to the 'map' attribute and requires all contained links to be of this type. This can be overridden by a 'toType' attribute on indivdual links, but it may also be useful to split the map into maps od different link types.
    *  
    * --type info--
    * 
    * The name of an XMLElement.
    * 
    *  (Distinguish from a chemical element as in elementTypeType). 
    * Currently used for assigning XMLElement types to references (e.g. to='a1' toType='atom'). 
    * Semantics are not controlled and in principle elements outside the CML tagSet 
    * could be used. Implementers cannot assume that namespace prefixes can be resolved 
    * and default usage is probably the local name.

    * @return CMLAttribute
    */
    public CMLAttribute getFromTypeAttribute() {
        return (CMLAttribute) getAttribute("fromType");
    }
    /** The type of the base of a link.
    *
    * The local tagname of the referenced element (e.g. 'molecule' or 'peakGroup'). This acts as a partial check on the integrity of the link. Software can assume that the referenced element is of a given tytpe and can create an object supporting that type. 
    * This attribute can be attached to the 'map' attribute and requires all contained links to be of this type. This can be overridden by a 'toType' attribute on indivdual links, but it may also be useful to split the map into maps od different link types.
    *  
    * --type info--
    * 
    * The name of an XMLElement.
    * 
    *  (Distinguish from a chemical element as in elementTypeType). 
    * Currently used for assigning XMLElement types to references (e.g. to='a1' toType='atom'). 
    * Semantics are not controlled and in principle elements outside the CML tagSet 
    * could be used. Implementers cannot assume that namespace prefixes can be resolved 
    * and default usage is probably the local name.

    * @return String
    */
    public String getFromType() {
        CMLAttribute _att_fromType = (CMLAttribute) getAttribute("fromType");
        if (_att_fromType == null) {
            return null;
        }
        return ((StringAttribute)_att_fromType).getString();
    }
    /** The type of the base of a link.
    *
    * The local tagname of the referenced element (e.g. 'molecule' or 'peakGroup'). This acts as a partial check on the integrity of the link. Software can assume that the referenced element is of a given tytpe and can create an object supporting that type. 
    * This attribute can be attached to the 'map' attribute and requires all contained links to be of this type. This can be overridden by a 'toType' attribute on indivdual links, but it may also be useful to split the map into maps od different link types.
    *  
    * --type info--
    * 
    * The name of an XMLElement.
    * 
    *  (Distinguish from a chemical element as in elementTypeType). 
    * Currently used for assigning XMLElement types to references (e.g. to='a1' toType='atom'). 
    * Semantics are not controlled and in principle elements outside the CML tagSet 
    * could be used. Implementers cannot assume that namespace prefixes can be resolved 
    * and default usage is probably the local name.

    * @param value fromType value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setFromType(String value) throws CMLRuntimeException {
            CMLAttribute _att_fromType = null;
            try {
        		_att_fromType = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("fromType"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_fromType == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : fromType; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_fromType);
        ((StringAttribute)_att_fromType).setCMLValue(value);
    }
    /** The type of the base of a link.
    *
    * 
    *  The local tagname of the referenced element (e.g. 'molecule' or 'peakGroup'). This acts as a partial check on the integrity of the link. Software can assume that the referenced element is of a given tytpe and can create an object supporting that type.
    *  This attribute can be attached to the 'map' attribute and requires all contained links to be of this type. This can be overridden by a 'toType' attribute on indivdual links, but it may also be useful to split the map into maps od different link types.
    *  
    * --type info--
    * 
    * The name of an XMLElement.
    * 
    *  (Distinguish from a chemical element as in elementTypeType). 
    * Currently used for assigning XMLElement types to references (e.g. to='a1' toType='atom'). 
    * Semantics are not controlled and in principle elements outside the CML tagSet 
    * could be used. Implementers cannot assume that namespace prefixes can be resolved 
    * and default usage is probably the local name.

    * @return CMLAttribute
    */
    public CMLAttribute getToTypeAttribute() {
        return (CMLAttribute) getAttribute("toType");
    }
    /** The type of the base of a link.
    *
    * 
    *  The local tagname of the referenced element (e.g. 'molecule' or 'peakGroup'). This acts as a partial check on the integrity of the link. Software can assume that the referenced element is of a given tytpe and can create an object supporting that type.
    *  This attribute can be attached to the 'map' attribute and requires all contained links to be of this type. This can be overridden by a 'toType' attribute on indivdual links, but it may also be useful to split the map into maps od different link types.
    *  
    * --type info--
    * 
    * The name of an XMLElement.
    * 
    *  (Distinguish from a chemical element as in elementTypeType). 
    * Currently used for assigning XMLElement types to references (e.g. to='a1' toType='atom'). 
    * Semantics are not controlled and in principle elements outside the CML tagSet 
    * could be used. Implementers cannot assume that namespace prefixes can be resolved 
    * and default usage is probably the local name.

    * @return String
    */
    public String getToType() {
        CMLAttribute _att_toType = (CMLAttribute) getAttribute("toType");
        if (_att_toType == null) {
            return null;
        }
        return ((StringAttribute)_att_toType).getString();
    }
    /** The type of the base of a link.
    *
    * 
    *  The local tagname of the referenced element (e.g. 'molecule' or 'peakGroup'). This acts as a partial check on the integrity of the link. Software can assume that the referenced element is of a given tytpe and can create an object supporting that type.
    *  This attribute can be attached to the 'map' attribute and requires all contained links to be of this type. This can be overridden by a 'toType' attribute on indivdual links, but it may also be useful to split the map into maps od different link types.
    *  
    * --type info--
    * 
    * The name of an XMLElement.
    * 
    *  (Distinguish from a chemical element as in elementTypeType). 
    * Currently used for assigning XMLElement types to references (e.g. to='a1' toType='atom'). 
    * Semantics are not controlled and in principle elements outside the CML tagSet 
    * could be used. Implementers cannot assume that namespace prefixes can be resolved 
    * and default usage is probably the local name.

    * @param value toType value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setToType(String value) throws CMLRuntimeException {
            CMLAttribute _att_toType = null;
            try {
        		_att_toType = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("toType"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_toType == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : toType; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_toType);
        ((StringAttribute)_att_toType).setCMLValue(value);
    }
    /** A set of ids representing the base of a link.
    *
    * For a partial mapping where a number of 'from' elements are known to link to a number of 'to' elements it can be useful to aggregate these into a single attribute value. The primary use is to assert that n links exist between a set of n 'from' elements and n 'to' elements but that the precise links are unknown. The semantics of the reference are the same as for 'from' and all the elements must be of the same type (which can be specified with 'fromType' either on the link or the containing map). No order information is implied. In general there will be the same number of idRefs in the 'toSet' and all implicit links will share the same attributes (e.g. 'role'). In many cases the sets will be later split into discrete links thorugh further calculation or experiment (e.g. peak assignment). Sets should never be used as a lazy or concise alternative where the all the links are explicitly known. 
    * 
    * --type info--
    * 
    * An array of ids or idRefs.
    * See idType.

    * @return CMLAttribute
    */
    public CMLAttribute getFromSetAttribute() {
        return (CMLAttribute) getAttribute("fromSet");
    }
    /** A set of ids representing the base of a link.
    *
    * For a partial mapping where a number of 'from' elements are known to link to a number of 'to' elements it can be useful to aggregate these into a single attribute value. The primary use is to assert that n links exist between a set of n 'from' elements and n 'to' elements but that the precise links are unknown. The semantics of the reference are the same as for 'from' and all the elements must be of the same type (which can be specified with 'fromType' either on the link or the containing map). No order information is implied. In general there will be the same number of idRefs in the 'toSet' and all implicit links will share the same attributes (e.g. 'role'). In many cases the sets will be later split into discrete links thorugh further calculation or experiment (e.g. peak assignment). Sets should never be used as a lazy or concise alternative where the all the links are explicitly known. 
    * 
    * --type info--
    * 
    * An array of ids or idRefs.
    * See idType.

    * @return String[]
    */
    public String[] getFromSet() {
        CMLAttribute _att_fromSet = (CMLAttribute) getAttribute("fromSet");
        if (_att_fromSet == null) {
            return null;
        }
        return ((StringArrayAttribute)_att_fromSet).getStringArray();
    }
    /** A set of ids representing the base of a link.
    *
    * For a partial mapping where a number of 'from' elements are known to link to a number of 'to' elements it can be useful to aggregate these into a single attribute value. The primary use is to assert that n links exist between a set of n 'from' elements and n 'to' elements but that the precise links are unknown. The semantics of the reference are the same as for 'from' and all the elements must be of the same type (which can be specified with 'fromType' either on the link or the containing map). No order information is implied. In general there will be the same number of idRefs in the 'toSet' and all implicit links will share the same attributes (e.g. 'role'). In many cases the sets will be later split into discrete links thorugh further calculation or experiment (e.g. peak assignment). Sets should never be used as a lazy or concise alternative where the all the links are explicitly known. 
    * 
    * --type info--
    * 
    * An array of ids or idRefs.
    * See idType.

    * @param value fromSet value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setFromSet(String[] value) throws CMLRuntimeException {
            CMLAttribute _att_fromSet = null;
            try {
        		_att_fromSet = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("fromSet"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_fromSet == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : fromSet; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_fromSet);
        ((StringArrayAttribute)_att_fromSet).setCMLValue(value);
    }
    /** A set of ids representing the base of a link.
    *
    * For a partial mapping where a number of 'from' elements are known to link to a number of 'to' elements it can be useful to aggregate these into a single attribute value. The primary use is to assert that n links exist between a set of n 'from' elements and n 'to' elements but that the precise links are unknown. The semantics of the reference are the same as for 'from' and all the elements must be of the same type (which can be specified with 'fromType' either on the link or the containing map). No order information is implied. In general there will be the same number of idRefs in the 'toSet' and all implicit links will share the same attributes (e.g. 'role'). In many cases the sets will be later split into discrete links thorugh further calculation or experiment (e.g. peak assignment). Sets should never be used as a lazy or concise alternative where the all the links are explicitly known. 
    * 
    * --type info--
    * 
    * An array of ids or idRefs.
    * See idType.

    * @param value fromSet value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setFromSet(String value) throws CMLRuntimeException {
            CMLAttribute _att_fromSet = new StringArrayAttribute((StringArrayAttribute)CMLAttributeList.getAttribute("fromSet"));
            if (_att_fromSet == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : fromSet; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_fromSet);
        ((StringArrayAttribute)_att_fromSet).setCMLValue(value);
    }
    /** A set of ids representing the base of a link.
    *
    * For a partial mapping where a number of 'to' elements are known to link to a number of 'from' elements it can be useful to aggregate these into a single attribute value. The primary use is to assert that n links exist between a set of n 'to' elements and n 'from' elements but that the precise links are unknown. The semantics of the reference are the same as for 'to' and all the elements must be of the same type (which can be specified with 'toType' either on the link or the containing map). No order information is implied. In general there will be the same number of idRefs in the 'fromSet' and all implicit links will share the same attributes (e.g. 'role'). In many cases the sets will be later split into discrete links thorugh further calculation or experiment (e.g. peak assignment). Sets should never be used as a lazy or concise alternative where the all the links are explicitly known. 
    * 
    * --type info--
    * 
    * An array of ids or idRefs.
    * See idType.

    * @return CMLAttribute
    */
    public CMLAttribute getToSetAttribute() {
        return (CMLAttribute) getAttribute("toSet");
    }
    /** A set of ids representing the base of a link.
    *
    * For a partial mapping where a number of 'to' elements are known to link to a number of 'from' elements it can be useful to aggregate these into a single attribute value. The primary use is to assert that n links exist between a set of n 'to' elements and n 'from' elements but that the precise links are unknown. The semantics of the reference are the same as for 'to' and all the elements must be of the same type (which can be specified with 'toType' either on the link or the containing map). No order information is implied. In general there will be the same number of idRefs in the 'fromSet' and all implicit links will share the same attributes (e.g. 'role'). In many cases the sets will be later split into discrete links thorugh further calculation or experiment (e.g. peak assignment). Sets should never be used as a lazy or concise alternative where the all the links are explicitly known. 
    * 
    * --type info--
    * 
    * An array of ids or idRefs.
    * See idType.

    * @return String[]
    */
    public String[] getToSet() {
        CMLAttribute _att_toSet = (CMLAttribute) getAttribute("toSet");
        if (_att_toSet == null) {
            return null;
        }
        return ((StringArrayAttribute)_att_toSet).getStringArray();
    }
    /** A set of ids representing the base of a link.
    *
    * For a partial mapping where a number of 'to' elements are known to link to a number of 'from' elements it can be useful to aggregate these into a single attribute value. The primary use is to assert that n links exist between a set of n 'to' elements and n 'from' elements but that the precise links are unknown. The semantics of the reference are the same as for 'to' and all the elements must be of the same type (which can be specified with 'toType' either on the link or the containing map). No order information is implied. In general there will be the same number of idRefs in the 'fromSet' and all implicit links will share the same attributes (e.g. 'role'). In many cases the sets will be later split into discrete links thorugh further calculation or experiment (e.g. peak assignment). Sets should never be used as a lazy or concise alternative where the all the links are explicitly known. 
    * 
    * --type info--
    * 
    * An array of ids or idRefs.
    * See idType.

    * @param value toSet value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setToSet(String[] value) throws CMLRuntimeException {
            CMLAttribute _att_toSet = null;
            try {
        		_att_toSet = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("toSet"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_toSet == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : toSet; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_toSet);
        ((StringArrayAttribute)_att_toSet).setCMLValue(value);
    }
    /** A set of ids representing the base of a link.
    *
    * For a partial mapping where a number of 'to' elements are known to link to a number of 'from' elements it can be useful to aggregate these into a single attribute value. The primary use is to assert that n links exist between a set of n 'to' elements and n 'from' elements but that the precise links are unknown. The semantics of the reference are the same as for 'to' and all the elements must be of the same type (which can be specified with 'toType' either on the link or the containing map). No order information is implied. In general there will be the same number of idRefs in the 'fromSet' and all implicit links will share the same attributes (e.g. 'role'). In many cases the sets will be later split into discrete links thorugh further calculation or experiment (e.g. peak assignment). Sets should never be used as a lazy or concise alternative where the all the links are explicitly known. 
    * 
    * --type info--
    * 
    * An array of ids or idRefs.
    * See idType.

    * @param value toSet value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setToSet(String value) throws CMLRuntimeException {
            CMLAttribute _att_toSet = new StringArrayAttribute((StringArrayAttribute)CMLAttributeList.getAttribute("toSet"));
            if (_att_toSet == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : toSet; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_toSet);
        ((StringArrayAttribute)_att_toSet).setCMLValue(value);
    }
    /** The context for the 'from' links in a map.
    *
    * A reference to the unique 'id' attribute of an element defining the context for links in a map. This may be required when id attributes may not be unique within a document. The id should either reference an element uniquely or should be taken as the first ancestor (of the map) with such an id.
    *  This is fairly horrid but may be required when documents are assembled without establishing unique ids (e.g. concatenation of files). As an example a map referencing linked atoms in two molecules might use the containing 'reaction' element as its uniquifying context.
    *  
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @return CMLAttribute
    */
    public CMLAttribute getFromContextAttribute() {
        return (CMLAttribute) getAttribute("fromContext");
    }
    /** The context for the 'from' links in a map.
    *
    * A reference to the unique 'id' attribute of an element defining the context for links in a map. This may be required when id attributes may not be unique within a document. The id should either reference an element uniquely or should be taken as the first ancestor (of the map) with such an id.
    *  This is fairly horrid but may be required when documents are assembled without establishing unique ids (e.g. concatenation of files). As an example a map referencing linked atoms in two molecules might use the containing 'reaction' element as its uniquifying context.
    *  
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @return String
    */
    public String getFromContext() {
        CMLAttribute _att_fromContext = (CMLAttribute) getAttribute("fromContext");
        if (_att_fromContext == null) {
            return null;
        }
        return ((StringAttribute)_att_fromContext).getString();
    }
    /** The context for the 'from' links in a map.
    *
    * A reference to the unique 'id' attribute of an element defining the context for links in a map. This may be required when id attributes may not be unique within a document. The id should either reference an element uniquely or should be taken as the first ancestor (of the map) with such an id.
    *  This is fairly horrid but may be required when documents are assembled without establishing unique ids (e.g. concatenation of files). As an example a map referencing linked atoms in two molecules might use the containing 'reaction' element as its uniquifying context.
    *  
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @param value fromContext value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setFromContext(String value) throws CMLRuntimeException {
            CMLAttribute _att_fromContext = null;
            try {
        		_att_fromContext = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("fromContext"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_fromContext == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : fromContext; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_fromContext);
        ((StringAttribute)_att_fromContext).setCMLValue(value);
    }
    /** The context for the 'from' links in a map.
    *
    * A reference to the unique 'id' attribute of an element defining the context for links in a map. This may be required when id attributes may not be unique within a document. The id should either reference an element uniquely or should be taken as the first ancestor (of the map) with such an id.
    *  This is fairly horrid but may be required when documents are assembled without establishing unique ids (e.g. concatenation of files). As an example a map referencing linked atoms in two molecules might use the containing 'reaction' element as its uniquifying context.
    *  
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @return CMLAttribute
    */
    public CMLAttribute getToContextAttribute() {
        return (CMLAttribute) getAttribute("toContext");
    }
    /** The context for the 'from' links in a map.
    *
    * A reference to the unique 'id' attribute of an element defining the context for links in a map. This may be required when id attributes may not be unique within a document. The id should either reference an element uniquely or should be taken as the first ancestor (of the map) with such an id.
    *  This is fairly horrid but may be required when documents are assembled without establishing unique ids (e.g. concatenation of files). As an example a map referencing linked atoms in two molecules might use the containing 'reaction' element as its uniquifying context.
    *  
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @return String
    */
    public String getToContext() {
        CMLAttribute _att_toContext = (CMLAttribute) getAttribute("toContext");
        if (_att_toContext == null) {
            return null;
        }
        return ((StringAttribute)_att_toContext).getString();
    }
    /** The context for the 'from' links in a map.
    *
    * A reference to the unique 'id' attribute of an element defining the context for links in a map. This may be required when id attributes may not be unique within a document. The id should either reference an element uniquely or should be taken as the first ancestor (of the map) with such an id.
    *  This is fairly horrid but may be required when documents are assembled without establishing unique ids (e.g. concatenation of files). As an example a map referencing linked atoms in two molecules might use the containing 'reaction' element as its uniquifying context.
    *  
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @param value toContext value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setToContext(String value) throws CMLRuntimeException {
            CMLAttribute _att_toContext = null;
            try {
        		_att_toContext = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("toContext"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_toContext == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : toContext; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_toContext);
        ((StringAttribute)_att_toContext).setCMLValue(value);
    }
    /** Role of the object.
    *
    * How the object functions or its position in the architecture. No controlled vocabulary.

    * @return CMLAttribute
    */
    public CMLAttribute getRoleAttribute() {
        return (CMLAttribute) getAttribute("role");
    }
    /** Role of the object.
    *
    * How the object functions or its position in the architecture. No controlled vocabulary.

    * @return String
    */
    public String getRole() {
        CMLAttribute _att_role = (CMLAttribute) getAttribute("role");
        if (_att_role == null) {
            return null;
        }
        return ((StringAttribute)_att_role).getString();
    }
    /** Role of the object.
    *
    * How the object functions or its position in the architecture. No controlled vocabulary.

    * @param value role value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setRole(String value) throws CMLRuntimeException {
            CMLAttribute _att_role = null;
            try {
        		_att_role = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("role"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_role == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : role; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_role);
        ((StringAttribute)_att_role).setCMLValue(value);
    }
    /** address of a resource.
    *
    * Links to another element in the same or other file. For dictionary/@dictRef requires the prefix and the physical URI 
    * address to be contained within the same file. We can anticipate that
    *  better mechanisms will arise - perhaps through XMLCatalogs.
    *  At least it works at present.
    * --type info--
    * 
    * Pattern: [a-z]*:.*

    * @return CMLAttribute
    */
    public CMLAttribute getHrefAttribute() {
        return (CMLAttribute) getAttribute("href");
    }
    /** address of a resource.
    *
    * Links to another element in the same or other file. For dictionary/@dictRef requires the prefix and the physical URI 
    * address to be contained within the same file. We can anticipate that
    *  better mechanisms will arise - perhaps through XMLCatalogs.
    *  At least it works at present.
    * --type info--
    * 
    * Pattern: [a-z]*:.*

    * @return String
    */
    public String getHref() {
        CMLAttribute _att_href = (CMLAttribute) getAttribute("href");
        if (_att_href == null) {
            return null;
        }
        return ((StringAttribute)_att_href).getString();
    }
    /** address of a resource.
    *
    * Links to another element in the same or other file. For dictionary/@dictRef requires the prefix and the physical URI 
    * address to be contained within the same file. We can anticipate that
    *  better mechanisms will arise - perhaps through XMLCatalogs.
    *  At least it works at present.
    * --type info--
    * 
    * Pattern: [a-z]*:.*

    * @param value href value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setHref(String value) throws CMLRuntimeException {
            CMLAttribute _att_href = null;
            try {
        		_att_href = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("href"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_href == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : href; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_href);
        ((StringAttribute)_att_href).setCMLValue(value);
    }
    /** The type of the link.
    *
    * 
    * --type info--
    * 
    * A labelled link.
    * Permitted values:
    *   extended
    *   locator
    *   arc

    * @return CMLAttribute
    */
    public CMLAttribute getLinkTypeAttribute() {
        return (CMLAttribute) getAttribute("linkType");
    }
    /** The type of the link.
    *
    * 
    * --type info--
    * 
    * A labelled link.
    * Permitted values:
    *   extended
    *   locator
    *   arc

    * @return String
    */
    public String getLinkType() {
        CMLAttribute _att_linkType = (CMLAttribute) getAttribute("linkType");
        if (_att_linkType == null) {
            return null;
        }
        return ((StringAttribute)_att_linkType).getString();
    }
    /** The type of the link.
    *
    * 
    * --type info--
    * 
    * A labelled link.
    * Permitted values:
    *   extended
    *   locator
    *   arc

    * @param value linkType value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setLinkType(String value) throws CMLRuntimeException {
            CMLAttribute _att_linkType = null;
            try {
        		_att_linkType = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("linkType"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_linkType == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : linkType; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_linkType);
        ((StringAttribute)_att_linkType).setCMLValue(value);
    }
    /** overrides addAttribute(Attribute).
    *
    * reroutes calls to setFoo()

    * @param att  attribute

    */
    public void addAttribute(Attribute att) {
        String name = att.getLocalName();
        String value = att.getValue();
        if (name == null) {
        } else if (name.equals("title")) {
            setTitle(value);
        } else if (name.equals("id")) {
            setId(value);
        } else if (name.equals("convention")) {
            setConvention(value);
        } else if (name.equals("dictRef")) {
            setDictRef(value);
        } else if (name.equals("from")) {
            setFrom(value);
        } else if (name.equals("to")) {
            setTo(value);
        } else if (name.equals("ref")) {
            setRef(value);
        } else if (name.equals("fromType")) {
            setFromType(value);
        } else if (name.equals("toType")) {
            setToType(value);
        } else if (name.equals("fromSet")) {
            setFromSet(value);
        } else if (name.equals("toSet")) {
            setToSet(value);
        } else if (name.equals("fromContext")) {
            setFromContext(value);
        } else if (name.equals("toContext")) {
            setToContext(value);
        } else if (name.equals("role")) {
            setRole(value);
        } else if (name.equals("href")) {
            setHref(value);
        } else if (name.equals("linkType")) {
            setLinkType(value);
        } else {
            super.addAttribute(att);
        }
    }
}
