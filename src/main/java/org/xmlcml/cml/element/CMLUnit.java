package org.xmlcml.cml.element;

import java.io.IOException;
import java.io.Writer;

import nu.xom.Element;
import nu.xom.Node;

import org.xmlcml.cml.attribute.NamespaceRefAttribute;
import org.xmlcml.cml.attribute.ParentSIAttribute;
import org.xmlcml.cml.attribute.UnitTypeAttribute;
import org.xmlcml.cml.attribute.UnitsAttribute;
import org.xmlcml.cml.base.CMLElement;
import org.xmlcml.cml.base.CMLElements;
import org.xmlcml.cml.base.CMLRuntimeException;
import org.xmlcml.cml.interfacex.GenericEntry;
import org.xmlcml.cml.interfacex.HasUnits;
import org.xmlcml.cml.map.NamespaceToUnitListMap;

/**
 * user-modifiable class supporting unit. * autogenerated from schema use as a
 * shell which can be edited
 *
 */
public class CMLUnit extends AbstractUnit implements GenericEntry {

	/** namespaced element name.*/
	public final static String NS = C_E+TAG;

    static String NULL_UNIT_LIST_MAP = "null unitListMap";

    /** common units in chemistry */
    public enum Units {
    	/** mass*/
    	GRAM			("units:g"),
    	/** density*/
    	GRAM_PER_CMCUBED("units:g.cm-3"),
    	/** molarMass*/
    	GRAM_PER_MOLE("units:g.mol-1"),
    	/** volume */
    	CMCUBED			("units:cm3"),
    	/** volume */
    	ML				("units:ml"),
    	/** volume */
    	L				("units:l"),
    	/** amount */
    	MOL				("units:mol"),
    	/** amount */
    	MMOL			("units:mmol"),
    	;
        /** dewisott */
    	public final String value;
    	private Units(String s) {
    		value = s;
    	}
    	/**
    	 * @return string
    	 */
    	public String toString() {
    		return value;
    	}
    };

    /**
     * can be cached within the unit.
     */
    protected NamespaceToUnitListMap unitListMap = null;

    /** contructor.
     */
    public CMLUnit() {
        this.setParentSI("si:unknown");
        this.setUnitType("unitType:unknown");
    }

    /** contructor.
     * use with great care as units should have their unitList parent
     * @param old
     */
    public CMLUnit(CMLUnit old) {
        super((AbstractUnit) old);

    }

    /** copy node .
     * use with great care as units should have their unitList parent
     * @return Node
     */
    public Node copy() {
        return new CMLUnit(this);
    }

    /**
     * create new instance in context of parent, overridable by subclasses.
     *
     * @param parent
     *            parent of element to be constructed (ignored by default)
     * @return CMLUnit
     */
    public CMLElement makeElementInContext(Element parent) {
        return new CMLUnit();
    }

    /**
     * writes table header for units dictionary as HTML.
     *
     * @param w
     *            writer
     * @throws IOException
     */
    static void writeHTMLTableHeader(Writer w) throws IOException {
        w.write("<tr>" + "<th>id</th>" + "<th>title</th>" + "<th>symbol</th>"
                + "<th>unitType</th>" + "<th>multSI</th>" + "<th>SI.id</th>"
                + "<th>description</th>" + "<th>unitType description</th>"
                + "</tr>\n");
    }

    /**
     * writes units dictionary as HTML.
     *
     * @param w writer
     * @throws IOException
     */
    public void writeHTML(Writer w) throws IOException {

        String unitTypeS = dePrefix(this.getUnitType());

        double mult = this.getMultiplierToSI();
        String multS = (mult < 0 || Double.isNaN(mult)) ? "NULL" : "" + mult;

        String parentSIS = dePrefix("" + this.getParentSI());

        CMLElements<CMLDescription> descriptions = this
                .getDescriptionElements();
        CMLDescription description = (descriptions.size() > 0) ? descriptions
                .get(0) : null;
        String desc = (description == null) ? "" : description
                .getStringContent();

        CMLUnitType cmlUnitType = this.getCMLUnitType();
        String cmlUnitTypeS = (cmlUnitType == null) ? null : cmlUnitType
                .getTitle();
        w.write("<tr>" + "<td><b>" + this.getId() + "</b></td>" + "<td><b>"
                + this.getTitle() + "</b></td>" + "<td>" + this.getSymbol()
                + "</td>" + "<td>" + unitTypeS + "</td>" + "<td>" + multS
                + "</td>" + "<td>" + parentSIS + "</td>" + "<td>" + desc
                + "</td>" + "<td>" + cmlUnitTypeS + "</td>" + "</tr>\n");
    }

    private String dePrefix(String ss) {
        String s = ss;
        if (ss != null) {
            int idx = ss.indexOf(S_COLON);
            s = ss.substring(idx + 1);
        }
        return s;
    }

    /**
     * gets id. traps missing id and throws runtime.
     *
     * @return id
     * @throws CMLRuntimeException
     *             missing id
     */
    public String getId() {
        String id = super.getId();
        if (id == null) {
            throw new CMLRuntimeException("unit must have id");
        }
        return id;
    }

    /**
     * gets containing CMLUnitList.
     *
     * @return parent unitList
     * @throws CMLRuntimeException
     *             does not have a parent list
     */
    public CMLUnitList getParentCMLUnitList() {
        Node parent = this.getParent();
        CMLUnitList parentUnitList = (parent != null && parent instanceof CMLUnitList) ? (CMLUnitList) parent
                : null;
        if (parentUnitList == null) {
            throw new CMLRuntimeException("unit " + this.getId()
                    + " must be contained within a unitList");
        }
        return (parent instanceof CMLUnitList) ? (CMLUnitList) parent : null;
    }

    /** get parentSIUnit. requires parent unitList to have an associated
     * unitListMap
     *
     * @return parent SI Unit or null
     */
    public CMLUnit getParentSIUnit() {
        CMLUnit siUnit = null;
        NamespaceRefAttribute siUnitAttribute =
            (NamespaceRefAttribute) this.getParentSIAttribute();
        if (siUnitAttribute != null) {
            CMLUnitList parentList = this.getParentCMLUnitList();
            CMLUnitList siUnitList = parentList.getSIUnitList();
            if (siUnitList == null) {
                NamespaceToUnitListMap unitListMap = this.getUnitListMap();
                if (unitListMap != null) {
                    siUnitList = parentList.getSIUnitList(unitListMap);
                }
            }
            if (siUnitList == null) {
                throw new CMLRuntimeException("must set siUnitList in parent unitList");
            }
            siUnit = siUnitList.getUnit(siUnitAttribute.getIdRef());
        }
        return siUnit;
    }

    /**
     * are unit attributes consistent with being SI. requires parentSI to point
     * to id and multiplier == 1.0
     *
     * @return true is all values not null and consistent
     */
    public boolean isSIUnit() {
        boolean isUnit = false;
        isUnit = this.getMultiplierToSIAttribute() != null;
        if (isUnit) {
            isUnit = (this.getMultiplierToSI() == 1.0);
        }
        if (isUnit) {
            isUnit = false;
            NamespaceRefAttribute parentSIAttribute = (NamespaceRefAttribute) this
                    .getParentSIAttribute();
            if (parentSIAttribute != null) {
                String id = this.getId();
                if (id != null && id.equals(parentSIAttribute.getIdRef())) {
                    isUnit = true;
                }
            }
        }
        return isUnit;
    }

    /** get unit type referenced from unit. may be directly referenced (by
     * unitType attribute) or indirectly by finding parentSI unit and then its
     * type
     *
     * @return the unitType
     */
    public CMLUnitType getCMLUnitType() {
        CMLUnitType unitType = null;
        UnitTypeAttribute unitTypeAttribute =
            (UnitTypeAttribute) this.getUnitTypeAttribute();
        if (unitTypeAttribute == null) {
            System.out.println("NO UNIT TYPE");
            // cannot find unitType, find parentSI
            CMLUnit parentSI = this.getSIUnit();
            if (parentSI != null) {
                try {
                    unitType = parentSI.getCMLUnitType();
                } catch (CMLRuntimeException e) {
                    if (e.getMessage().equals(NULL_UNIT_LIST_MAP)) {
                        unitType = CMLUnitType.UNKNOWN_PARENT;
                    }
                }
            }
        } else {
            NamespaceToUnitListMap unitListMap = null;
            unitListMap = this.getUnitListMap();
            if (unitListMap == null) {
                throw new CMLRuntimeException(NULL_UNIT_LIST_MAP);
            }
            unitType = (CMLUnitType) unitTypeAttribute.getEntry(unitListMap);
        }
        return unitType;
    }

    /** gets the SIUnit. dereferences the parentSI unit.
     *
     * @return the unit
     */
    public CMLUnit getSIUnit() {
        CMLUnit siUnit = null;
        ParentSIAttribute parentSIAttribute =
            (ParentSIAttribute) this.getParentSIAttribute();
        if (parentSIAttribute == null) {
            throw new CMLRuntimeException("Unit: " + this.getId()
                    + " must have parentSI");
        }
        NamespaceToUnitListMap unitListMap = this.getUnitListMap();
        if (unitListMap == null) {
            throw new CMLRuntimeException("Unit: " + this.getId()
                    + " must have associated unitListMap");
        }
        siUnit = (CMLUnit) parentSIAttribute.getEntry(unitListMap);
        return siUnit;
    }

    /**
     * returns super.getPower(). enforces default value of 1.0 if attribute
     * missing.
     *
     * @return the power (default = 1.0)
     */
    public double getPower() {
        if (this.getPowerAttribute() == null) {
            this.setPower(1.0);
        }
        return super.getPower();
    }

    /**
     * get mapping of namespaces onto unitLists.
     *
     * @return map
     */
    public NamespaceToUnitListMap getUnitListMap() {
        if (unitListMap == null) {
            CMLUnitList parentUnitList = this.getParentCMLUnitList();
            unitListMap = parentUnitList.getUnitListMap();
//            for (String ss : unitListMap.keySet()) {
//                System.out.println("UNITLISTMAP_ITEM "+ss);
//            }
        }
        return unitListMap;
    }

    /**
     * set the unitListMap. Be careful before using this to avoid
     * incosnistencies. Currently required for unit composition.
     *
     * @param unitListMap
     */
    public void setUnitListMap(NamespaceToUnitListMap unitListMap) {
        this.unitListMap = unitListMap;
    }

    /**
     * get namespace for unit. Note: this is the unit namespace, not the XML
     * element namespace (which will be CML). It is normally obtained from the
     * namespace prefix or from the dictionary in which the unit occurs.
     *
     * @return the namespace
     */
    public String getNamespace() {
        String namespace = null;
        CMLUnitList parentUnitList = this.getParentCMLUnitList();
        if (parentUnitList != null) {
            namespace = parentUnitList.getNamespace();
        }
        return namespace;
    }

    /**
     * set this as units on elements which can have them. overrides any existing
     * units
     *
     * @param element
     *            to set the units on
     */
    public void setUnitsOn(HasUnits element) {
        String namespaceURI = this.getNamespace();
        String prefix = ((CMLElement) element).getPrefixForNamespace(namespaceURI);
        element.setUnits(prefix, this.getId(), namespaceURI);
    }

    /**
     * computes new unit from child units.
     *
     * <unit id="a.b"> <unit units="units:u1" power="2"/> <unit units="units:u2"
     * power="-1"/> </unit>
     *
     * @param unitListMap
     * @param addUnitType if true, add the new unitType as child
     */
    public void computeUnit(NamespaceToUnitListMap unitListMap, boolean addUnitType) {
        CMLElements<CMLUnit> childUnits = this.getUnitElements();
        // get any multiplier on the unit
        double multiplier = (this.getMultiplierToDataAttribute() != null) ? this
                .getMultiplierToData()
                : 1.0;
        CMLUnitType newUnitType = new CMLUnitType();
        newUnitType.setParentSI("siUnitType:unknown");
        // iterate through child units which define the new unit
        for (CMLUnit childUnit : childUnits) {
            UnitsAttribute unitAttribute = (UnitsAttribute) childUnit
                    .getUnitsAttribute();
            CMLUnit uuu = unitListMap.getUnit(unitAttribute);
            if (uuu == null) {
                throw new CMLRuntimeException("Cannot find unit: " + unitAttribute);
            }
            CMLUnit unitUnit = new CMLUnit(uuu);
            // we have to add the new units so they have a context
            // we remove them later
            this.appendChild(unitUnit);
            unitUnit.setPower(childUnit.getPower());
            unitUnit.setUnitListMap(unitListMap);
            if (unitUnit.getMultiplierToSIAttribute() != null) {
                double mult = unitUnit.getMultiplierToSI();
                double pp = unitUnit.getPower();
                int power = (int) Math.round(pp);
                for (int p = power; p > 0; p--) {
                    multiplier *= mult;
                }
                for (int p = power; p < 0; p++) {
                    multiplier /= mult;
                }
                CMLUnitType childUnitType = unitUnit.getCMLUnitType();
                if (childUnitType != null) {
                    CMLElements<CMLDimension> childDimensions = childUnitType
                            .getDimensionElements();
                    for (CMLDimension childDimension : childDimensions) {
                        newUnitType
                                .composeDimensionsFrom(childDimension, power);
                    }
                } else {
                    throw new CMLRuntimeException("CANNOT FIND UNIT TYPE "
                            + unitUnit.getId());
                }
            }
            unitUnit.detach();
        }
        if (addUnitType) {
            if (this.getUnitTypeElements().size() != 0) {
                throw new CMLRuntimeException("unit already has unitType child");
            }
            this.appendChild(newUnitType);
        }
        this.setMultiplierToSI(multiplier);
    }
}
