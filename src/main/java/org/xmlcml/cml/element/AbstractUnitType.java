package org.xmlcml.cml.element;

import java.util.HashMap;
import java.util.Map;

import nu.xom.Attribute;
import nu.xom.Elements;

import org.xmlcml.cml.base.CMLAttribute;
import org.xmlcml.cml.base.CMLElement;
import org.xmlcml.cml.base.CMLElements;
import org.xmlcml.cml.base.CMLException;
import org.xmlcml.cml.base.CMLRuntimeException;
import org.xmlcml.cml.base.StringAttribute;

/** The type of a scientific unit.
*
* 
* \n Mandatory for SI Units, optional for nonSI units since they should be able to obtain this from their parent. For complex derived units without parents it may be useful.\n Used within a unitList\n Distinguish carefully from unitsType\n which is primarily used for attributes describing the units that elements \ncarry
* 
* NON-MOFIFIABLE class autogenerated from schema
* DO NOT EDIT; ADD FUNCTIONALITY TO SUBCLASS

*/
public abstract class AbstractUnitType extends CMLElement {

// fields;
    /** table mapping attribute names to attributegroup names*/
    public static Map<String, String> attributeGroupNameTable = new HashMap<String, String>();
    /** local name*/
    public final static String TAG = "unitType";
    /** default constructor.
    *
    * creates element initially without parent


    */

    public AbstractUnitType() {
        super("unitType");
    }
    /** copy constructor.
    *
    * deep copy using XOM copy()

    * @param old AbstractUnitType to copy

    */

    public AbstractUnitType(AbstractUnitType old) {
        super((CMLElement) old);
    }

    static {
        attributeGroupNameTable.put(IdAttribute.NAME, "id");
        attributeGroupNameTable.put("name", "name");
        attributeGroupNameTable.put("title", "title");
        attributeGroupNameTable.put("parentSI", "parentSI");
        attributeGroupNameTable.put("abbreviation", "abbreviation");
        attributeGroupNameTable.put("preserve", "preserve");
        attributeGroupNameTable.put("symbol", "symbol");
    };
    /** get attributeGroupName from attributeName.
    *
    * @param attributeName attribute name
    * @return String
    */
    public String getAttributeGroupName(String attributeName) {
            return attributeGroupNameTable.get(attributeName);
    }
    /** A unique ID for an element.
    *
    * Id is used for machine identification of elements and
    *  in general should not have application semantics. It is similar to the XML ID type
    *  as containing only alphanumerics, '_', ',' and '-' and and must start with an
    *  alphabetic character. Ids are case sensitive. Ids should be unique within local scope,
    *  thus all atoms within a molecule should have unique ids, but separated molecules within a 
    * document (such as a published article) might have identical ids. Software
    *  should be able to search local scope (e.g. all atoms within a molecule). 
    * However this is under constant review.
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @return CMLAttribute
    */
    public CMLAttribute getIdAttribute() {
        return (CMLAttribute) getAttribute("id");
    }
    /** A unique ID for an element.
    *
    * Id is used for machine identification of elements and
    *  in general should not have application semantics. It is similar to the XML ID type
    *  as containing only alphanumerics, '_', ',' and '-' and and must start with an
    *  alphabetic character. Ids are case sensitive. Ids should be unique within local scope,
    *  thus all atoms within a molecule should have unique ids, but separated molecules within a 
    * document (such as a published article) might have identical ids. Software
    *  should be able to search local scope (e.g. all atoms within a molecule). 
    * However this is under constant review.
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @return String
    */
    public String getId() {
        CMLAttribute _att_id = (CMLAttribute) getAttribute("id");
        if (_att_id == null) {
            return null;
        }
        return ((StringAttribute)_att_id).getString();
    }
    /** A unique ID for an element.
    *
    * Id is used for machine identification of elements and
    *  in general should not have application semantics. It is similar to the XML ID type
    *  as containing only alphanumerics, '_', ',' and '-' and and must start with an
    *  alphabetic character. Ids are case sensitive. Ids should be unique within local scope,
    *  thus all atoms within a molecule should have unique ids, but separated molecules within a 
    * document (such as a published article) might have identical ids. Software
    *  should be able to search local scope (e.g. all atoms within a molecule). 
    * However this is under constant review.
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @param value id value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setId(String value) throws CMLRuntimeException {
            CMLAttribute _att_id = null;
            try {
        		_att_id = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("id"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_id == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : id; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_id);
        ((StringAttribute)_att_id).setCMLValue(value);
    }
    /** Name of the object.
    *
    * A string by which the object is known. Often a required attribute. The may or may not be a semi-controlled vocabulary.

    * @return CMLAttribute
    */
    public CMLAttribute getNameAttribute() {
        return (CMLAttribute) getAttribute("name");
    }
    /** Name of the object.
    *
    * A string by which the object is known. Often a required attribute. The may or may not be a semi-controlled vocabulary.

    * @return String
    */
    public String getName() {
        CMLAttribute _att_name = (CMLAttribute) getAttribute("name");
        if (_att_name == null) {
            return null;
        }
        return ((StringAttribute)_att_name).getString();
    }
    /** Name of the object.
    *
    * A string by which the object is known. Often a required attribute. The may or may not be a semi-controlled vocabulary.

    * @param value name value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setName(String value) throws CMLRuntimeException {
            CMLAttribute _att_name = null;
            try {
        		_att_name = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("name"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_name == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : name; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_name);
        ((StringAttribute)_att_name).setCMLValue(value);
    }
    /** A title on an element.
    *
    * No controlled value.

    * @return CMLAttribute
    */
    public CMLAttribute getTitleAttribute() {
        return (CMLAttribute) getAttribute("title");
    }
    /** A title on an element.
    *
    * No controlled value.

    * @return String
    */
    public String getTitle() {
        CMLAttribute _att_title = (CMLAttribute) getAttribute("title");
        if (_att_title == null) {
            return null;
        }
        return ((StringAttribute)_att_title).getString();
    }
    /** A title on an element.
    *
    * No controlled value.

    * @param value title value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setTitle(String value) throws CMLRuntimeException {
            CMLAttribute _att_title = null;
            try {
        		_att_title = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("title"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_title == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : title; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_title);
        ((StringAttribute)_att_title).setCMLValue(value);
    }
    /** A dictRef-like reference to the id of the parent SI unit.
    *
    * This parent should occur in this or another dictionary 
    * and be accessible through the dictRef mechanism. This attribute is forbidden 
    * for SI Units themselves. The mechanism holds for base SI units (7) and 
    * all compound (derived) units made by combinations of base Units.
    * --type info--
    * 
    * An XML QName with required prefix.
    * 
    *  The namespace prefix must start with an alpha character
    *  and can only contain alphanumeric and '_'. The suffix can 
    * have characters from the XML ID specification 
    * (alphanumeric, '_', '.' and '-'
    * Pattern: [A-Za-z][A-Za-z0-9_]*:[A-Za-z][A-Za-z0-9_\.\-]*

    * @return CMLAttribute
    */
    public CMLAttribute getParentSIAttribute() {
        return (CMLAttribute) getAttribute("parentSI");
    }
    /** A dictRef-like reference to the id of the parent SI unit.
    *
    * This parent should occur in this or another dictionary 
    * and be accessible through the dictRef mechanism. This attribute is forbidden 
    * for SI Units themselves. The mechanism holds for base SI units (7) and 
    * all compound (derived) units made by combinations of base Units.
    * --type info--
    * 
    * An XML QName with required prefix.
    * 
    *  The namespace prefix must start with an alpha character
    *  and can only contain alphanumeric and '_'. The suffix can 
    * have characters from the XML ID specification 
    * (alphanumeric, '_', '.' and '-'
    * Pattern: [A-Za-z][A-Za-z0-9_]*:[A-Za-z][A-Za-z0-9_\.\-]*

    * @return String
    */
    public String getParentSI() {
        CMLAttribute _att_parentSI = (CMLAttribute) getAttribute("parentSI");
        if (_att_parentSI == null) {
            return null;
        }
        return ((StringAttribute)_att_parentSI).getString();
    }
    /** A dictRef-like reference to the id of the parent SI unit.
    *
    * This parent should occur in this or another dictionary 
    * and be accessible through the dictRef mechanism. This attribute is forbidden 
    * for SI Units themselves. The mechanism holds for base SI units (7) and 
    * all compound (derived) units made by combinations of base Units.
    * --type info--
    * 
    * An XML QName with required prefix.
    * 
    *  The namespace prefix must start with an alpha character
    *  and can only contain alphanumeric and '_'. The suffix can 
    * have characters from the XML ID specification 
    * (alphanumeric, '_', '.' and '-'
    * Pattern: [A-Za-z][A-Za-z0-9_]*:[A-Za-z][A-Za-z0-9_\.\-]*

    * @param value parentSI value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setParentSI(String value) throws CMLRuntimeException {
            CMLAttribute _att_parentSI = null;
            try {
        		_att_parentSI = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("parentSI"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_parentSI == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : parentSI; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_parentSI);
        ((StringAttribute)_att_parentSI).setCMLValue(value);
    }
    /** Abbreviation.
    *
    * Abbreviation for units, terms, etc.

    * @return CMLAttribute
    */
    public CMLAttribute getAbbreviationAttribute() {
        return (CMLAttribute) getAttribute("abbreviation");
    }
    /** Abbreviation.
    *
    * Abbreviation for units, terms, etc.

    * @return String
    */
    public String getAbbreviation() {
        CMLAttribute _att_abbreviation = (CMLAttribute) getAttribute("abbreviation");
        if (_att_abbreviation == null) {
            return null;
        }
        return ((StringAttribute)_att_abbreviation).getString();
    }
    /** Abbreviation.
    *
    * Abbreviation for units, terms, etc.

    * @param value abbreviation value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setAbbreviation(String value) throws CMLRuntimeException {
            CMLAttribute _att_abbreviation = null;
            try {
        		_att_abbreviation = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("abbreviation"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_abbreviation == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : abbreviation; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_abbreviation);
        ((StringAttribute)_att_abbreviation).setCMLValue(value);
    }
    /** Is the dimension preserved during algebra.
    *
    * 
    * --type info--
    * 
    * Permitted values:
    *   true
    *   false

    * @return CMLAttribute
    */
    public CMLAttribute getPreserveAttribute() {
        return (CMLAttribute) getAttribute("preserve");
    }
    /** Is the dimension preserved during algebra.
    *
    * 
    * --type info--
    * 
    * Permitted values:
    *   true
    *   false

    * @return String
    */
    public String getPreserve() {
        CMLAttribute _att_preserve = (CMLAttribute) getAttribute("preserve");
        if (_att_preserve == null) {
            return null;
        }
        return ((StringAttribute)_att_preserve).getString();
    }
    /** Is the dimension preserved during algebra.
    *
    * 
    * --type info--
    * 
    * Permitted values:
    *   true
    *   false

    * @param value preserve value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setPreserve(String value) throws CMLRuntimeException {
            CMLAttribute _att_preserve = null;
            try {
        		_att_preserve = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("preserve"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_preserve == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : preserve; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_preserve);
        ((StringAttribute)_att_preserve).setCMLValue(value);
    }
    /** A symbol.
    *
    * No semantics. However it should contain only 
    * ASCII characters and we may have to develop an escaping mechanism.
    *  Used on _atomicBasisFunction_, _unit_, etc.

    * @return CMLAttribute
    */
    public CMLAttribute getSymbolAttribute() {
        return (CMLAttribute) getAttribute("symbol");
    }
    /** A symbol.
    *
    * No semantics. However it should contain only 
    * ASCII characters and we may have to develop an escaping mechanism.
    *  Used on _atomicBasisFunction_, _unit_, etc.

    * @return String
    */
    public String getSymbol() {
        CMLAttribute _att_symbol = (CMLAttribute) getAttribute("symbol");
        if (_att_symbol == null) {
            return null;
        }
        return ((StringAttribute)_att_symbol).getString();
    }
    /** A symbol.
    *
    * No semantics. However it should contain only 
    * ASCII characters and we may have to develop an escaping mechanism.
    *  Used on _atomicBasisFunction_, _unit_, etc.

    * @param value symbol value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setSymbol(String value) throws CMLRuntimeException {
            CMLAttribute _att_symbol = null;
            try {
        		_att_symbol = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("symbol"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_symbol == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : symbol; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_symbol);
        ((StringAttribute)_att_symbol).setCMLValue(value);
    }
    /** add unitType element.
    *
    * @param dimension dimension child to add

    */
    public void addDimension(AbstractDimension dimension) {
        dimension.detach();
        this.appendChild(dimension);
    }
    /** get unitType child elements .
    *
    * @return CMLElements<CMLDimension>
    */
    public CMLElements<CMLDimension> getDimensionElements() {
        Elements elements = this.getChildElements("dimension", CML_NS);
        return new CMLElements<CMLDimension>(elements);
    }
    /** add unitType element.
    *
    * @param annotation annotation child to add

    */
    public void addAnnotation(AbstractAnnotation annotation) {
        annotation.detach();
        this.appendChild(annotation);
    }
    /** get unitType child elements .
    *
    * @return CMLElements<CMLAnnotation>
    */
    public CMLElements<CMLAnnotation> getAnnotationElements() {
        Elements elements = this.getChildElements("annotation", CML_NS);
        return new CMLElements<CMLAnnotation>(elements);
    }
    /** add unitType element.
    *
    * @param definition definition child to add

    */
    public void addDefinition(AbstractDefinition definition) {
        definition.detach();
        this.appendChild(definition);
    }
    /** get unitType child elements .
    *
    * @return CMLElements<CMLDefinition>
    */
    public CMLElements<CMLDefinition> getDefinitionElements() {
        Elements elements = this.getChildElements("definition", CML_NS);
        return new CMLElements<CMLDefinition>(elements);
    }
    /** add unitType element.
    *
    * @param description description child to add

    */
    public void addDescription(AbstractDescription description) {
        description.detach();
        this.appendChild(description);
    }
    /** get unitType child elements .
    *
    * @return CMLElements<CMLDescription>
    */
    public CMLElements<CMLDescription> getDescriptionElements() {
        Elements elements = this.getChildElements("description", CML_NS);
        return new CMLElements<CMLDescription>(elements);
    }
    /** overrides addAttribute(Attribute).
    *
    * reroutes calls to setFoo()

    * @param att  attribute

    */
    public void addAttribute(Attribute att) {
        String name = att.getLocalName();
        String value = att.getValue();
        if (name == null) {
        } else if (name.equals("id")) {
            setId(value);
        } else if (name.equals("name")) {
            setName(value);
        } else if (name.equals("title")) {
            setTitle(value);
        } else if (name.equals("parentSI")) {
            setParentSI(value);
        } else if (name.equals("abbreviation")) {
            setAbbreviation(value);
        } else if (name.equals("preserve")) {
            setPreserve(value);
        } else if (name.equals("symbol")) {
            setSymbol(value);
        } else {
            super.addAttribute(att);
        }
    }
}
