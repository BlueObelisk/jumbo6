package org.xmlcml.cml.element;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.logging.Logger;

import nu.xom.Attribute;
import nu.xom.Document;
import nu.xom.Element;
import nu.xom.Elements;
import nu.xom.Node;

import org.xmlcml.cml.base.CMLAttribute;
import org.xmlcml.cml.base.CMLElements;
import org.xmlcml.cml.base.CMLException;
import org.xmlcml.cml.base.CMLRuntimeException;
import org.xmlcml.euclid.DoubleTool;
import org.xmlcml.euclid.RealArray;
import org.xmlcml.euclid.Util;
import org.xmlcml.molutil.ChemicalElement;

/**
 * user-modifiable class supporting formula. * The semantics of formula have
 * been updated (2005-10) and the relationship between concise attribute and
 * atomArray children is explicit. This class supports the parsing of a number
 * of current inline structures but does not guarantee correctness as there are
 * no agreed community syntax/semantics. This is a particular problem for
 * charges which could be "2+", "++", "+2", etc. For robust inline interchange
 * ONLY the concise representation is supported.
 *
 * NOTE: The atomArray child, in array format, together with the formalCharge
 * attribute is the primary means of holding the formula. There is now no lazy
 * evaluation. The concise attribute can be autogenerated from the atomArray and
 * formalCharge. If a formula is input with only concise then the atomArray is
 * automatically generated from it.
 */
public class CMLFormula extends AbstractFormula {

    /** namespaced element name.*/
    public final static String NS = C_E+TAG;

    /** */
    public final static int NPLACES = 10;

    /** */
    public final static int NDEC = 4;

    /** type */
    public enum Type {
        /**
         * the simplest representation. an input-only format. parsing is
         * possible but fragile. The charge semantics are not defined. Not
         * recommended for output.
         */
        NOPUNCTUATION("NoPunctuation", "C2H4Cl2"),

        /**
         * another simple representation. an input-only format. parsing is also
         * fragile as charge sematics are not defined. Not recommended for
         * output.
         */
        ELEMENT_COUNT_WHITESPACE("Element Count Whitespace", "C2 H4 Cl2"),

        /**
         * Yet another simple representation. an input-only format. Element
         * counts of 1 should always be given. Fragile as charge field is likely
         * to be undefined. Not recommended for output.
         */
        ELEMENT_WHITESPACE_COUNT("Element Whitespace Count", "C 2 H 4 O 1"),

        /**
         * the format used in concise. recommended as the main output form.
         * Element counts of 1 should always be given. the charge shoudl always
         * be included. See concise.xsd and formulaType.xsd for syntax.
         */
        CONCISE("CML Concise", "C 2 H 3 O 2 -1"),

        /**
         * multipliers for moieties. an input only format. JUMBO will try to
         * parse this correctly but no guarantee is given.
         */
        MULTIPLIED_ELEMENT_COUNT_WHITESPACE(
                "Multiplied Element Whitespace Count",
                "3(C2 H4 Cl2) or (H2 O)3"),
        /**
         * hierarchical formula. an input-only format. JUMBO will try to parse
         * this correctly but no guarantee is given.
         */
        NESTEDBRACKETS("NestedBrackets", "Na2(SO4).10(H2O)"),
        /**
         * an input only format. JUMBO will not yet parse this correctly.
         * comments from IUCr
         *
         * <pre>
         *          _chemical_formula_iupac '[V O (H2 O)5] 2(C7 H5 O6 S), 2H2 O'
         *          _example                    '[Co Re (C12 H22 P)2 (C O)6].0.5C H3 O H'
         *          _definition
         *          ;              Formula expressed in conformance with IUPAC rules for inorganic
         *          and metal-organic compounds where these conflict with the rules
         *          for any other _chemical_formula_ entries. Typically used for
         *          formatting a formula in accordance with journal rules. This
         *          should appear in the data block in addition to the most
         *          appropriate of the other _chemical_formula_ data names.
         * </pre>
         *
         * I do not know how to parse the second example! I think it means 0.5
         * MeOH solvate.
         */
        IUPAC("IUPAC", "[V O (H2 O)5] 2(C7 H5 O6 S), 2H2 O"),

        /**
         * Moiety, used by IUCr. an input-only format. moieties assumed to be
         * comma separated then ELEMENT_COUNT_WHITESPACE, with optional brackets
         * and post or pre-multipliers
         *
         * <pre>
         *          'C46 H50 Cl2 Hg2 N6 O10, 2C2 H6 O, 4H2 O'
         *          'C46 H34 Co N5 O3'
         *          'C18 H25 N O3'
         *          'C12 H17 N4 O S 1+, C6 H2 N3 O7 1-'
         *          'C12 H16 N2 O6, 5(H2 O1)'
         *          &quot;(Cd 2+)3, (C6 N6 Cr 3-)2, 2(H2 O)
         *          'C40 H66 Mo O4 P2'
         * </pre>
         */
        MOIETY("Moiety", "(Cd 2+)3, (C6 N6 Cr 3-)2, 2(H2 O)"),

        /**
         * SubMoiety, used by IUCr. the part of a moiety within the brackets
         * assumed to b ELEMENT_OPTIONALCOUNT followed by optional FORMULA
         */
        SUBMOIETY("SubMoiety", "C6 N6 Cr 3-"),

        /**
         * Structural, used by IUCr. not currently implemented, I think.
         * probably the same as nested brackets
         */
        STRUCTURAL("STRUCTURAL", "Sn (C2 O4) K F"),

        /**
         * any of the above. input-only.
         */
        ANY("Any", "(Cd 2+)3, (C6 N6 Cr 3-)2, 2(H2 O)");

        String type;

        String example;

        Type(String type, String example) {
            this.type = type;
            this.example = example;
        }
    }

    /** sort type */
    public enum Sort {
        /**
         * sort alphabetically. output only. Not sure where this is
         */
        ALPHABETIC_ELEMENTS("Alphabetic Elements", "AgCFHNOS"),

        /**
         * C H and then alphabetically. (output only)
         */
        CHFIRST("C and H first", "CHFNOS");

        String type;

        String example;

        Sort(String type, String example) {
            this.type = type;
            this.example = example;
        }
    }

    static Logger logger = Logger.getLogger(CMLFormula.class.getName());

    // only edit insertion module!

    // marks whether concise has been processed before atomArray hass been read
    boolean processedConcise;

    /**
     * normal constructor.
     *
     *
     */
    public CMLFormula() {
        super();
        init();
    }

    /**
     * Constructor that creates a formula element using the atoms in a molecule.
     * Adds occupancy (default 1.0) to count for each atom Sums charges for
     * atoms; if any are non-zero then sets formalCharge as sum. else if
     * molecule has formalCharge attribute uses this uses hydrogenCount if not
     * null;
     *
     * @param molecule
     *            to analyze
     * @throws CMLRuntimeException
     *             if non-CML elements are present
     */
    public CMLFormula(CMLMolecule molecule) {
        init();
        int formalCharge = Integer.MIN_VALUE;
        // iterate through atoms adding elements, occupancies and charges
        for (CMLAtom atom : molecule.getAtoms()) {
            double occupancy = 1.0;
            if (atom.getOccupancyAttribute() != null) {
                occupancy = atom.getOccupancy();
            }
            if (occupancy <= 0.0) {
                throw new CMLRuntimeException("zero or negative occupancy: " + occupancy);
            }
            String elementType = atom.getElementType();
            if (elementType == null
                    || ChemicalElement.getChemicalElement(elementType) == null) {
                throw new CMLRuntimeException("Missing or invalid elementType: "
                        + elementType);
            }
            this.add(atom.getElementType(), occupancy);
            if (atom.getFormalChargeAttribute() != null) {
                formalCharge += atom.getFormalCharge();
            }
            if (atom.getHydrogenCountAttribute() != null) {
                int hydrogenCount = atom.getHydrogenCount();
                if (hydrogenCount != 0) {
                    this.add("H", hydrogenCount);
                }
            }
        }
        // has the molecule a net computed charge?
        if (formalCharge != Integer.MIN_VALUE) {
            this.setFormalCharge(formalCharge);
        } else if (molecule.getFormalChargeAttribute() != null) {
            this.setFormalCharge(molecule.getFormalCharge());
        }
    }

    /**
     * copy constructor.
     *
     * @param old
     *            to copy
     */
    public CMLFormula(CMLFormula old) {
        this();
        copyAttributesFrom(old);
        // concise will have triggered the creation of atomArray, so detach if
        // necessary
        if (old.getConcise() != null) {
            CMLAtomArray newAtomArray = this.getAtomArrayElements().get(0);
            CMLAtomArray oldAtomArray = old.getAtomArrayElements().get(0);
            if (oldAtomArray != null) {
                this.removeChild(newAtomArray);
            }
        }
        copyChildrenFrom(old);
        copyProperties(old);
    }

    /**
     * copy node .
     *
     * @return Node
     */
    public Node copy() {
        CMLFormula newForm = new CMLFormula(this);
        return newForm;
    }

    /**
     * create new instance in context of parent, overridable by subclasses.
     *
     * @param parent
     *            parent of element to be constructed (ignored by default)
     * @return CMLFormula
     */
    public static CMLFormula makeElementInContext(Element parent) {
        return new CMLFormula();
    }

    /**
     * shouldn't be necessary.
     *
     * @param parent
     *            element
     */
    public void finishMakingElement(Element parent) {
        super.finishMakingElement(parent);
        normalize();
    }

    /**
     * normalizes the formula.
     * <ul>
     * <li> if two or more atomArrays are present throws CMLRuntime</li>
     * <li> if no concise or atomArray is present does nothing.</li>
     * <li> if atomArray is present checks for array format; throws CMLRuntime
     * if not.</li>
     * <li> if concise but not atomArray is present, generates atomArray. If
     * formalCharge is present and in conflict throws CMLRuntime. If non-CML
     * elements are present or elements are duplicated, throws CMLRuntime. If
     * format is wrong (should have been detected already) throws CMLRuntime</li>
     * <li>sorts AtomArray according to CHFIRST</li>
     * <li> generates concise including trailing charge and overwrites any
     * previous version</li>
     * </ul>
     *
     * @throws CMLRuntimeException -
     *             see above
     */
    public void normalize() {
        CMLElements<CMLAtomArray> atomArrays = this.getAtomArrayElements();
        if (atomArrays.size() > 1) {
            throw new CMLRuntimeException(
                    "Only one atomArray child allowed for formula; found: "
                            + atomArrays.size());
        }
        CMLAttribute concise = this.getConciseAttribute();
        if (concise == null && atomArrays.size() == 0) {
            ; // return
        } else {
            CMLAtomArray atomArray = (atomArrays.size() == 0) ? null
                    : atomArrays.get(0);
            int formalCharge = 0;
            if (this.getFormalChargeAttribute() != null) {
                formalCharge = this.getFormalCharge();
            }

            // if no atomArray, create
            if (atomArray == null) {
                atomArray = createAndAddAtomArrayAndFormalChargeFromConcise(concise);
            } else {
                checkAtomArrayFormat(atomArray);
            }
            sortAtomArray(atomArray, Sort.CHFIRST);
            String conciseS = generateConcise(atomArray, formalCharge);
            super.setConcise(conciseS);

        }
    }

    CMLAtomArray createAndAddAtomArrayAndFormalChargeFromConcise(
            CMLAttribute concise) {
        CMLAtomArray atomArray = new CMLAtomArray();
        List<String> elements = new ArrayList<String>();
        List<Double> counts = new ArrayList<Double>();
        String[] tokens = concise.getValue().split(S_WHITEREGEX);
        int nelement = tokens.length / 2;
        for (int i = 0; i < nelement; i++) {
            String elem = tokens[2 * i];
            ChemicalElement chemicalElement = ChemicalElement
                    .getChemicalElement(elem);
            if (chemicalElement == null) {
                throw new CMLRuntimeException("Unknown chemical element: " + elem);
            }
            if (elements.contains(elem)) {
                throw new CMLRuntimeException("Duplicate element in concise: " + elem);
            }
            elements.add(elem);
            String countS = tokens[2 * i + 1];
            try {
                counts.add(new Double(countS));
            } catch (NumberFormatException nfe) {
                throw new CMLRuntimeException("Bad element count in concise: " + countS);
            }
        }
        if (tokens.length > nelement * 2) {
            String chargeS = tokens[nelement * 2];
            try {
                int formalCharge = Integer.parseInt(chargeS);
                super.setFormalCharge(formalCharge);
            } catch (NumberFormatException nfe) {
                throw new CMLRuntimeException("Bad formal charge in concise: " + chargeS);
            }
        }
//        atomArray.setElementType((String[]) elements.toArray(new String[0]));
        double[] countD = new double[nelement];
        for (int i = 0; i < nelement; i++) {
            countD[i] = counts.get(i).doubleValue();
        }
        atomArray.setElementTypeAndCount((String[]) elements.toArray(new String[0]), countD);
//        atomArray.setCount(countD);
        setAtomArray(atomArray);
        return atomArray;
    }

    private void setAtomArray(CMLAtomArray atomArray) {
        for (CMLAtomArray aa : this.getAtomArrayElements()) {
            aa.detach();
        }
        super.appendChild(atomArray);
    }

    /**
     * checks that atomArray is in array format with unduplicated valid
     * elements. must have elementType and count attributes of equal lengths.
     *
     * @param atomArray
     *            to check (not modified)
     * @throws CMLRuntimeException
     *             if invalid
     */
    public void checkAtomArrayFormat(CMLAtomArray atomArray) {
        if (atomArray.getChildElements().size() > 0) {
            throw new CMLRuntimeException("No children allowed for formula/atomArray");
        }
        String[] elements = atomArray.getElementType();
        double[] counts = atomArray.getCount();
        if (elements == null || counts == null) {
            throw new CMLRuntimeException(
                    "formula/atomArray must have elementType and count attributes");
        }
        if (elements.length != counts.length) {
            throw new CMLRuntimeException(
                    "formula/atomArray must have equal length elementType and count values");
        }
        Set<String> elementSet = new HashSet<String>();
        for (int i = 0; i < elements.length; i++) {
            if (elements[i] != null && !(elements[i].equals("null"))) {
                if (elementSet.contains(elements[i])) {
                    throw new CMLRuntimeException(
                            "formula/atomArray@elementType has duplicate element: "
                                    + elements[i]);
                }
                elementSet.add(elements[i]);
                if (counts[i] <= 0) {
                    throw new CMLRuntimeException(
                            "formula/atomArray@count has nonPositive value: "
                                    + counts[i]);
                }
            }
        }
    }

    private void sortAtomArray(CMLAtomArray atomArray, Sort sort) {
        if (atomArray != null) {
            String[] elems = atomArray.getElementType();
            double[] counts = atomArray.getCount();
            int nelem = elems.length;
            String[] sortS = new String[elems.length];
            for (int i = 0; i < nelem; i++) {
                sortS[i] = elems[i] + S_SPACE + counts[i];
            }
            Arrays.sort(sortS);
            if (sort.equals(Sort.ALPHABETIC_ELEMENTS)) {
                ; // already done
            } else if (sort.equals(Sort.CHFIRST)) {
                String[] temp = new String[nelem];
                int c = 0;
                for (int i = 0; i < nelem; i++) {
                    if (sortS[i].startsWith("C ")) {
                        temp[c++] = sortS[i];
                    }
                }
                for (int i = 0; i < nelem; i++) {
                    if (sortS[i].startsWith("H ")) {
                        temp[c++] = sortS[i];
                    }
                }
                for (int i = 0; i < nelem; i++) {
                    if (sortS[i].startsWith("C ") || sortS[i].startsWith("H ")) {
                        ; //
                    } else {
                        temp[c++] = sortS[i];
                    }
                }
                System.arraycopy(temp, 0, sortS, 0, nelem);
            }
            for (int i = 0; i < nelem; i++) {
                String[] ss = sortS[i].split(S_SPACE);
                elems[i] = ss[0];
                counts[i] = new Double(ss[1]).doubleValue();
            }
//            atomArray.setElementType(elems);
//            atomArray.setCount(counts);
            atomArray.setElementTypeAndCount(elems, counts);
        }
    }

    /**
     * generates concise representation. correponds to concise attribute in
     * schema. only works if atomArray has elementType and count in array format
     *
     * @param atomArray
     * @param formalCharge
     *            (maybe omit this)
     * @throws CMLRuntimeException
     *             if atomArray of wrong sort
     * @return concise string
     */
    public static String generateConcise(CMLAtomArray atomArray, int formalCharge) {
        String concise = null;
        if (atomArray != null) {
            String[] elems = atomArray.getElementType();
            double[] counts = atomArray.getCount();
            if (elems == null && counts == null) {
                elems = new String[0];
                counts = new double[0];
            } else if (elems == null || counts == null) {
                throw new CMLRuntimeException(
                        "atomArray has elements/counts "+elems+S_SLASH+counts);
            } else if (counts.length != elems.length) {
                throw new CMLRuntimeException(
                        "atomArray has inconsistent counts/elems "+counts.length+S_SLASH+elems.length);
            }
            int nelem = elems.length;
            StringBuffer sb = new StringBuffer();
            for (int i = 0; i < nelem; i++) {
                sb.append(S_SPACE);
                sb.append(elems[i]);
                sb.append(S_SPACE);
                sb.append(Util.trim(Util.format(counts[i], 4)));
            }
            if (formalCharge != 0) {
                sb.append(S_SPACE);
                sb.append(formalCharge);
            }
            concise = (sb.length() == 0) ? S_EMPTY : sb.substring(1);
        }
        return concise;
    }

    // trap special combinations
    /**
     * add child. must not add atomArray
     *
     * @param child
     */
    public void appendChild(Element child) {
        if (child instanceof CMLAtomArray) {
            throw new CMLRuntimeException("atomArray child of formula is deprecated");
        }
        super.appendChild(child);
    }

    /**
     * removes optional charge field from concise formula. convenience method,
     * does not affect CMLormula object.
     *
     * @param s
     *            concise string (sssumed to be valid)
     * @return string without trailing charge (does NOT check validity)
     */
    public static String removeChargeFromConcise(String s) {
        String s0 = s.trim();
        String ss[] = s0.split(S_SPACE);
        if (ss.length % 2 != 0) {
            int idx = s0.lastIndexOf(S_SPACE);
            s0 = s0.substring(0, idx).trim();
        }
        return s0;
    }

    /**
     * return concise formaul without trailing charge.
     *
     * @return truncated concise (or null)
     */
    public String getConciseNoCharge() {
        String concise = this.getConcise();
        return (concise == null) ? null : removeChargeFromConcise(concise);
    }

    /**
     * set concise attribute. if atomArray is absent will automatically compute
     * atomArray and formalCharge, so use with care if atomArray is present will
     * throw CMLRuntime this logic may need to be revised
     *
     * @param value
     *            concise value
     * @throws CMLRuntimeException
     *             attribute wrong value/type
     *
     */
    public void setConcise(String value) throws CMLRuntimeException {
        if (getAtomArrayElements().size() > 0) {
            throw new CMLRuntimeException("Cannot reset concise if atomArray is present");
        }
        super.setConcise(value);
        normalize();
        // if building, then XOM attributes are processed before children
        // this flag will allow subsequent atomArray to override
        processedConcise = true;
    }

    /**
     * set formal charge. this will re-compute concise if possible.
     *
     * @param ch
     */
    public void setFormalCharge(int ch) {
        super.setFormalCharge(ch);
        normalize();
    }

    void init() {
        processedConcise = false;
    }

    /**
     * create formula from string. convention defaults to ANY
     *
     * @param s
     *            the String describing the formula
     * @exception CMLRuntimeException
     * @return the CMLFormula derived from the String s
     */
    public static CMLFormula createFormula(String s) {
        return createFormula(s, Type.ANY);
    }

    /**
     * create formula from string using convention.
     *
     * @param s
     *            the String describing the formula
     * @param convention
     *            the convention
     * @return the CMLFormula derived from the String s
     */
    // shouldn't this be a constructor instead?
    public static CMLFormula createFormula(String s, Type convention) {
        CMLFormula docFormula = new CMLFormula();
        docFormula.createFromString(s, convention);

        return docFormula;
    }

    /**
     * Sets the multiplier.
     *
     * Defaults to 1.0.
     *
     * @param count
     *            multiplier for this moiety;
     */
    // public void setCount(double count) {this.count = count;}
    /**
     * Gets the multplier.
     *
     * @return double count multiplier for this moiety;
     */
    // public double getCount() {return count;}
    /**
     * Interpret string as a formula and replace contents.
     *
     * (Normal usage would be to create an empty Formula and fill it. If
     * formulaConvention is not ANY then a specific convention is used, for ANY
     * we try a mixture of heuristics. This allows us to throw exceptions if we
     * deviate from conventions. Does allow non-integer counts Does not do
     * brackets at present...
     *
     * @param formulaString
     *            the string to interpret
     * @param formulaConvention
     *            taken from list above
     * @throws CMLRuntimeException
     *             uninterpretable formula.
     */
    /*
     * void createFromString(String formulaString, String formulaConvention)
     * throws CMLRuntime { formulaString = formulaString.trim(); if
     * (formulaConvention.equals(ELEMENT_WHITESPACE_COUNT) ||
     * formulaConvention.equals(ELEMENT_COUNT_WHITESPACE)) {
     * parseElementCountWhitespace(formulaString, formulaConvention); } else if
     * (formulaConvention.equals(MULTIPLIED_ELEMENT_COUNT_WHITESPACE)) {
     * parseMultipliedElementCountWhitespace(formulaString); } else if
     * (formulaConvention.equals(MOIETY)) { parseMoiety(formulaString); } else
     * if (formulaConvention.equals(IUPAC)) { System.out.println("IUPAC formula
     * convention not yet supported"); } else if
     * (formulaConvention.equals(NESTEDBRACKETS) ||
     * formulaConvention.equals(STRUCTURAL)) {
     * System.out.println("Nested/structural formula convention not yet
     * supported"); } else if (formulaConvention.equals(ANY)) {
     * parseAny(formulaString); } else { throw new CMLRuntime("Unknown formula
     * convention: "); } }
     */

    void createFromString(String formulaString, Type formulaConvention) {
        formulaString = formulaString.trim();
        if (formulaConvention.equals(Type.ELEMENT_WHITESPACE_COUNT)
                || formulaConvention.equals(Type.ELEMENT_COUNT_WHITESPACE)) {
            parseElementCountWhitespace(formulaString, formulaConvention);
        } else if (formulaConvention.equals(Type.NOPUNCTUATION)) {
//            parseElementCountWhitespace(formulaString, formulaConvention);
            parseAny(formulaString /*, formulaConvention*/);
        } else if (formulaConvention
                .equals(Type.MULTIPLIED_ELEMENT_COUNT_WHITESPACE)) {
            parseMultipliedElementCountWhitespace(formulaString);
        } else if (formulaConvention.equals(Type.MOIETY)) {
            parseMoiety(formulaString);
        } else if (formulaConvention.equals(Type.SUBMOIETY)) {
            parseSubMoiety(formulaString);
        } else if (formulaConvention.equals(Type.IUPAC)) {
            System.out.println("IUPAC formula convention not yet supported");
        } else if (formulaConvention.equals(Type.NESTEDBRACKETS)
                || formulaConvention.equals(Type.STRUCTURAL)) {
            System.out
                    .println("Nested/structural formula convention not yet supported");
        } else if (formulaConvention.equals(Type.ANY)) {
            parseAny(formulaString);
        } else {
            throw new CMLRuntimeException("Unknown formula convention: "
                    + formulaConvention.type);
        }
    }

    private void parseElementCountWhitespace(String formulaString,
            Type formulaConvention) {
        StringTokenizer st = new StringTokenizer(formulaString);
        while (st.hasMoreTokens()) {
            String s = st.nextToken();
            String countS = null;
            String elTypeS = null;
            if (formulaConvention.equals(Type.ELEMENT_WHITESPACE_COUNT)) {
                try {
                    countS = st.nextToken();
                } catch (NoSuchElementException e) {
                    throw new CMLRuntimeException("Bad formula: {" + formulaString
                            + S_RCURLY);
                }
                elTypeS = s;
            } else {
                elTypeS = S_EMPTY;
                int l = s.length();
                if (!Character.isUpperCase(s.charAt(0))) {
                    throw new CMLRuntimeException("Bad element 1st char in: " + s);
                }
                if (l == 1) {
                    elTypeS = s;
                    countS = "1";
                } else {
                    if (Character.isLowerCase(s.charAt(1))) {
                        elTypeS = s.substring(0, 2);
                        countS = s.substring(2);
                    } else {
                        elTypeS = s.substring(0, 1);
                        countS = s.substring(1);
                    }
                }
            }
            double c = 0.0;
            ChemicalElement element = ChemicalElement
                    .getChemicalElement(elTypeS);
            if (element == null) {
                throw new CMLRuntimeException("Bad element (" + elTypeS + ") in: " + s);
            }
            if (countS.equals(S_EMPTY)) {
                c = 1;
            } else {
                try {
                    c = new Double(countS).doubleValue();
                } catch (NumberFormatException nfe) {
                    throw new CMLRuntimeException("Bad element count (" + countS
                            + ") in: " + s);
                }
            }
            this.add(elTypeS, c);
        }
        String concise = getFormattedString(Type.ELEMENT_WHITESPACE_COUNT,
                Sort.CHFIRST, false).trim();
        if (!concise.equals(S_EMPTY)) {
            super.setConcise(concise);
        }
    }

    private void parseMultipliedElementCountWhitespace(String formulaString) {
        formulaString.trim();
        // can start with a number :-(
        int ii = 0;
        double mult = -1.0;
        while (ii < formulaString.length()) {
            if (formulaString.charAt(ii) == '.'
                    || Character.isDigit(formulaString.charAt(ii))) {
                ii++;
            } else {
                break;
            }
        }
        if (ii != 0) {
            try {
                mult = new Double(formulaString.substring(0, ii)).doubleValue();
            } catch (NumberFormatException nfe) {
                throw new CMLRuntimeException(
                        "Cannot interpret start of formula as multiplier: "
                                + formulaString);
            }
            formulaString = formulaString.substring(ii);
        }

        int lb = formulaString.indexOf(S_LBRAK);
        int rb = formulaString.indexOf(S_RBRAK);
        if (lb == -1 && rb == -1) {
            this.createFromString(formulaString, Type.ANY);
        } else if (lb == 0 && rb != -1) {
            if (mult < 0.0) {
                // possible postmultiplier
                String r = formulaString.substring(rb + 1);
                if (r.length() > 0) {
                    try {
                        mult = new Double(r).doubleValue();
                    } catch (NumberFormatException nfe) {
                        throw new CMLRuntimeException("Bad multiplier in: "
                                + formulaString);
                    }
                } else {
                    mult = 1.0;
                }
            }
            this.createFromString(formulaString.substring(1, rb), Type.ANY);
        } else {
            throw new CMLRuntimeException(
                    "Unbalanced () in multiplied formula string: "
                            + formulaString);
        }
        if (mult > 0.0) {
            this.setCount(mult);
        }
    }

    /**
     * splits at commas. then creates nested formula and parses ANY.
     *
     * @param formulaString
     */
    private void parseMoiety(String formulaString) {
        formulaString = formulaString.trim();
        StringTokenizer st = new StringTokenizer(formulaString, S_COMMA);
        if (st.countTokens() == 1) {
            parseMoiety0(formulaString);
        } else {
            while (st.hasMoreTokens()) {
                CMLFormula subForm = new CMLFormula();
                String f = st.nextToken().trim();
                subForm.parseMoiety0(f);
                this.appendChild(subForm);
            }
        }
    }

    private void parseMoiety0(String formulaString) {
        formulaString = formulaString.trim();
        // can start with a number :-(
        int ii = 0;
        double mult = -1.0;
        while (ii < formulaString.length()) {
            if (formulaString.charAt(ii) == C_PERIOD
                    || Character.isDigit(formulaString.charAt(ii))) {
                ii++;
            } else {
                break;
            }
        }
        if (ii != 0) {
            try {
                mult = new Double(formulaString.substring(0, ii)).doubleValue();
            } catch (NumberFormatException nfe) {
                throw new CMLRuntimeException(
                        "Cannot interpret start of formula as multiplier: "
                                + formulaString);
            }
            formulaString = formulaString.substring(ii);
        }
        int lb = formulaString.indexOf(S_LBRAK);
        int rb = formulaString.indexOf(S_RBRAK);
        if (lb == -1 && rb == -1) {
            this.parseSubMoiety(formulaString);
        } else if (lb == 0 && rb != -1) {
            if (mult < 0.0) {
                // possible postmultiplier
                String r = formulaString.substring(rb + 1);
                if (r.length() > 0) {
                    try {
                        mult = new Double(r).doubleValue();
                    } catch (NumberFormatException nfe) {
                        throw new CMLRuntimeException("Bad multiplier in: "
                                + formulaString);
                    }
                } else {
                    mult = 1.0;
                }
            }
            this.parseSubMoiety(formulaString.substring(1, rb));
        } else {
            throw new CMLRuntimeException(
                    "Unbalanced () in multiplied formula string: "
                            + formulaString);
        }
        if (mult > 0.0) {
            this.setCount(mult);
        }
    }

    private void parseSubMoiety(String sm) {
        sm = sm.trim();
        // List<String> elementList = new ArrayList<String>();
        int charge = 0;
        StringTokenizer st = new StringTokenizer(sm);
        int l = st.countTokens();
        for (int i = 0; i < l; i++) {
            String ss = st.nextToken();
            String s = ss;
            int mult = 0;
            // charge at the end?
            if (i == l - 1) {
                char c = s.charAt(0);
                if (c == C_PLUS) {
                    mult = 1;
                    s = s.substring(1);
                } else if (c == C_MINUS) {
                    mult = -1;
                    s = s.substring(1);
                } else if (s.endsWith(S_PLUS)) {
                    mult = 1;
                    s = s.substring(0, s.length() - 1);
                } else if (s.endsWith(S_MINUS)) {
                    mult = -1;
                    s = s.substring(0, s.length() - 1);
                }
                if (mult != 0) {
                    if (!s.trim().equals(S_EMPTY)) {
                        try {
                            charge = Integer.parseInt(s);
                        } catch (NumberFormatException nfe) {
                            throw new CMLRuntimeException("Bad charge: " + s);
                        }
                    } else {
                        charge = 1;
                    }
                    charge *= mult;
                }
            }
            // found charge
            if (mult != 0) {
                break;
            }
            s = ss;
            // get Element+count
            String elem = S_EMPTY;
            double count = 0;
            if (Character.isUpperCase(s.charAt(0))) {
                if (s.length() > 1) {
                    if (Character.isLowerCase(s.charAt(1))) {
                        elem = s.substring(0, 2);
                        s = s.substring(2);
                    } else if (!Character.isDigit(s.charAt(1))) {
                        throw new CMLRuntimeException("Bad elementCount: " + s);
                    } else {
                        elem = s.substring(0, 1);
                        s = s.substring(1);
                    }
                    if (s.trim().equals(S_EMPTY)) {
                        count = 1.0;
                    } else {
                        try {
                            count = new Double(s).doubleValue();
                        } catch (NumberFormatException nfe) {
                            throw new CMLRuntimeException(
                                "Moiety cannot parse element count: " + s);
                        }
                    }
                } else {
                    elem = s;
                    count = 1.0;
                }
            } else {
                throw new CMLRuntimeException("Moiety cannot parse element at: " + s);
            }
            if (elem.equals(S_EMPTY)) {
                throw new CMLRuntimeException("Moiety cannot parse element: " + s);
            }
            this.add(elem, count);
        }
        if (charge != 0) {
            this.setFormalCharge(charge);
        }
    }

    private void parseAny(String formulaString) {
        // ANY - make whitespace separated string and then recurse
        String result = S_EMPTY;
        formulaString += S_SPACE;
        int l = formulaString.length();
        int i = 0;
        char c;
        int charge = 0;
        String count = S_EMPTY;
        while (i < l) {
            // skip white
            while (formulaString.charAt(i) == C_SPACE) {
                if (++i >= l)
                    break;
            }
            if (i >= l)
                break;
            c = formulaString.charAt(i);
            // start element or charge
            String el = S_EMPTY;
            // finish with -, -1, 1-, 2-, -2, +1, 1+, +2, 2+ ... etc
            if (Character.isDigit(c) || c == '+' || c == '-') {
                charge = getFinalCharge(formulaString.substring(i).trim());
                break;
            }
            // upper case required
            if (!Character.isUpperCase(c)) {
                throw new CMLRuntimeException("Formula: Cannot interpret element ("
                        + c + ") at char (" + (i + 1) + ") in: "
                        + formulaString);
            }
            el += c;
            if (++i >= l) {
                result += el + " 1";
                break;
            }
            c = formulaString.charAt(i);
            // lower case optional
            if (Character.isLowerCase(c)) {
                el += c;
                i++;
            }
            // skip white
            while (formulaString.charAt(i) == C_SPACE) {
                if (++i >= l)
                    break;
            }
            if (i >= l) {
                result += el + " 1";
                break;
            }
            // multiplier?
            c = formulaString.charAt(i);
            // implied count of 1?
            count = S_EMPTY;
            if (!Character.isDigit(c)) {
                count = "1";
            } else {
                while (true) {
                    c = formulaString.charAt(i);
                    if (!Character.isDigit(c) && c != C_PERIOD) {
                        break;
                    }
                    count += c;
                    if (++i == l)
                        break;
                }
            }
            result += el + S_SPACE + count + S_SPACE;
        }
        createFromString(result, Type.ELEMENT_WHITESPACE_COUNT);
        if (charge != 0) {
            this.setFormalCharge(charge);
        }
    }

    private int getFinalCharge(String f) {
        if (f.indexOf(' ') != -1) {
            throw new CMLRuntimeException("Charge must be final field: " + f);
        }
        int sign = 0;
        int charge = 0;
        String ch = S_EMPTY;
        int l = f.length();
        if (f.charAt(0) == C_PLUS) {
            sign = 1;
            ch = f.substring(1);
        } else if (f.charAt(0) == C_MINUS) {
            sign = -1;
            ch = f.substring(1);
        } else if (f.indexOf(C_PLUS) == l - 1) {
            sign = 1;
            ch = f.substring(0, l - 1);
        } else if (f.indexOf(C_MINUS) == l - 1) {
            sign = -1;
            ch = f.substring(0, l - 1);
        } else {
            throw new CMLRuntimeException("Cannot parse as charge field: " + f);
        }
        if (ch.equals(S_EMPTY)) {
            charge = 1;
        } else {
            try {
                charge = Integer.parseInt(ch);
            } catch (NumberFormatException nfe) {
                throw new CMLRuntimeException("Cannot parse as charge field: " + f);
            }
        }
        return sign * charge;
    }

    /**
     * Adds element and count to formula. If element is already known,
     * increments the count.
     *
     * @param elementType
     *            the element atomicSymbol
     * @param count
     *            the element multiplier
     */
    public void add(String elementType, double count) {
        CMLAtomArray atomArray = (getAtomArrayElements().size() == 0) ? null
                : getAtomArrayElements().get(0);
        if (atomArray == null) {
            // if no atomArray , create from concise
            normalize();
            // if still none, create new one with empty attributes
            if (atomArray == null) {
                atomArray = new CMLAtomArray();
                setAtomArray(atomArray);
                atomArray.setElementTypeAndCount(new String[0], new double[0]);
            }
        }
        String[] elements = getElementTypes();
        if (elements == null) {
            elements = new String[0];
        }
        double[] counts = getCounts();
        if (counts == null) {
            counts = new double[0];
        }
        int nelem = elements.length;
        boolean added = false;
        for (int i = 0; i < nelem; i++) {
            if (elements[i].equals(elementType)) {
                counts[i] += count;
                added = true;
                break;
            }
        }
        if (!added) {
            String[] newElem = new String[nelem + 1];
            System.arraycopy(elements, 0, newElem, 0, nelem);
            newElem[nelem] = elementType;
            double[] newCount = new double[nelem + 1];
            System.arraycopy(counts, 0, newCount, 0, nelem);
            newCount[nelem] = count;
            atomArray.setElementTypeAndCount(newElem, newCount);
        } else {
            atomArray.setElementTypeAndCount(elements, counts);
        }
        int formalCharge = (this.getFormalChargeAttribute() == null) ? 0 : this
                .getFormalCharge();
        String conciseS = generateConcise(atomArray, formalCharge);
        super.setConcise(conciseS);
    }

    /**
     * Count for corresponding element.
     *
     * No defaults.
     *
     * @return double[] array of element counts; or null for none.
     */
    public double[] getCounts() {
        CMLAtomArray atomArray = (getAtomArrayElements().size() == 0) ? null
                : getAtomArrayElements().get(0);
        return (atomArray == null) ? null : atomArray.getCount();
    }

    /**
     * Count for corresponding element.
     *
     * No defaults.
     *
     * @return double[] array of element counts; or null for none.
     */
    public String[] getElementTypes() {
        CMLAtomArray atomArray = (getAtomArrayElements().size() == 0) ? null
                : getAtomArrayElements().get(0);
        return (atomArray == null) ? null : atomArray.getElementType();
    }

    /**
     * multiply all counts by the same constant factor. this is normally used to
     * multiply formula which represent a subfragment of a symmetrical molecule
     * it is distinct from the count attribute which represents two of more
     * independent entities
     *
     * @param d
     *            to multiply by
     */
    public void multiplyBy(double d) {
        CMLAtomArray atomArray = (getAtomArrayElements().size() == 0) ? null
                : getAtomArrayElements().get(0);
        if (atomArray != null) {
            String[] elems = this.getElementTypes();
            double counts[] = getCounts();
            for (int i = 0; i < counts.length; i++) {
                counts[i] *= d;
            }
//            atomArray.setCount(counts);
            atomArray.setElementTypeAndCount(elems, counts);
        } else {
            // convoluted! create new formula , multiply it and suck out the
            // values
            String concise = this.getConcise();
            CMLFormula fNew = new CMLFormula();
            fNew.createFromString(concise, Type.ELEMENT_WHITESPACE_COUNT);
            fNew.multiplyBy(d);
            String concise1 = fNew.getConcise();
            this.setConcise(concise1);
            atomArray.detach();
            CMLAtomArray fAtomArray = fNew.getAtomArrayElements().get(0);
            fAtomArray.detach();
            this.addAtomArray(fAtomArray);
        }
        String concise = CMLFormula.generateConcise(this.getAtomArrayElements()
                .get(0), (int) (this.getFormalCharge() * d));
        super.setConcise(concise);
    }

    /**
     * Adds a child formula to the content. if this is empty formula, no action.
     * if this has no children, copy this and add as a child, detaching
     * atomArray and removing concise from this after that f is copied and
     * appended as child
     *
     * @param f
     *            to be copied and added. null is ignored
     */
    public void addFormula(CMLFormula f) {
        CMLAtomArray atomArray = this.getAtomArrayElements().get(0);
        CMLElements<CMLFormula> formulas = this.getFormulaElements();
        if (formulas.size() == 0 && atomArray != null) {
            CMLFormula thisCopy = new CMLFormula(this);
            super.appendChild(thisCopy);
            atomArray.detach();
            // remove current concise attribute
            CMLAttribute att = this.getConciseAttribute();
            if (att != null) {
                this.removeAttribute(att);
            }
            att = this.getCountAttribute();
            if (att != null) {
                this.removeAttribute(att);
            }
        }
        if (atomArray != null) {
            CMLFormula ff = new CMLFormula(f);
            super.appendChild(ff);
        }
    }

    /**
     * gets single formula representing all contents.
     *
     * all formulae are added, using count when present. the current formula is
     * not modified can be used for adding separate formula
     *
     * @return composite formula (no formulaVector child)
     */
    public CMLFormula getAggregateFormula() {
        CMLFormula newFormula = null;
        CMLElements<CMLFormula> formulas = this.getFormulaElements();
        if (formulas.size() == 0) {
            newFormula = this;
        } else {
            newFormula = new CMLFormula();
            for (CMLFormula formula : formulas) {
                newFormula = newFormula.createAggregatedFormula(formula);
            }
        }
        return newFormula;
    }

    /**
     * aggregates two formulae including charge.
     *
     * if either formula is composite, aggregates them first current formula is
     * updated to contain aggregate, destroying any structure if no contents,
     * uses concise attribute
     *
     * @param form
     *            to aggregate
     * @return formula
     */
    public CMLFormula createAggregatedFormula(CMLFormula form) {
        CMLFormula newFormula = new CMLFormula();
        newFormula.aggregate(this);
        form = form.getAggregateFormula();
        newFormula.aggregate(form);
        return newFormula;
    }

    void aggregate(CMLFormula form) {
        String[] fElements = form.getElementTypes();
        double[] fCounts = form.getCounts();
        double thisCount = (this.getCountAttribute() == null) ? 1.0 : this
                .getCount();
        double fCount = (form.getCountAttribute() == null) ? 1.0 : form
                .getCount();
        int thisCharge = (this.getFormalChargeAttribute() == null) ? 0 : this
                .getFormalCharge();
        int fCharge = (form.getFormalChargeAttribute() == null) ? 0 : form
                .getFormalCharge();
        if (fElements != null) {
            for (int i = 0; i < fElements.length; i++) {
                this.add(fElements[i], fCounts[i] * fCount);
            }
        } else {
            // build from concise
            String concise = S_EMPTY;
            concise = form.getFormattedString(Type.ELEMENT_WHITESPACE_COUNT,
                    Sort.CHFIRST, false).trim();
            if (getConciseAttribute() != null) {
                CMLFormula newForm = new CMLFormula();
                newForm.createFromString(concise, Type.ANY);
                aggregate(newForm);
            }
        }
        // fix charges
        int newCharge = (int) (thisCharge * thisCount + fCharge * fCount);
        if (newCharge != 0) {
            this.setFormalCharge(newCharge);
        } else if (this.getFormalChargeAttribute() != null) {
            this.removeAttribute(this.getFormalChargeAttribute());
        }
        // set count to unity/remove
        Attribute countAttribute = this.getCountAttribute();
        if (countAttribute != null) {
            this.removeAttribute(this.getCountAttribute());
        }
        normalize();
    }

    /**
     * gets count of formula. defaults to 1.0
     *
     * @return formula count
     */
    public double getCount() {
        double fCount = 1.0;
        if (getCountAttribute() != null) {
            fCount = super.getCount();
            if (Math.round((float) fCount) == 0) {
                fCount = 1.0;
                this.setCount(fCount);
            }
        }
        return fCount;
    }

    /**
     * divide one formula by another.
     *
     * requires exactly the same elements are present in each and in the same
     * order. 'this' should be the largest formula at present expects the
     * results to be integer.
     *
     * @param f
     *            formula to divide into 'this'
     * @param eps
     *            allowed tolerance between element ratios
     * @return the multiplier (Double.NaN if operation fails)
     */
    public double divideBy(CMLFormula f, double eps) {
        double divide = Double.NaN;
        String[] elementTypes = this.getElementTypes();
        double[] counts = this.getCounts();
        if (f != null) {
            String[] fElem = f.getElementTypes();
            double[] fCounts = f.getCounts();
            if (fElem != null && fElem.length == elementTypes.length) {
                for (int i = 0; i < fElem.length; i++) {
                    // sorted; check for error
                    if (!elementTypes[i].equals(fElem[i]) || fCounts[i] == 0.0) {
                        divide = Double.NaN;
                        break;
                    }
                    double dd = counts[i] / fCounts[i];
                    if (false) {
                        ;
                    } else if (Double.isNaN(divide)) {
                        divide = dd;
                    } else if (Math.abs(divide - dd) > eps) {
                        divide = Double.NaN;
                        break;
                    }
                }
            }
        }
        return divide;
    }

    /**
     * get calculated molecular mass.
     *
     * @return calculated molecular mass.
     * @throws CMLRuntimeException
     *             unknown/unsupported element type (Dummy counts as zero mass)
     */
    public double getCalculatedMolecularMass() throws CMLRuntimeException {
        double mwt = 0.0;
        Elements formulas = this.getChildElements("formula", CML_NS);
        if (formulas.size() > 0) {
            for (int i = 0; i < formulas.size(); i++) {
                CMLFormula formula = (CMLFormula) formulas.get(i);
                mwt += formula.getCalculatedMolecularMass();
            }
        } else {
            String[] elementTypes = this.getElementTypes();
            double[] counts = this.getCounts();
            for (int i = 0; i < counts.length; i++) {
                mwt += getAtomicMass(elementTypes[i]) * counts[i];
            }
        }
        return getCount() * mwt;
    }

    /**
     * get mass for elementType.
     *
     * @param elementType
     * @return 0.0 if unknown or null
     */
    private static double getAtomicMass(String elementType) {
        double mass = 0.0;
        if (elementType != null) {
            ChemicalElement el = ChemicalElement
                    .getChemicalElement(elementType);
            mass = (el == null) ? 0.0 : el.getAtomicWeight();
        }
        return mass;
    }

    /**
     * Get formatted formula.
     *
     * @param convention
     *
     * <pre>
     *      NOPUNCTUATION      &quot;C2H4Cl2&quot; (default)
     *      ELEMENT_COUNT_WHITESPACE &quot;C2 H4 Cl2&quot;
     *      ELEMENT_WHITESPACE_COUNT &quot;C 2 H 4 Cl 2&quot;
     *      NESTEDBRACKETS     &quot;(Na2)(SO4).10(H2O)&quot;
     * </pre>
     *
     * @param sort
     *
     * <pre>
     *      ALPHABETIC_ELEMENTS    &quot;Br C Cl H&quot;
     *      CHFIRST      = &quot;C H Br Cl&quot;; (default)
     * </pre>
     *
     * @param omitCount1
     *            omit elements count if 1 (default false)
     * @return String the formatted formula
     * @throws CMLRuntimeException
     */
    public String getFormattedString(Type convention, Sort sort,
            boolean omitCount1) throws CMLRuntimeException {
        if (sort == null) {
            sort = Sort.CHFIRST;
        }
        if (!sort.equals(Sort.CHFIRST)
                && !sort.equals(Sort.ALPHABETIC_ELEMENTS)) {
            sort = Sort.CHFIRST;
        }
        if (convention == null || convention.equals(S_EMPTY)) {
            convention = Type.NOPUNCTUATION;
        }
        if (!convention.equals(Type.NOPUNCTUATION)
                && !convention.equals(Type.NESTEDBRACKETS)
                && !convention.equals(Type.ELEMENT_WHITESPACE_COUNT)
                && !convention.equals(Type.ELEMENT_COUNT_WHITESPACE)) {
            convention = Type.NOPUNCTUATION;
        }
        normalize();
        CMLAtomArray atomArray = (getAtomArrayElements().size() == 0) ? null
                : getAtomArrayElements().get(0);
        sortAtomArray(atomArray, sort);
        StringBuffer sb = new StringBuffer();
        Elements formulas = this.getChildElements("formula", CML_NS);
        if (convention.equals(Type.NESTEDBRACKETS)) {
            for (int i = 0; i < formulas.size(); i++) {
                CMLFormula formula = (CMLFormula) formulas.get(i);
                String c = Util.outputNumber(NPLACES, NDEC, formula.getCount());
                if (!omitCount1 || !c.equals("1")) {
                    sb.append(c);
                }
                sb.append(S_LBRAK);
                sb
                        .append(this.getFormattedString(convention, sort,
                                omitCount1));
                sb.append(S_RBRAK);
            }
            return sb.toString();
        } else {
            combineSubFormulaElementVectors();
            sortAtomArray(atomArray, sort);
        }
        String[] elementTypes = this.getElementTypes();
        double[] counts = this.getCounts();
        if (elementTypes != null && counts != null) {
            for (int i = 0; i < elementTypes.length; i++) {
                sb.append(elementTypes[i]);
                String s = Util.outputNumber(NPLACES, NDEC, counts[i]).trim();
                if (!omitCount1 || !s.equals("1")) {
                    if (convention.equals(Type.ELEMENT_WHITESPACE_COUNT)) {
                        sb.append(S_SPACE);
                    }
                    sb.append(s);
                }
                if (convention.equals(Type.ELEMENT_WHITESPACE_COUNT)
                        || convention.equals(Type.ELEMENT_COUNT_WHITESPACE)) {
                    sb.append(S_SPACE);
                }
            }
        }
        // trim any trailing blanks
        int l = sb.length();
        while (l > 0 && sb.charAt(--l) == ' ') {
            sb.deleteCharAt(l);
        }
        String s = getFormalChargeString().trim();
        if (!s.equals(S_EMPTY)) {
            if (!convention.equals(Type.NOPUNCTUATION)) {
                sb.append(S_SPACE);
            }
            sb.append(s);
        }
        return sb.toString();
    }

    /**
     * gets the charge on the formula.
     *
     * if there are child Formulas, iterate through, summing.
     *
     * @return the charge
     */
    public int getFormalCharge() {
        int charge = 0;
        Elements childFormulas = this.getChildElements("formula", CML_NS);
        if (childFormulas.size() > 0) {
            for (int i = 0; i < childFormulas.size(); i++) {
                CMLFormula childFormula = (CMLFormula) childFormulas.get(i);
                charge += childFormula.getFormalCharge()
                        * childFormula.getCount();
            }
        } else {
            if (this.getFormalChargeAttribute() != null) {
                charge = super.getFormalCharge();
            }
        }
        return charge;
    }

    /**
     * translates charge to an integer and then to String.
     *
     * @return charge as a String
     */
    public String getFormalChargeString() {
        String s = S_EMPTY;
        int iCharge = this.getFormalCharge();
        if (iCharge == 0) {
            ;
        } else if (iCharge < 0) {
            for (int i = iCharge; i < 0; i++) {
                s += S_MINUS;
            }
        } else {
            for (int i = 0; i < iCharge; i++) {
                s += S_PLUS;
            }
        }
        return s;
    }

    /**
     * default formula.
     *
     * @return default formula
     */
    public String getFormattedString() {
        return getFormattedString(null, null, true);
    }

    private void combineSubFormulaElementVectors() {
        Elements formulas = this.getChildElements("formula", CML_NS);
        if (formulas.size() > 0) {
            for (int i = 0; i < formulas.size(); i++) {
                CMLFormula subFormula = (CMLFormula) formulas.get(i);
                String[] subElementTypes = subFormula.getElementTypes();
                double[] subCounts = subFormula.getCounts();
                for (int j = 0; j < subElementTypes.length; j++) {
                    this.add((String) subElementTypes[j], subCounts[j]
                            * subFormula.getCount());
                }
            }
        }
    }

    /**
     * Calculate molecular mass from vector of element symbols and their counts.
     *
     * @param countArray
     * @param elementTypeVector
     * @return mass
     */
    public static double getCalculatedMass(List elementTypeVector,
            RealArray countArray)  {
        if (elementTypeVector == null || countArray == null
                || elementTypeVector.size() != countArray.size()) {
            throw new CMLRuntimeException("Bad arguments");
        }
        double mwt = 0.0;
        for (int i = 0; i < elementTypeVector.size(); i++) {
            String elType = (String) elementTypeVector.get(i);
            ChemicalElement el = ChemicalElement.getChemicalElement(elType);
            if (el == null) {
                throw new CMLRuntimeException("Unsupported element: " + elType);
            }
            mwt += el.getAtomicWeight() * countArray.elementAt(i);
        }
        return mwt;
    }

    /**
     * Output debug info to Writer.
     *
     * @param w
     *            output
     * @throws IOException
     */
    public void debug(Writer w) throws IOException {
        w.write("\n------------formula-------------\n");
        w.write(this.toString());
    }

    /**
     * tests equality of formulae. order of elements should be unimportant
     *
     * @param form
     *            to compare with this
     * @param eps
     *            tolerance for element counts
     * @return true if formulae are equals
     */
    public boolean equals(CMLFormula form, double eps) {
        boolean equals = false;
        String[] thisElem = this.getElementTypes();
        String[] formElem = form.getElementTypes();
        boolean ee = Arrays.equals(thisElem, formElem);
        double[] thisCount = this.getCounts();
        double[] formCount = form.getCounts();
        boolean cc = DoubleTool.equals(thisCount, formCount, eps);
        if (ee && cc) {
            equals = true;
        }
        return equals;
    }

    /**
     * compares current concise strings.
     * could fail if strings have decimal points
     *
     * @param f
     * @return true if equal
     */
    public boolean equalsConcise(CMLFormula f) {
        boolean equals = false;
        equals = this.getConcise().equals(f.getConcise());
        return equals;
    }

    /**
     * difference between formulas.
     *
     * formula is difference between this and f on an element by element basis.
     * Negative values are used where f has a greater element count that this.
     * Zero element counts are ommitted
     *
     * @param form
     *            formula to compare
     * @return difference in concise format (but may contain negative values)
     */
    public String getDifference(CMLFormula form) {
        Map<String, Double> countTable = new HashMap<String, Double>();
        String[] elementTypes = this.getElementTypes();
        double[] counts = this.getCounts();
        double thisCount = (this.getCountAttribute() == null) ? 1.0 : this
                .getCount();
        if (elementTypes != null && counts != null) {
            for (int i = 0; i < elementTypes.length; i++) {
                countTable.put(elementTypes[i], new Double(counts[i]));
            }
        }
        String newFormula = S_EMPTY;
        String[] fElementTypes = form.getElementTypes();
        double[] fCounts = form.getCounts();
        double fCount = (form.getCountAttribute() == null) ? 1.0 : form
                .getCount();
        if (fElementTypes != null && fCounts != null) {
            for (int i = 0; i < fElementTypes.length; i++) {
                String element = fElementTypes[i];
                Double count = countTable.get(element);
                // not in this
                double delta = 0.0;
                if (count == null) {
                    delta = 0.0 - fCounts[i];
                } else {
                    delta = count.doubleValue() * thisCount - fCounts[i]
                            * fCount;
                }
                if (Math.abs(delta) > 0.000001) {
                    newFormula += S_SPACE + element + S_SPACE + delta;
                }
                countTable.remove(element);
            }
        }
        // not in f
        for (String element : countTable.keySet()) {
            Double count = countTable.get(element);
            if (count != null) {
                newFormula += S_SPACE + element + S_SPACE
                        + (count.doubleValue() * thisCount);
            }
        }
        int charge = (int) Math.round(this.getFormalCharge() * thisCount
                - form.getFormalCharge() * fCount);
        if (charge != 0) {
            newFormula += S_SPACE + charge;
        }
        return newFormula.trim();
    }

    /**
     * are two formulas equal.
     *
     * use aggregated formulae as basis
     *
     * @param form
     *            formula to compare
     * @return true if equal
     */
    public boolean equalsAggregate(CMLFormula form) {
        String differenceFormula = this.getDifference(form).trim();
        return differenceFormula.length() == 0;
    }

    /**
     * create formula string.
     *
     * @return the string
     */
    public String toFormulaString() {
        String s = "count: " + this.getCount() + "; charge: "
                + this.getFormalCharge() + ": ";
        CMLElements<CMLFormula> formulas = this.getFormulaElements();
        for (CMLFormula formula : formulas) {
            s += "\nForm: " + formula.toFormulaString();
        }
        String[] elementTypes = this.getElementTypes();
        if (elementTypes != null) {
            double[] counts = this.getCounts();
            for (int i = 0; i < elementTypes.length; i++) {
                double d = counts[i];
                s += elementTypes[i]
                        + ((d > 1.000000001) ? S_LBRAK + counts[i] + S_RBRAK : S_EMPTY);
            }
        }
        return s;
    }

    /**
     * output HTML.
     *
     * @param w
     * @throws IOException
     */
    public void writeHTML(Writer w) throws IOException {
        w.write("<span class='formula'>");
        CMLElements<CMLFormula> formulas = this.getFormulaElements();
        if (formulas.size() > 0) {
            for (CMLFormula formula : formulas) {
                w.write(S_LBRAK);
                formula.writeHTML(w);
                w.write(S_RBRAK);
            }
        } else {
            String[] elementTypes = this.getElementTypes();
            double[] counts = this.getCounts();
            for (int i = 0; i < elementTypes.length; i++) {
                w.write(elementTypes[i]);
                double d = counts[i];
                int c = (int) Math.round(d);
                String countS = S_EMPTY;
                if (Math.abs(d - c) < EPS) {
                    countS = S_EMPTY+c;
                } else {
                    countS = S_EMPTY+d;
                }
                if (!countS.equals("1")) {
                    w.write("<sub>"+countS+"</sub>");
                }
            }
            if (this.getFormalChargeAttribute() != null) {
                int fc = this.getFormalCharge();
                int signum = Integer.signum(fc);
                String sign = S_EMPTY;

                //no need to assign S_MINUS to sign if signum is negative as the S_MINUS will be in the formalChargeAttribute
                if (signum == 1) {
                    sign = S_PLUS;
                }
                if (fc != 0) {
                    w.write("<sup>"+fc+sign+"</sup>");
                }
            }
            w.write("</span>");
        }
    }

    /**
     * test. maybe obsolete
     *
     * @param args
     */
    public static void mainTest(String[] args) {
        if (args.length == 0) {
            System.out
                    .println("Usage: FormulaImpl -IN xmlFile -OUT formFile -FORMAT format -MWT");
            // format -MWT -HCOUNT|EXPLICIT");
            System.out
                    .println("      Format NOSPACE EL_SPACE_COUNT EL_COUNT_SPACE");
            System.exit(0);
        }
        int i = 0;
        String infile = S_EMPTY;
        String outfile = S_EMPTY;
        String formatS = S_EMPTY;
        Type format = null;
        // String hCount = MoleculeTool.USE_HYDROGEN_COUNT;
        while (i < args.length) {
            if (args[i].equalsIgnoreCase("-IN")) {
                infile = args[++i];
                i++;
            } else if (args[i].equalsIgnoreCase("-OUT")) {
                outfile = args[++i];
                i++;
            } else if (args[i].equalsIgnoreCase("-FORMAT")) {
                formatS = args[++i];
                i++;
                // } else if (args[i].equalsIgnoreCase("-HCOUNT")) {
                // hCount = MoleculeTool.USE_HYDROGEN_COUNT;
                // i++;
                // } else if (args[i].equalsIgnoreCase("-EXPLICIT")) {
                // hCount = MoleculeTool.USE_EXPLICIT_HYDROGENS;
                // i++;
            } else {
                System.err.println("Bad argument: " + args[i]);
                i++;
            }
        }
        if (formatS.equals(S_EMPTY)) {
            formatS = "EL_SPACE_COUNT";
        }
        if (formatS.equals("EL_SPACE_COUNT")) {
            format = Type.ELEMENT_WHITESPACE_COUNT;
        } else if (formatS.equals("EL_COUNT_SPACE")) {
            format = Type.ELEMENT_COUNT_WHITESPACE;
        } else if (formatS.equals("NOSPACE")) {
            format = Type.NOPUNCTUATION;
        } else {
            System.err.println("Unsupported format: " + formatS);
        }
        try {
            if (!infile.equals(S_EMPTY)) {
                CMLBuilder builder = new CMLBuilder();
                Document document = builder.build(new File(infile));
                Elements moleculeVector = document.getRootElement()
                        .getChildElements(CMLMolecule.TAG, CML_NS);
                List<String> formulaVector = new ArrayList<String>();
                for (i = 0; i < moleculeVector.size(); i++) {
                    CMLMolecule molecule = (CMLMolecule) moleculeVector.get(i);
                    if (molecule == null) {
                        System.err.println("No molecule");
                    } else {
                        CMLFormula formula = (CMLFormula) molecule
                                .getFirstChildElement("formula", CML_NS);
                        if (formula != null) {
                            String s = "<formula>"
                                    + formula.getFormattedString(format,
                                            Sort.CHFIRST, false) + "</formula>";
                            formulaVector.add(s);
                        }
                    }
                }
                if (!outfile.equals(S_EMPTY)) {
                    FileWriter fw = new FileWriter(outfile);
                    fw.write("<cml>\n");
                    for (i = 0; i < formulaVector.size(); i++) {
                        fw.write(S_EMPTY + formulaVector.get(i) + S_NL);
                    }
                    fw.write("</cml>\n");
                    fw.close();
                }
            }
            /*--
             "Formula: "+this.toString()+S_NL+
             "MWt:"+this.getCalculatedMolecularMass()+S_NL+
             this.getFormattedString(CMLFormula.NOPUNCTUATION, CMLFormula.CHFIRST, false)+S_NL+
             this.getFormattedString(CMLFormula.ELEMENT_WHITESPACE_COUNT, CMLFormula.CHFIRST, false)+S_NL+
             this.getFormattedString(CMLFormula.ELEMENT_COUNT_WHITESPACE, S_EMPTY, false)+S_NL+
             this.getFormattedString(CMLFormula.NESTEDBRACKETS, CMLFormula.CHFIRST, false)+S_NL+
             this.getFormattedString(CMLFormula.NOPUNCTUATION, CMLFormula.ALPHABETIC_ELEMENTS, true)+S_NL+
             this.getFormattedString(CMLFormula.ELEMENT_WHITESPACE_COUNT, CMLFormula.CHFIRST, true)+S_NL+
             this.getFormattedString(CMLFormula.ELEMENT_COUNT_WHITESPACE, S_EMPTY, true)+S_NL+
             this.getFormattedString(CMLFormula.NESTEDBRACKETS, CMLFormula.ALPHABETIC_ELEMENTS, true);
             --*/
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

}
