package org.xmlcml.cml.element;

import java.util.HashMap;
import java.util.Map;

import nu.xom.Attribute;
import nu.xom.Elements;

import org.xmlcml.cml.base.CMLAttribute;
import org.xmlcml.cml.base.CMLElement;
import org.xmlcml.cml.base.CMLElements;
import org.xmlcml.cml.base.CMLException;
import org.xmlcml.cml.base.CMLRuntimeException;
import org.xmlcml.cml.base.CMLUtil;
import org.xmlcml.cml.base.DoubleAttribute;
import org.xmlcml.cml.base.IntAttribute;
import org.xmlcml.cml.base.StringAttribute;

/** An atom.
*
* 
* 
* 
* NON-MOFIFIABLE class autogenerated from schema
* DO NOT EDIT; ADD FUNCTIONALITY TO SUBCLASS

*/
public abstract class AbstractAtom extends CMLElement {

// fields;
    /** table mapping attribute names to attributegroup names*/
    public static Map<String, String> attributeGroupNameTable = new HashMap<String, String>();
    /** local name*/
    public final static String TAG = "atom";
    /** default constructor.
    *
    * creates element initially without parent


    */

    public AbstractAtom() {
        super("atom");
    }
    /** copy constructor.
    *
    * deep copy using XOM copy()

    * @param old AbstractAtom to copy

    */

    public AbstractAtom(AbstractAtom old) {
        super((CMLElement) old);
    }

    static {
        attributeGroupNameTable.put("id", "id");
        attributeGroupNameTable.put("convention", "convention");
        attributeGroupNameTable.put("dictRef", "dictRef");
        attributeGroupNameTable.put("ref", "ref");
        attributeGroupNameTable.put("count", "count");
        attributeGroupNameTable.put("elementType", "elementType");
        attributeGroupNameTable.put("formalCharge", "formalCharge");
        attributeGroupNameTable.put("hydrogenCount", "hydrogenCount");
        attributeGroupNameTable.put("isotope", "isotope");
        attributeGroupNameTable.put("isotopeNumber", "isotopeNumber");
        attributeGroupNameTable.put("isotopeRef", "isotopeRef");
        attributeGroupNameTable.put("isotopeListRef", "isotopeListRef");
        attributeGroupNameTable.put("occupancy", "occupancy");
        attributeGroupNameTable.put("spinMultiplicity", "spinMultiplicity");
        attributeGroupNameTable.put("x2", "x2");
        attributeGroupNameTable.put("y2", "y2");
        attributeGroupNameTable.put("x3", "x3");
        attributeGroupNameTable.put("y3", "y3");
        attributeGroupNameTable.put("z3", "z3");
        attributeGroupNameTable.put("xFract", "xFract");
        attributeGroupNameTable.put("yFract", "yFract");
        attributeGroupNameTable.put("zFract", "zFract");
        attributeGroupNameTable.put("title", "title");
        attributeGroupNameTable.put("role", "role");
        attributeGroupNameTable.put("spaceGroupMultiplicity", "spaceGroupMultiplicity");
        attributeGroupNameTable.put("pointGroupMultiplicity", "pointGroupMultiplicity");
    };
    /** get attributeGroupName from attributeName.
    *
    * @param attributeName attribute name
    * @return String
    */
    public String getAttributeGroupName(String attributeName) {
            return attributeGroupNameTable.get(attributeName);
    }
    /** A unique ID for an element.
    *
    * Id is used for machine identification of elements and
    *  in general should not have application semantics. It is similar to the XML ID type
    *  as containing only alphanumerics, '_', ',' and '-' and and must start with an
    *  alphabetic character. Ids are case sensitive. Ids should be unique within local scope,
    *  thus all atoms within a molecule should have unique ids, but separated molecules within a 
    * document (such as a published article) might have identical ids. Software
    *  should be able to search local scope (e.g. all atoms within a molecule). 
    * However this is under constant review.
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @return CMLAttribute
    */
    public CMLAttribute getIdAttribute() {
        return (CMLAttribute) getAttribute("id");
    }
    /** A unique ID for an element.
    *
    * Id is used for machine identification of elements and
    *  in general should not have application semantics. It is similar to the XML ID type
    *  as containing only alphanumerics, '_', ',' and '-' and and must start with an
    *  alphabetic character. Ids are case sensitive. Ids should be unique within local scope,
    *  thus all atoms within a molecule should have unique ids, but separated molecules within a 
    * document (such as a published article) might have identical ids. Software
    *  should be able to search local scope (e.g. all atoms within a molecule). 
    * However this is under constant review.
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @return String
    */
    public String getId() {
        CMLAttribute _att_id = (CMLAttribute) getAttribute("id");
        if (_att_id == null) {
            return null;
        }
        return ((StringAttribute)_att_id).getString();
    }
    /** A unique ID for an element.
    *
    * Id is used for machine identification of elements and
    *  in general should not have application semantics. It is similar to the XML ID type
    *  as containing only alphanumerics, '_', ',' and '-' and and must start with an
    *  alphabetic character. Ids are case sensitive. Ids should be unique within local scope,
    *  thus all atoms within a molecule should have unique ids, but separated molecules within a 
    * document (such as a published article) might have identical ids. Software
    *  should be able to search local scope (e.g. all atoms within a molecule). 
    * However this is under constant review.
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @param value id value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setId(String value) throws CMLRuntimeException {
            CMLAttribute _att_id = null;
            try {
        		_att_id = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("id"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_id == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : id; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_id);
        ((StringAttribute)_att_id).setCMLValue(value);
    }
    /** A reference to a convention.
    *
    * There is no controlled vocabulary for conventions, but the author must ensure that the semantics are openly available and that there are mechanisms for implementation. The convention is inherited by all the subelements, 
    * so that a convention for molecule would by default extend to its bond and atom children. This can be overwritten
    *  if necessary by an explicit convention.
    *  It may be useful to create conventions with namespaces (e.g. iupac:name).
    *  Use of convention will normally require non-STMML semantics, and should be used with
    *  caution. We would expect that conventions prefixed with "ISO" would be useful,
    *  such as ISO8601 for dateTimes.
    *  There is no default, but the conventions of STMML or the related language (e.g. CML) will be assumed.
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @return CMLAttribute
    */
    public CMLAttribute getConventionAttribute() {
        return (CMLAttribute) getAttribute("convention");
    }
    /** A reference to a convention.
    *
    * There is no controlled vocabulary for conventions, but the author must ensure that the semantics are openly available and that there are mechanisms for implementation. The convention is inherited by all the subelements, 
    * so that a convention for molecule would by default extend to its bond and atom children. This can be overwritten
    *  if necessary by an explicit convention.
    *  It may be useful to create conventions with namespaces (e.g. iupac:name).
    *  Use of convention will normally require non-STMML semantics, and should be used with
    *  caution. We would expect that conventions prefixed with "ISO" would be useful,
    *  such as ISO8601 for dateTimes.
    *  There is no default, but the conventions of STMML or the related language (e.g. CML) will be assumed.
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @return String
    */
    public String getConvention() {
        CMLAttribute _att_convention = (CMLAttribute) getAttribute("convention");
        if (_att_convention == null) {
            return null;
        }
        return ((StringAttribute)_att_convention).getString();
    }
    /** A reference to a convention.
    *
    * There is no controlled vocabulary for conventions, but the author must ensure that the semantics are openly available and that there are mechanisms for implementation. The convention is inherited by all the subelements, 
    * so that a convention for molecule would by default extend to its bond and atom children. This can be overwritten
    *  if necessary by an explicit convention.
    *  It may be useful to create conventions with namespaces (e.g. iupac:name).
    *  Use of convention will normally require non-STMML semantics, and should be used with
    *  caution. We would expect that conventions prefixed with "ISO" would be useful,
    *  such as ISO8601 for dateTimes.
    *  There is no default, but the conventions of STMML or the related language (e.g. CML) will be assumed.
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @param value convention value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setConvention(String value) throws CMLRuntimeException {
            CMLAttribute _att_convention = null;
            try {
        		_att_convention = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("convention"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_convention == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : convention; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_convention);
        ((StringAttribute)_att_convention).setCMLValue(value);
    }
    /** A reference to a dictionary entry.
    *
    * Elements in data instances such as _scalar_ may have a dictRef attribute to point to an entry in a dictionary. To avoid excessive use of (mutable) filenames and URIs we recommend a namespace prefix, mapped to a namespace URI in the normal manner. In this case, of course, the namespace URI must point to a real XML document containing _entry_ elements and validated against STMML Schema.
    *  Where there is concern about the dictionary becoming separated from the document the dictionary entries can be physically included as part of the data instance and the normal XPointer addressing mechanism can be used.
    *  This attribute can also be used on _dictionary_ elements to define the namespace prefix
    * --type info--
    * 
    * An XML QName with required prefix.
    * 
    *  The namespace prefix must start with an alpha character
    *  and can only contain alphanumeric and '_'. The suffix can 
    * have characters from the XML ID specification 
    * (alphanumeric, '_', '.' and '-'
    * Pattern: [A-Za-z][A-Za-z0-9_]*:[A-Za-z][A-Za-z0-9_\.\-]*

    * @return CMLAttribute
    */
    public CMLAttribute getDictRefAttribute() {
        return (CMLAttribute) getAttribute("dictRef");
    }
    /** A reference to a dictionary entry.
    *
    * Elements in data instances such as _scalar_ may have a dictRef attribute to point to an entry in a dictionary. To avoid excessive use of (mutable) filenames and URIs we recommend a namespace prefix, mapped to a namespace URI in the normal manner. In this case, of course, the namespace URI must point to a real XML document containing _entry_ elements and validated against STMML Schema.
    *  Where there is concern about the dictionary becoming separated from the document the dictionary entries can be physically included as part of the data instance and the normal XPointer addressing mechanism can be used.
    *  This attribute can also be used on _dictionary_ elements to define the namespace prefix
    * --type info--
    * 
    * An XML QName with required prefix.
    * 
    *  The namespace prefix must start with an alpha character
    *  and can only contain alphanumeric and '_'. The suffix can 
    * have characters from the XML ID specification 
    * (alphanumeric, '_', '.' and '-'
    * Pattern: [A-Za-z][A-Za-z0-9_]*:[A-Za-z][A-Za-z0-9_\.\-]*

    * @return String
    */
    public String getDictRef() {
        CMLAttribute _att_dictRef = (CMLAttribute) getAttribute("dictRef");
        if (_att_dictRef == null) {
            return null;
        }
        return ((StringAttribute)_att_dictRef).getString();
    }
    /** A reference to a dictionary entry.
    *
    * Elements in data instances such as _scalar_ may have a dictRef attribute to point to an entry in a dictionary. To avoid excessive use of (mutable) filenames and URIs we recommend a namespace prefix, mapped to a namespace URI in the normal manner. In this case, of course, the namespace URI must point to a real XML document containing _entry_ elements and validated against STMML Schema.
    *  Where there is concern about the dictionary becoming separated from the document the dictionary entries can be physically included as part of the data instance and the normal XPointer addressing mechanism can be used.
    *  This attribute can also be used on _dictionary_ elements to define the namespace prefix
    * --type info--
    * 
    * An XML QName with required prefix.
    * 
    *  The namespace prefix must start with an alpha character
    *  and can only contain alphanumeric and '_'. The suffix can 
    * have characters from the XML ID specification 
    * (alphanumeric, '_', '.' and '-'
    * Pattern: [A-Za-z][A-Za-z0-9_]*:[A-Za-z][A-Za-z0-9_\.\-]*

    * @param value dictRef value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setDictRef(String value) throws CMLRuntimeException {
            CMLAttribute _att_dictRef = null;
            try {
        		_att_dictRef = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("dictRef"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_dictRef == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : dictRef; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_dictRef);
        ((StringAttribute)_att_dictRef).setCMLValue(value);
    }
    /** A reference to an element of given type.
    *
    * ref modifies an element into a reference to an existing element of that type within the document. This is similar to a pointer and it can be thought of a strongly typed hyperlink. It may also be used for "subclassing" or "overriding" elements.
    *  When referring to an element most of the "data" such as attribute values and element content will be on the full instantiated element. Therefore ref (and possibly id) will normally be the only attributes on the pointing element. However there may be some attributes (title, count, etc.) which have useful semantics, but these are element-specific
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @return CMLAttribute
    */
    public CMLAttribute getRefAttribute() {
        return (CMLAttribute) getAttribute("ref");
    }
    /** A reference to an element of given type.
    *
    * ref modifies an element into a reference to an existing element of that type within the document. This is similar to a pointer and it can be thought of a strongly typed hyperlink. It may also be used for "subclassing" or "overriding" elements.
    *  When referring to an element most of the "data" such as attribute values and element content will be on the full instantiated element. Therefore ref (and possibly id) will normally be the only attributes on the pointing element. However there may be some attributes (title, count, etc.) which have useful semantics, but these are element-specific
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @return String
    */
    public String getRef() {
        CMLAttribute _att_ref = (CMLAttribute) getAttribute("ref");
        if (_att_ref == null) {
            return null;
        }
        return ((StringAttribute)_att_ref).getString();
    }
    /** A reference to an element of given type.
    *
    * ref modifies an element into a reference to an existing element of that type within the document. This is similar to a pointer and it can be thought of a strongly typed hyperlink. It may also be used for "subclassing" or "overriding" elements.
    *  When referring to an element most of the "data" such as attribute values and element content will be on the full instantiated element. Therefore ref (and possibly id) will normally be the only attributes on the pointing element. However there may be some attributes (title, count, etc.) which have useful semantics, but these are element-specific
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @param value ref value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setRef(String value) throws CMLRuntimeException {
            CMLAttribute _att_ref = null;
            try {
        		_att_ref = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("ref"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_ref == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : ref; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_ref);
        ((StringAttribute)_att_ref).setCMLValue(value);
    }
    /** The count of the object.
    *
    * No fixed semantics or default, normally integers. 
    * It is presumed that the element can be multiplied by the count value.
    * --type info--
    * 
    * A positive number.
    * Note that we also provide nonNegativeNumber with inclusive zero. The maximum number is (quite large) since 'unbounded' is more difficult to implement.

    * @return CMLAttribute
    */
    public CMLAttribute getCountAttribute() {
        return (CMLAttribute) getAttribute("count");
    }
    /** The count of the object.
    *
    * No fixed semantics or default, normally integers. 
    * It is presumed that the element can be multiplied by the count value.
    * --type info--
    * 
    * A positive number.
    * Note that we also provide nonNegativeNumber with inclusive zero. The maximum number is (quite large) since 'unbounded' is more difficult to implement.

    * @return double
    */
    public double getCount() {
        CMLAttribute _att_count = (CMLAttribute) getAttribute("count");
        if (_att_count == null) {
            return Double.NaN;
        }
        return ((DoubleAttribute)_att_count).getDouble();
    }
    /** The count of the object.
    *
    * No fixed semantics or default, normally integers. 
    * It is presumed that the element can be multiplied by the count value.
    * --type info--
    * 
    * A positive number.
    * Note that we also provide nonNegativeNumber with inclusive zero. The maximum number is (quite large) since 'unbounded' is more difficult to implement.

    * @param value count value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setCount(double value) throws CMLRuntimeException {
            CMLAttribute _att_count = null;
            try {
        		_att_count = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("count"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_count == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : count; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_count);
        ((DoubleAttribute)_att_count).setCMLValue(value);
    }
    /** The count of the object.
    *
    * No fixed semantics or default, normally integers. 
    * It is presumed that the element can be multiplied by the count value.
    * --type info--
    * 
    * A positive number.
    * Note that we also provide nonNegativeNumber with inclusive zero. The maximum number is (quite large) since 'unbounded' is more difficult to implement.

    * @param value count value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setCount(String value) throws CMLRuntimeException {
            CMLAttribute _att_count = new DoubleAttribute((DoubleAttribute)CMLAttributeList.getAttribute("count"));
            if (_att_count == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : count; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_count);
        ((DoubleAttribute)_att_count).setCMLValue(value);
    }
    /** The identity of a chemical element.
    *
    * Normally mandatory on _atom_, _isotope_, etc.
    * --type info--
    * 
    * A point at which an atom or group might be attached.
    * 
    *  Examples are abbreviated organic functional groups, Markush representations, polymers, unknown atoms, etc. Semantics may be determined by the role attribute on the atom. 

    * @return CMLAttribute
    */
    public CMLAttribute getElementTypeAttribute() {
        return (CMLAttribute) getAttribute("elementType");
    }
    /** The identity of a chemical element.
    *
    * Normally mandatory on _atom_, _isotope_, etc.
    * --type info--
    * 
    * A point at which an atom or group might be attached.
    * 
    *  Examples are abbreviated organic functional groups, Markush representations, polymers, unknown atoms, etc. Semantics may be determined by the role attribute on the atom. 

    * @return String
    */
    public String getElementType() {
        CMLAttribute _att_elementType = (CMLAttribute) getAttribute("elementType");
        if (_att_elementType == null) {
            return null;
        }
        return ((StringAttribute)_att_elementType).getString();
    }
    /** The identity of a chemical element.
    *
    * Normally mandatory on _atom_, _isotope_, etc.
    * --type info--
    * 
    * A point at which an atom or group might be attached.
    * 
    *  Examples are abbreviated organic functional groups, Markush representations, polymers, unknown atoms, etc. Semantics may be determined by the role attribute on the atom. 

    * @param value elementType value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setElementType(String value) throws CMLRuntimeException {
            CMLAttribute _att_elementType = null;
            try {
        		_att_elementType = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("elementType"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_elementType == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : elementType; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_elementType);
        ((StringAttribute)_att_elementType).setCMLValue(value);
    }
    /** The formalCharge on the object.
    *
    * NOT the calculated charge or oxidation state. No formal default, but assumed to be zero if omitted. It may become good practice to include it.
    * --type info--
    * 
    * The formal charge on an object.
    * Used for electron-bookeeping. This has no relation to its calculated (fractional) charge or oxidation state.

    * @return CMLAttribute
    */
    public CMLAttribute getFormalChargeAttribute() {
        return (CMLAttribute) getAttribute("formalCharge");
    }
    /** The formalCharge on the object.
    *
    * NOT the calculated charge or oxidation state. No formal default, but assumed to be zero if omitted. It may become good practice to include it.
    * --type info--
    * 
    * The formal charge on an object.
    * Used for electron-bookeeping. This has no relation to its calculated (fractional) charge or oxidation state.

    * @return int
    */
    public int getFormalCharge() {
        CMLAttribute _att_formalCharge = (CMLAttribute) getAttribute("formalCharge");
        if (_att_formalCharge == null) {
            CMLUtil.BUG("unset attribute: formalCharge");
        }
        return ((IntAttribute)_att_formalCharge).getInt();
    }
    /** The formalCharge on the object.
    *
    * NOT the calculated charge or oxidation state. No formal default, but assumed to be zero if omitted. It may become good practice to include it.
    * --type info--
    * 
    * The formal charge on an object.
    * Used for electron-bookeeping. This has no relation to its calculated (fractional) charge or oxidation state.

    * @param value formalCharge value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setFormalCharge(int value) throws CMLRuntimeException {
            CMLAttribute _att_formalCharge = null;
            try {
        		_att_formalCharge = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("formalCharge"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_formalCharge == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : formalCharge; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_formalCharge);
        ((IntAttribute)_att_formalCharge).setCMLValue(value);
    }
    /** The formalCharge on the object.
    *
    * NOT the calculated charge or oxidation state. No formal default, but assumed to be zero if omitted. It may become good practice to include it.
    * --type info--
    * 
    * The formal charge on an object.
    * Used for electron-bookeeping. This has no relation to its calculated (fractional) charge or oxidation state.

    * @param value formalCharge value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setFormalCharge(String value) throws CMLRuntimeException {
            CMLAttribute _att_formalCharge = new IntAttribute((IntAttribute)CMLAttributeList.getAttribute("formalCharge"));
            if (_att_formalCharge == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : formalCharge; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_formalCharge);
        ((IntAttribute)_att_formalCharge).setCMLValue(value);
    }
    /** Number of hydrogens.
    *
    * The total number of hydrogens bonded to the atom or molecule. It is preferable to include hydrogens explicitly, and where this is done their count represents the minimum (and may thus override this attribute). It is dangerous to use this attribute for electron-deficient molecules (e.g. diborane) or hydrogen bonds. There is NO DEFAULT and the absence of this attribute must not be given any meaning.
    * --type info--
    * 
    * The total number of hydrogen atoms bonded to an object.
    * The total number of hydrogen atoms bonded to an atom or contained in a molecule, whether explicitly included as atoms or not. It is an error to have hydrogen count less than the explicit hydrogen count. There is no default value and no assumptions about hydrogen Count can be made if it is not given. If hydrogenCount is given on every atom, then the values can be summed to give the total hydrogenCount for the (sub)molecule. Because of this hydrogenCount should not be used where hydrogen atoms bridge 2 or more atoms.
    * MinInclusive: 0

    * @return CMLAttribute
    */
    public CMLAttribute getHydrogenCountAttribute() {
        return (CMLAttribute) getAttribute("hydrogenCount");
    }
    /** Number of hydrogens.
    *
    * The total number of hydrogens bonded to the atom or molecule. It is preferable to include hydrogens explicitly, and where this is done their count represents the minimum (and may thus override this attribute). It is dangerous to use this attribute for electron-deficient molecules (e.g. diborane) or hydrogen bonds. There is NO DEFAULT and the absence of this attribute must not be given any meaning.
    * --type info--
    * 
    * The total number of hydrogen atoms bonded to an object.
    * The total number of hydrogen atoms bonded to an atom or contained in a molecule, whether explicitly included as atoms or not. It is an error to have hydrogen count less than the explicit hydrogen count. There is no default value and no assumptions about hydrogen Count can be made if it is not given. If hydrogenCount is given on every atom, then the values can be summed to give the total hydrogenCount for the (sub)molecule. Because of this hydrogenCount should not be used where hydrogen atoms bridge 2 or more atoms.
    * MinInclusive: 0

    * @return int
    */
    public int getHydrogenCount() {
        CMLAttribute _att_hydrogenCount = (CMLAttribute) getAttribute("hydrogenCount");
        if (_att_hydrogenCount == null) {
            CMLUtil.BUG("unset attribute: hydrogenCount");
        }
        return ((IntAttribute)_att_hydrogenCount).getInt();
    }
    /** Number of hydrogens.
    *
    * The total number of hydrogens bonded to the atom or molecule. It is preferable to include hydrogens explicitly, and where this is done their count represents the minimum (and may thus override this attribute). It is dangerous to use this attribute for electron-deficient molecules (e.g. diborane) or hydrogen bonds. There is NO DEFAULT and the absence of this attribute must not be given any meaning.
    * --type info--
    * 
    * The total number of hydrogen atoms bonded to an object.
    * The total number of hydrogen atoms bonded to an atom or contained in a molecule, whether explicitly included as atoms or not. It is an error to have hydrogen count less than the explicit hydrogen count. There is no default value and no assumptions about hydrogen Count can be made if it is not given. If hydrogenCount is given on every atom, then the values can be summed to give the total hydrogenCount for the (sub)molecule. Because of this hydrogenCount should not be used where hydrogen atoms bridge 2 or more atoms.
    * MinInclusive: 0

    * @param value hydrogenCount value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setHydrogenCount(int value) throws CMLRuntimeException {
            CMLAttribute _att_hydrogenCount = null;
            try {
        		_att_hydrogenCount = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("hydrogenCount"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_hydrogenCount == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : hydrogenCount; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_hydrogenCount);
        ((IntAttribute)_att_hydrogenCount).setCMLValue(value);
    }
    /** Number of hydrogens.
    *
    * The total number of hydrogens bonded to the atom or molecule. It is preferable to include hydrogens explicitly, and where this is done their count represents the minimum (and may thus override this attribute). It is dangerous to use this attribute for electron-deficient molecules (e.g. diborane) or hydrogen bonds. There is NO DEFAULT and the absence of this attribute must not be given any meaning.
    * --type info--
    * 
    * The total number of hydrogen atoms bonded to an object.
    * The total number of hydrogen atoms bonded to an atom or contained in a molecule, whether explicitly included as atoms or not. It is an error to have hydrogen count less than the explicit hydrogen count. There is no default value and no assumptions about hydrogen Count can be made if it is not given. If hydrogenCount is given on every atom, then the values can be summed to give the total hydrogenCount for the (sub)molecule. Because of this hydrogenCount should not be used where hydrogen atoms bridge 2 or more atoms.
    * MinInclusive: 0

    * @param value hydrogenCount value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setHydrogenCount(String value) throws CMLRuntimeException {
            CMLAttribute _att_hydrogenCount = new IntAttribute((IntAttribute)CMLAttributeList.getAttribute("hydrogenCount"));
            if (_att_hydrogenCount == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : hydrogenCount; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_hydrogenCount);
        ((IntAttribute)_att_hydrogenCount).setCMLValue(value);
    }
    /** The isotope for an element.
    *
    * A real number describing the isotope. Probably obsolet.

    * @return CMLAttribute
    */
    public CMLAttribute getIsotopeAttribute() {
        return (CMLAttribute) getAttribute("isotope");
    }
    /** The isotope for an element.
    *
    * A real number describing the isotope. Probably obsolet.

    * @return double
    */
    public double getIsotope() {
        CMLAttribute _att_isotope = (CMLAttribute) getAttribute("isotope");
        if (_att_isotope == null) {
            return Double.NaN;
        }
        return ((DoubleAttribute)_att_isotope).getDouble();
    }
    /** The isotope for an element.
    *
    * A real number describing the isotope. Probably obsolet.

    * @param value isotope value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setIsotope(double value) throws CMLRuntimeException {
            CMLAttribute _att_isotope = null;
            try {
        		_att_isotope = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("isotope"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_isotope == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : isotope; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_isotope);
        ((DoubleAttribute)_att_isotope).setCMLValue(value);
    }
    /** The isotope for an element.
    *
    * A real number describing the isotope. Probably obsolet.

    * @param value isotope value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setIsotope(String value) throws CMLRuntimeException {
            CMLAttribute _att_isotope = new DoubleAttribute((DoubleAttribute)CMLAttributeList.getAttribute("isotope"));
            if (_att_isotope == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : isotope; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_isotope);
        ((DoubleAttribute)_att_isotope).setCMLValue(value);
    }
    /** The integer number for an isotope.
    *
    * The number representing the isotope. By default it does not point to a fuller description of the isotope (use isotopeRef).
    * --type info--
    * 
    * MinExclusive: 0

    * @return CMLAttribute
    */
    public CMLAttribute getIsotopeNumberAttribute() {
        return (CMLAttribute) getAttribute("isotopeNumber");
    }
    /** The integer number for an isotope.
    *
    * The number representing the isotope. By default it does not point to a fuller description of the isotope (use isotopeRef).
    * --type info--
    * 
    * MinExclusive: 0

    * @return int
    */
    public int getIsotopeNumber() {
        CMLAttribute _att_isotopeNumber = (CMLAttribute) getAttribute("isotopeNumber");
        if (_att_isotopeNumber == null) {
            CMLUtil.BUG("unset attribute: isotopeNumber");
        }
        return ((IntAttribute)_att_isotopeNumber).getInt();
    }
    /** The integer number for an isotope.
    *
    * The number representing the isotope. By default it does not point to a fuller description of the isotope (use isotopeRef).
    * --type info--
    * 
    * MinExclusive: 0

    * @param value isotopeNumber value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setIsotopeNumber(int value) throws CMLRuntimeException {
            CMLAttribute _att_isotopeNumber = null;
            try {
        		_att_isotopeNumber = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("isotopeNumber"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_isotopeNumber == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : isotopeNumber; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_isotopeNumber);
        ((IntAttribute)_att_isotopeNumber).setCMLValue(value);
    }
    /** The integer number for an isotope.
    *
    * The number representing the isotope. By default it does not point to a fuller description of the isotope (use isotopeRef).
    * --type info--
    * 
    * MinExclusive: 0

    * @param value isotopeNumber value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setIsotopeNumber(String value) throws CMLRuntimeException {
            CMLAttribute _att_isotopeNumber = new IntAttribute((IntAttribute)CMLAttributeList.getAttribute("isotopeNumber"));
            if (_att_isotopeNumber == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : isotopeNumber; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_isotopeNumber);
        ((IntAttribute)_att_isotopeNumber).setCMLValue(value);
    }
    /** Reference to a fuller description of the isotope.
    *
    * 
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @return CMLAttribute
    */
    public CMLAttribute getIsotopeRefAttribute() {
        return (CMLAttribute) getAttribute("isotopeRef");
    }
    /** Reference to a fuller description of the isotope.
    *
    * 
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @return String
    */
    public String getIsotopeRef() {
        CMLAttribute _att_isotopeRef = (CMLAttribute) getAttribute("isotopeRef");
        if (_att_isotopeRef == null) {
            return null;
        }
        return ((StringAttribute)_att_isotopeRef).getString();
    }
    /** Reference to a fuller description of the isotope.
    *
    * 
    * --type info--
    * 
    * A reference to an existing object.
    * The semantic of reference are normally identical to 
    * an idType (e.g. "a123b"). Howevere there are some cases where compound references
    *  are required, such as "a123b:pq456". It is likely that this will be superseded at
    *  by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem
    * Pattern: ([A-Za-z_][A-Za-z0-9_\.\-]*:)?[A-Za-z_][A-Za-z0-9_\.\-]*

    * @param value isotopeRef value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setIsotopeRef(String value) throws CMLRuntimeException {
            CMLAttribute _att_isotopeRef = null;
            try {
        		_att_isotopeRef = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("isotopeRef"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_isotopeRef == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : isotopeRef; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_isotopeRef);
        ((StringAttribute)_att_isotopeRef).setCMLValue(value);
    }
    /** Reference to a description of the isotopic composition of an atom.
    *
    * Used when more than one atom shares the same isotopic composition (e.g. when H/D have been scrambled over some or all of the atoms in a molecule..
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @return CMLAttribute
    */
    public CMLAttribute getIsotopeListRefAttribute() {
        return (CMLAttribute) getAttribute("isotopeListRef");
    }
    /** Reference to a description of the isotopic composition of an atom.
    *
    * Used when more than one atom shares the same isotopic composition (e.g. when H/D have been scrambled over some or all of the atoms in a molecule..
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @return String
    */
    public String getIsotopeListRef() {
        CMLAttribute _att_isotopeListRef = (CMLAttribute) getAttribute("isotopeListRef");
        if (_att_isotopeListRef == null) {
            return null;
        }
        return ((StringAttribute)_att_isotopeListRef).getString();
    }
    /** Reference to a description of the isotopic composition of an atom.
    *
    * Used when more than one atom shares the same isotopic composition (e.g. when H/D have been scrambled over some or all of the atoms in a molecule..
    * --type info--
    * 
    * A unique ID for an element.
    * 
    *  This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.
    *  It is difficult to ensure uniqueness when documents are merged. We suggest
    *  namespacing IDs, perhaps using the containing elements as the base.
    *  Thus mol3:a1 could be a useful unique ID. 
    * However this is still experimental.
    * Pattern: [A-Za-z][A-Za-z0-9\.\-_]*

    * @param value isotopeListRef value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setIsotopeListRef(String value) throws CMLRuntimeException {
            CMLAttribute _att_isotopeListRef = null;
            try {
        		_att_isotopeListRef = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("isotopeListRef"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_isotopeListRef == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : isotopeListRef; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_isotopeListRef);
        ((StringAttribute)_att_isotopeListRef).setCMLValue(value);
    }
    /** Occupancy for an atom.
    *
    * Normally only found in crystallography. Defaults to 1.0. The occupancy is required to calculate the molecular formaula from the atoms.
    * --type info--
    * 
    * A floating point number between 0 and 1 inclusive.
    * Originally for crystallographic occupancy but re-usable 
    * for fractional yield, etc.

    * @return CMLAttribute
    */
    public CMLAttribute getOccupancyAttribute() {
        return (CMLAttribute) getAttribute("occupancy");
    }
    /** Occupancy for an atom.
    *
    * Normally only found in crystallography. Defaults to 1.0. The occupancy is required to calculate the molecular formaula from the atoms.
    * --type info--
    * 
    * A floating point number between 0 and 1 inclusive.
    * Originally for crystallographic occupancy but re-usable 
    * for fractional yield, etc.

    * @return double
    */
    public double getOccupancy() {
        CMLAttribute _att_occupancy = (CMLAttribute) getAttribute("occupancy");
        if (_att_occupancy == null) {
            return Double.NaN;
        }
        return ((DoubleAttribute)_att_occupancy).getDouble();
    }
    /** Occupancy for an atom.
    *
    * Normally only found in crystallography. Defaults to 1.0. The occupancy is required to calculate the molecular formaula from the atoms.
    * --type info--
    * 
    * A floating point number between 0 and 1 inclusive.
    * Originally for crystallographic occupancy but re-usable 
    * for fractional yield, etc.

    * @param value occupancy value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setOccupancy(double value) throws CMLRuntimeException {
            CMLAttribute _att_occupancy = null;
            try {
        		_att_occupancy = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("occupancy"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_occupancy == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : occupancy; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_occupancy);
        ((DoubleAttribute)_att_occupancy).setCMLValue(value);
    }
    /** Occupancy for an atom.
    *
    * Normally only found in crystallography. Defaults to 1.0. The occupancy is required to calculate the molecular formaula from the atoms.
    * --type info--
    * 
    * A floating point number between 0 and 1 inclusive.
    * Originally for crystallographic occupancy but re-usable 
    * for fractional yield, etc.

    * @param value occupancy value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setOccupancy(String value) throws CMLRuntimeException {
            CMLAttribute _att_occupancy = new DoubleAttribute((DoubleAttribute)CMLAttributeList.getAttribute("occupancy"));
            if (_att_occupancy == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : occupancy; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_occupancy);
        ((DoubleAttribute)_att_occupancy).setCMLValue(value);
    }
    /** Spin multiplicity.
    *
    * Normally for a molecule. This attribute gives the spin multiplicity of the molecule and is independent of any atomic information. No default, and it may take any positive integer value (though values are normally between 1 and 5.
    * --type info--
    * 
    * MinExclusive: 0

    * @return CMLAttribute
    */
    public CMLAttribute getSpinMultiplicityAttribute() {
        return (CMLAttribute) getAttribute("spinMultiplicity");
    }
    /** Spin multiplicity.
    *
    * Normally for a molecule. This attribute gives the spin multiplicity of the molecule and is independent of any atomic information. No default, and it may take any positive integer value (though values are normally between 1 and 5.
    * --type info--
    * 
    * MinExclusive: 0

    * @return int
    */
    public int getSpinMultiplicity() {
        CMLAttribute _att_spinMultiplicity = (CMLAttribute) getAttribute("spinMultiplicity");
        if (_att_spinMultiplicity == null) {
            CMLUtil.BUG("unset attribute: spinMultiplicity");
        }
        return ((IntAttribute)_att_spinMultiplicity).getInt();
    }
    /** Spin multiplicity.
    *
    * Normally for a molecule. This attribute gives the spin multiplicity of the molecule and is independent of any atomic information. No default, and it may take any positive integer value (though values are normally between 1 and 5.
    * --type info--
    * 
    * MinExclusive: 0

    * @param value spinMultiplicity value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setSpinMultiplicity(int value) throws CMLRuntimeException {
            CMLAttribute _att_spinMultiplicity = null;
            try {
        		_att_spinMultiplicity = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("spinMultiplicity"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_spinMultiplicity == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : spinMultiplicity; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_spinMultiplicity);
        ((IntAttribute)_att_spinMultiplicity).setCMLValue(value);
    }
    /** Spin multiplicity.
    *
    * Normally for a molecule. This attribute gives the spin multiplicity of the molecule and is independent of any atomic information. No default, and it may take any positive integer value (though values are normally between 1 and 5.
    * --type info--
    * 
    * MinExclusive: 0

    * @param value spinMultiplicity value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setSpinMultiplicity(String value) throws CMLRuntimeException {
            CMLAttribute _att_spinMultiplicity = new IntAttribute((IntAttribute)CMLAttributeList.getAttribute("spinMultiplicity"));
            if (_att_spinMultiplicity == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : spinMultiplicity; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_spinMultiplicity);
        ((IntAttribute)_att_spinMultiplicity).setCMLValue(value);
    }
    /** x2 coordinate for an object.
    *
    * Used for displaying the object in 2 dimensions. Unrelated to the 3-D coordinates for the object. The orientation of the axes matters as it can affect the chirality of object.

    * @return CMLAttribute
    */
    public CMLAttribute getX2Attribute() {
        return (CMLAttribute) getAttribute("x2");
    }
    /** x2 coordinate for an object.
    *
    * Used for displaying the object in 2 dimensions. Unrelated to the 3-D coordinates for the object. The orientation of the axes matters as it can affect the chirality of object.

    * @return double
    */
    public double getX2() {
        CMLAttribute _att_x2 = (CMLAttribute) getAttribute("x2");
        if (_att_x2 == null) {
            return Double.NaN;
        }
        return ((DoubleAttribute)_att_x2).getDouble();
    }
    /** x2 coordinate for an object.
    *
    * Used for displaying the object in 2 dimensions. Unrelated to the 3-D coordinates for the object. The orientation of the axes matters as it can affect the chirality of object.

    * @param value x2 value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setX2(double value) throws CMLRuntimeException {
            CMLAttribute _att_x2 = null;
            try {
        		_att_x2 = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("x2"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_x2 == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : x2; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_x2);
        ((DoubleAttribute)_att_x2).setCMLValue(value);
    }
    /** x2 coordinate for an object.
    *
    * Used for displaying the object in 2 dimensions. Unrelated to the 3-D coordinates for the object. The orientation of the axes matters as it can affect the chirality of object.

    * @param value x2 value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setX2(String value) throws CMLRuntimeException {
            CMLAttribute _att_x2 = new DoubleAttribute((DoubleAttribute)CMLAttributeList.getAttribute("x2"));
            if (_att_x2 == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : x2; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_x2);
        ((DoubleAttribute)_att_x2).setCMLValue(value);
    }
    /** y2 coordinate for an object.
    *
    * Used for displaying the object in 2 
    * dimensions. Unrelated to the 3-D coordinates for the object. The 
    * orientation of the axes matters as it can affect the chirality of 
    * object.

    * @return CMLAttribute
    */
    public CMLAttribute getY2Attribute() {
        return (CMLAttribute) getAttribute("y2");
    }
    /** y2 coordinate for an object.
    *
    * Used for displaying the object in 2 
    * dimensions. Unrelated to the 3-D coordinates for the object. The 
    * orientation of the axes matters as it can affect the chirality of 
    * object.

    * @return double
    */
    public double getY2() {
        CMLAttribute _att_y2 = (CMLAttribute) getAttribute("y2");
        if (_att_y2 == null) {
            return Double.NaN;
        }
        return ((DoubleAttribute)_att_y2).getDouble();
    }
    /** y2 coordinate for an object.
    *
    * Used for displaying the object in 2 
    * dimensions. Unrelated to the 3-D coordinates for the object. The 
    * orientation of the axes matters as it can affect the chirality of 
    * object.

    * @param value y2 value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setY2(double value) throws CMLRuntimeException {
            CMLAttribute _att_y2 = null;
            try {
        		_att_y2 = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("y2"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_y2 == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : y2; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_y2);
        ((DoubleAttribute)_att_y2).setCMLValue(value);
    }
    /** y2 coordinate for an object.
    *
    * Used for displaying the object in 2 
    * dimensions. Unrelated to the 3-D coordinates for the object. The 
    * orientation of the axes matters as it can affect the chirality of 
    * object.

    * @param value y2 value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setY2(String value) throws CMLRuntimeException {
            CMLAttribute _att_y2 = new DoubleAttribute((DoubleAttribute)CMLAttributeList.getAttribute("y2"));
            if (_att_y2 == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : y2; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_y2);
        ((DoubleAttribute)_att_y2).setCMLValue(value);
    }
    /** The x coordinate of a 3 dimensional object.
    *
    * The default units are Angstrom. (The provision 
    * for other units is weak at present.) Objects are always described 
    * with a right-handed coordinate system.

    * @return CMLAttribute
    */
    public CMLAttribute getX3Attribute() {
        return (CMLAttribute) getAttribute("x3");
    }
    /** The x coordinate of a 3 dimensional object.
    *
    * The default units are Angstrom. (The provision 
    * for other units is weak at present.) Objects are always described 
    * with a right-handed coordinate system.

    * @return double
    */
    public double getX3() {
        CMLAttribute _att_x3 = (CMLAttribute) getAttribute("x3");
        if (_att_x3 == null) {
            return Double.NaN;
        }
        return ((DoubleAttribute)_att_x3).getDouble();
    }
    /** The x coordinate of a 3 dimensional object.
    *
    * The default units are Angstrom. (The provision 
    * for other units is weak at present.) Objects are always described 
    * with a right-handed coordinate system.

    * @param value x3 value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setX3(double value) throws CMLRuntimeException {
            CMLAttribute _att_x3 = null;
            try {
        		_att_x3 = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("x3"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_x3 == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : x3; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_x3);
        ((DoubleAttribute)_att_x3).setCMLValue(value);
    }
    /** The x coordinate of a 3 dimensional object.
    *
    * The default units are Angstrom. (The provision 
    * for other units is weak at present.) Objects are always described 
    * with a right-handed coordinate system.

    * @param value x3 value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setX3(String value) throws CMLRuntimeException {
            CMLAttribute _att_x3 = new DoubleAttribute((DoubleAttribute)CMLAttributeList.getAttribute("x3"));
            if (_att_x3 == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : x3; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_x3);
        ((DoubleAttribute)_att_x3).setCMLValue(value);
    }
    /** The y coordinate of a 3 dimensional object.
    *
    * The default units are Angstrom. (The 
    * provision for other units is weak at present.) Objects are always 
    * described with a right-handed coordinate system.

    * @return CMLAttribute
    */
    public CMLAttribute getY3Attribute() {
        return (CMLAttribute) getAttribute("y3");
    }
    /** The y coordinate of a 3 dimensional object.
    *
    * The default units are Angstrom. (The 
    * provision for other units is weak at present.) Objects are always 
    * described with a right-handed coordinate system.

    * @return double
    */
    public double getY3() {
        CMLAttribute _att_y3 = (CMLAttribute) getAttribute("y3");
        if (_att_y3 == null) {
            return Double.NaN;
        }
        return ((DoubleAttribute)_att_y3).getDouble();
    }
    /** The y coordinate of a 3 dimensional object.
    *
    * The default units are Angstrom. (The 
    * provision for other units is weak at present.) Objects are always 
    * described with a right-handed coordinate system.

    * @param value y3 value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setY3(double value) throws CMLRuntimeException {
            CMLAttribute _att_y3 = null;
            try {
        		_att_y3 = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("y3"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_y3 == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : y3; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_y3);
        ((DoubleAttribute)_att_y3).setCMLValue(value);
    }
    /** The y coordinate of a 3 dimensional object.
    *
    * The default units are Angstrom. (The 
    * provision for other units is weak at present.) Objects are always 
    * described with a right-handed coordinate system.

    * @param value y3 value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setY3(String value) throws CMLRuntimeException {
            CMLAttribute _att_y3 = new DoubleAttribute((DoubleAttribute)CMLAttributeList.getAttribute("y3"));
            if (_att_y3 == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : y3; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_y3);
        ((DoubleAttribute)_att_y3).setCMLValue(value);
    }
    /** The z coordinate of a 3 dimensional object.
    *
    * The default units are Angstrom. (The 
    * provision for other units is weak at present.) Objects are always 
    * described with a right-handed coordinate system.

    * @return CMLAttribute
    */
    public CMLAttribute getZ3Attribute() {
        return (CMLAttribute) getAttribute("z3");
    }
    /** The z coordinate of a 3 dimensional object.
    *
    * The default units are Angstrom. (The 
    * provision for other units is weak at present.) Objects are always 
    * described with a right-handed coordinate system.

    * @return double
    */
    public double getZ3() {
        CMLAttribute _att_z3 = (CMLAttribute) getAttribute("z3");
        if (_att_z3 == null) {
            return Double.NaN;
        }
        return ((DoubleAttribute)_att_z3).getDouble();
    }
    /** The z coordinate of a 3 dimensional object.
    *
    * The default units are Angstrom. (The 
    * provision for other units is weak at present.) Objects are always 
    * described with a right-handed coordinate system.

    * @param value z3 value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setZ3(double value) throws CMLRuntimeException {
            CMLAttribute _att_z3 = null;
            try {
        		_att_z3 = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("z3"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_z3 == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : z3; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_z3);
        ((DoubleAttribute)_att_z3).setCMLValue(value);
    }
    /** The z coordinate of a 3 dimensional object.
    *
    * The default units are Angstrom. (The 
    * provision for other units is weak at present.) Objects are always 
    * described with a right-handed coordinate system.

    * @param value z3 value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setZ3(String value) throws CMLRuntimeException {
            CMLAttribute _att_z3 = new DoubleAttribute((DoubleAttribute)CMLAttributeList.getAttribute("z3"));
            if (_att_z3 == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : z3; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_z3);
        ((DoubleAttribute)_att_z3).setCMLValue(value);
    }
    /** Fractional x coordinate.
    *
    * normally xFract, yFract and zFract should all be present or absent. If present a _crystal_ element should also occur.

    * @return CMLAttribute
    */
    public CMLAttribute getXFractAttribute() {
        return (CMLAttribute) getAttribute("xFract");
    }
    /** Fractional x coordinate.
    *
    * normally xFract, yFract and zFract should all be present or absent. If present a _crystal_ element should also occur.

    * @return double
    */
    public double getXFract() {
        CMLAttribute _att_xFract = (CMLAttribute) getAttribute("xFract");
        if (_att_xFract == null) {
            return Double.NaN;
        }
        return ((DoubleAttribute)_att_xFract).getDouble();
    }
    /** Fractional x coordinate.
    *
    * normally xFract, yFract and zFract should all be present or absent. If present a _crystal_ element should also occur.

    * @param value xFract value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setXFract(double value) throws CMLRuntimeException {
            CMLAttribute _att_xFract = null;
            try {
        		_att_xFract = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("xFract"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_xFract == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : xFract; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_xFract);
        ((DoubleAttribute)_att_xFract).setCMLValue(value);
    }
    /** Fractional x coordinate.
    *
    * normally xFract, yFract and zFract should all be present or absent. If present a _crystal_ element should also occur.

    * @param value xFract value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setXFract(String value) throws CMLRuntimeException {
            CMLAttribute _att_xFract = new DoubleAttribute((DoubleAttribute)CMLAttributeList.getAttribute("xFract"));
            if (_att_xFract == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : xFract; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_xFract);
        ((DoubleAttribute)_att_xFract).setCMLValue(value);
    }
    /** Fractional y coordinate.
    *
    * normally xFract, yFract and zFract 
    * should all be present or absent. If present a _crystal_ element 
    * should also occur.

    * @return CMLAttribute
    */
    public CMLAttribute getYFractAttribute() {
        return (CMLAttribute) getAttribute("yFract");
    }
    /** Fractional y coordinate.
    *
    * normally xFract, yFract and zFract 
    * should all be present or absent. If present a _crystal_ element 
    * should also occur.

    * @return double
    */
    public double getYFract() {
        CMLAttribute _att_yFract = (CMLAttribute) getAttribute("yFract");
        if (_att_yFract == null) {
            return Double.NaN;
        }
        return ((DoubleAttribute)_att_yFract).getDouble();
    }
    /** Fractional y coordinate.
    *
    * normally xFract, yFract and zFract 
    * should all be present or absent. If present a _crystal_ element 
    * should also occur.

    * @param value yFract value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setYFract(double value) throws CMLRuntimeException {
            CMLAttribute _att_yFract = null;
            try {
        		_att_yFract = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("yFract"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_yFract == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : yFract; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_yFract);
        ((DoubleAttribute)_att_yFract).setCMLValue(value);
    }
    /** Fractional y coordinate.
    *
    * normally xFract, yFract and zFract 
    * should all be present or absent. If present a _crystal_ element 
    * should also occur.

    * @param value yFract value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setYFract(String value) throws CMLRuntimeException {
            CMLAttribute _att_yFract = new DoubleAttribute((DoubleAttribute)CMLAttributeList.getAttribute("yFract"));
            if (_att_yFract == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : yFract; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_yFract);
        ((DoubleAttribute)_att_yFract).setCMLValue(value);
    }
    /** Fractional y coordinate.
    *
    * normally xFract, yFract and zFract 
    * should all be present or absent. If present a _crystal_ element 
    * should also occur.

    * @return CMLAttribute
    */
    public CMLAttribute getZFractAttribute() {
        return (CMLAttribute) getAttribute("zFract");
    }
    /** Fractional y coordinate.
    *
    * normally xFract, yFract and zFract 
    * should all be present or absent. If present a _crystal_ element 
    * should also occur.

    * @return double
    */
    public double getZFract() {
        CMLAttribute _att_zFract = (CMLAttribute) getAttribute("zFract");
        if (_att_zFract == null) {
            return Double.NaN;
        }
        return ((DoubleAttribute)_att_zFract).getDouble();
    }
    /** Fractional y coordinate.
    *
    * normally xFract, yFract and zFract 
    * should all be present or absent. If present a _crystal_ element 
    * should also occur.

    * @param value zFract value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setZFract(double value) throws CMLRuntimeException {
            CMLAttribute _att_zFract = null;
            try {
        		_att_zFract = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("zFract"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_zFract == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : zFract; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_zFract);
        ((DoubleAttribute)_att_zFract).setCMLValue(value);
    }
    /** Fractional y coordinate.
    *
    * normally xFract, yFract and zFract 
    * should all be present or absent. If present a _crystal_ element 
    * should also occur.

    * @param value zFract value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setZFract(String value) throws CMLRuntimeException {
            CMLAttribute _att_zFract = new DoubleAttribute((DoubleAttribute)CMLAttributeList.getAttribute("zFract"));
            if (_att_zFract == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : zFract; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_zFract);
        ((DoubleAttribute)_att_zFract).setCMLValue(value);
    }
    /** A title on an element.
    *
    * No controlled value.

    * @return CMLAttribute
    */
    public CMLAttribute getTitleAttribute() {
        return (CMLAttribute) getAttribute("title");
    }
    /** A title on an element.
    *
    * No controlled value.

    * @return String
    */
    public String getTitle() {
        CMLAttribute _att_title = (CMLAttribute) getAttribute("title");
        if (_att_title == null) {
            return null;
        }
        return ((StringAttribute)_att_title).getString();
    }
    /** A title on an element.
    *
    * No controlled value.

    * @param value title value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setTitle(String value) throws CMLRuntimeException {
            CMLAttribute _att_title = null;
            try {
        		_att_title = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("title"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_title == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : title; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_title);
        ((StringAttribute)_att_title).setCMLValue(value);
    }
    /** Role of the object.
    *
    * How the object functions or its position in the architecture. No controlled vocabulary.

    * @return CMLAttribute
    */
    public CMLAttribute getRoleAttribute() {
        return (CMLAttribute) getAttribute("role");
    }
    /** Role of the object.
    *
    * How the object functions or its position in the architecture. No controlled vocabulary.

    * @return String
    */
    public String getRole() {
        CMLAttribute _att_role = (CMLAttribute) getAttribute("role");
        if (_att_role == null) {
            return null;
        }
        return ((StringAttribute)_att_role).getString();
    }
    /** Role of the object.
    *
    * How the object functions or its position in the architecture. No controlled vocabulary.

    * @param value role value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setRole(String value) throws CMLRuntimeException {
            CMLAttribute _att_role = null;
            try {
        		_att_role = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("role"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_role == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : role; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_role);
        ((StringAttribute)_att_role).setCMLValue(value);
    }
    /** SpaceGroup multiplicity.
    *
    * Normally for an atom. This attribute gives the spaceGroup multiplicity of the molecule and is independent of any atomic information. No default, and it may take any positive integer value 
    * (though values are normally between 1 and 192. It represents the number of symmetry operations
    *  (without cell translations) that transform the atom into itself. 
    * Thus an atom on a centre of symmetry can have a spaceGroupMultiplicity of 2.
    *  The spaceGroupMultiplicity can be deduced from a knowledge of the
    *  coordinates and the spaceGroup operators and so is formally redundant but this is a
    *  useful convenience operator. Some crystallographic experiments report this attribute
    *  as, for example, the IUCr CIF item 'atom_site_symmetry_multiplicity'.
    *  Distinguish carefully from occupancy which represents incomplete occupation of a 
    * site.
    * --type info--
    * 
    * MinExclusive: 0

    * @return CMLAttribute
    */
    public CMLAttribute getSpaceGroupMultiplicityAttribute() {
        return (CMLAttribute) getAttribute("spaceGroupMultiplicity");
    }
    /** SpaceGroup multiplicity.
    *
    * Normally for an atom. This attribute gives the spaceGroup multiplicity of the molecule and is independent of any atomic information. No default, and it may take any positive integer value 
    * (though values are normally between 1 and 192. It represents the number of symmetry operations
    *  (without cell translations) that transform the atom into itself. 
    * Thus an atom on a centre of symmetry can have a spaceGroupMultiplicity of 2.
    *  The spaceGroupMultiplicity can be deduced from a knowledge of the
    *  coordinates and the spaceGroup operators and so is formally redundant but this is a
    *  useful convenience operator. Some crystallographic experiments report this attribute
    *  as, for example, the IUCr CIF item 'atom_site_symmetry_multiplicity'.
    *  Distinguish carefully from occupancy which represents incomplete occupation of a 
    * site.
    * --type info--
    * 
    * MinExclusive: 0

    * @return int
    */
    public int getSpaceGroupMultiplicity() {
        CMLAttribute _att_spaceGroupMultiplicity = (CMLAttribute) getAttribute("spaceGroupMultiplicity");
        if (_att_spaceGroupMultiplicity == null) {
            CMLUtil.BUG("unset attribute: spaceGroupMultiplicity");
        }
        return ((IntAttribute)_att_spaceGroupMultiplicity).getInt();
    }
    /** SpaceGroup multiplicity.
    *
    * Normally for an atom. This attribute gives the spaceGroup multiplicity of the molecule and is independent of any atomic information. No default, and it may take any positive integer value 
    * (though values are normally between 1 and 192. It represents the number of symmetry operations
    *  (without cell translations) that transform the atom into itself. 
    * Thus an atom on a centre of symmetry can have a spaceGroupMultiplicity of 2.
    *  The spaceGroupMultiplicity can be deduced from a knowledge of the
    *  coordinates and the spaceGroup operators and so is formally redundant but this is a
    *  useful convenience operator. Some crystallographic experiments report this attribute
    *  as, for example, the IUCr CIF item 'atom_site_symmetry_multiplicity'.
    *  Distinguish carefully from occupancy which represents incomplete occupation of a 
    * site.
    * --type info--
    * 
    * MinExclusive: 0

    * @param value spaceGroupMultiplicity value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setSpaceGroupMultiplicity(int value) throws CMLRuntimeException {
            CMLAttribute _att_spaceGroupMultiplicity = null;
            try {
        		_att_spaceGroupMultiplicity = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("spaceGroupMultiplicity"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_spaceGroupMultiplicity == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : spaceGroupMultiplicity; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_spaceGroupMultiplicity);
        ((IntAttribute)_att_spaceGroupMultiplicity).setCMLValue(value);
    }
    /** SpaceGroup multiplicity.
    *
    * Normally for an atom. This attribute gives the spaceGroup multiplicity of the molecule and is independent of any atomic information. No default, and it may take any positive integer value 
    * (though values are normally between 1 and 192. It represents the number of symmetry operations
    *  (without cell translations) that transform the atom into itself. 
    * Thus an atom on a centre of symmetry can have a spaceGroupMultiplicity of 2.
    *  The spaceGroupMultiplicity can be deduced from a knowledge of the
    *  coordinates and the spaceGroup operators and so is formally redundant but this is a
    *  useful convenience operator. Some crystallographic experiments report this attribute
    *  as, for example, the IUCr CIF item 'atom_site_symmetry_multiplicity'.
    *  Distinguish carefully from occupancy which represents incomplete occupation of a 
    * site.
    * --type info--
    * 
    * MinExclusive: 0

    * @param value spaceGroupMultiplicity value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setSpaceGroupMultiplicity(String value) throws CMLRuntimeException {
            CMLAttribute _att_spaceGroupMultiplicity = new IntAttribute((IntAttribute)CMLAttributeList.getAttribute("spaceGroupMultiplicity"));
            if (_att_spaceGroupMultiplicity == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : spaceGroupMultiplicity; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_spaceGroupMultiplicity);
        ((IntAttribute)_att_spaceGroupMultiplicity).setCMLValue(value);
    }
    /** SpaceGroup multiplicity.
    *
    * Normally for an atom. This attribute gives the pointGroup multiplicity of the molecule and is independent of any atomic information. No default, and it may take any positive integer value 
    * (though values are normally between 1 and 60 (for icosahedral). It represents the number of symmetry operations
    *  (without any translations) that transform the atom into itself. 
    * Thus an atom on a centre of symmetry can have a pointGroupMultiplicity of 2.
    *  The pointGroupMultiplicity can be deduced from a knowledge of the
    *  coordinates and the pointGroup operators and so is formally redundant but this is a
    *  useful convenience operator. 
    * Distinguish carefully from occupancy which represents incomplete occupation of a 
    * site.
    * --type info--
    * 
    * MinExclusive: 0

    * @return CMLAttribute
    */
    public CMLAttribute getPointGroupMultiplicityAttribute() {
        return (CMLAttribute) getAttribute("pointGroupMultiplicity");
    }
    /** SpaceGroup multiplicity.
    *
    * Normally for an atom. This attribute gives the pointGroup multiplicity of the molecule and is independent of any atomic information. No default, and it may take any positive integer value 
    * (though values are normally between 1 and 60 (for icosahedral). It represents the number of symmetry operations
    *  (without any translations) that transform the atom into itself. 
    * Thus an atom on a centre of symmetry can have a pointGroupMultiplicity of 2.
    *  The pointGroupMultiplicity can be deduced from a knowledge of the
    *  coordinates and the pointGroup operators and so is formally redundant but this is a
    *  useful convenience operator. 
    * Distinguish carefully from occupancy which represents incomplete occupation of a 
    * site.
    * --type info--
    * 
    * MinExclusive: 0

    * @return int
    */
    public int getPointGroupMultiplicity() {
        CMLAttribute _att_pointGroupMultiplicity = (CMLAttribute) getAttribute("pointGroupMultiplicity");
        if (_att_pointGroupMultiplicity == null) {
            CMLUtil.BUG("unset attribute: pointGroupMultiplicity");
        }
        return ((IntAttribute)_att_pointGroupMultiplicity).getInt();
    }
    /** SpaceGroup multiplicity.
    *
    * Normally for an atom. This attribute gives the pointGroup multiplicity of the molecule and is independent of any atomic information. No default, and it may take any positive integer value 
    * (though values are normally between 1 and 60 (for icosahedral). It represents the number of symmetry operations
    *  (without any translations) that transform the atom into itself. 
    * Thus an atom on a centre of symmetry can have a pointGroupMultiplicity of 2.
    *  The pointGroupMultiplicity can be deduced from a knowledge of the
    *  coordinates and the pointGroup operators and so is formally redundant but this is a
    *  useful convenience operator. 
    * Distinguish carefully from occupancy which represents incomplete occupation of a 
    * site.
    * --type info--
    * 
    * MinExclusive: 0

    * @param value pointGroupMultiplicity value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    public void setPointGroupMultiplicity(int value) throws CMLRuntimeException {
            CMLAttribute _att_pointGroupMultiplicity = null;
            try {
        		_att_pointGroupMultiplicity = (CMLAttribute) org.xmlcml.cml.element.SpecialAttribute.createSubclassedAttribute(this, CMLAttributeList.getAttribute("pointGroupMultiplicity"));
        	} catch (CMLException e) {
        		throw new CMLRuntimeException("bug "+e);
        	}
            if (_att_pointGroupMultiplicity == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : pointGroupMultiplicity; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_pointGroupMultiplicity);
        ((IntAttribute)_att_pointGroupMultiplicity).setCMLValue(value);
    }
    /** SpaceGroup multiplicity.
    *
    * Normally for an atom. This attribute gives the pointGroup multiplicity of the molecule and is independent of any atomic information. No default, and it may take any positive integer value 
    * (though values are normally between 1 and 60 (for icosahedral). It represents the number of symmetry operations
    *  (without any translations) that transform the atom into itself. 
    * Thus an atom on a centre of symmetry can have a pointGroupMultiplicity of 2.
    *  The pointGroupMultiplicity can be deduced from a knowledge of the
    *  coordinates and the pointGroup operators and so is formally redundant but this is a
    *  useful convenience operator. 
    * Distinguish carefully from occupancy which represents incomplete occupation of a 
    * site.
    * --type info--
    * 
    * MinExclusive: 0

    * @param value pointGroupMultiplicity value
    * @throws CMLRuntimeException attribute wrong value/type

    */
    private void setPointGroupMultiplicity(String value) throws CMLRuntimeException {
            CMLAttribute _att_pointGroupMultiplicity = new IntAttribute((IntAttribute)CMLAttributeList.getAttribute("pointGroupMultiplicity"));
            if (_att_pointGroupMultiplicity == null) {
                throw new CMLRuntimeException("BUG: cannot process attributeGroupName : pointGroupMultiplicity; probably incompatible attributeGroupName and attributeName");
            }
            super.addAttribute(_att_pointGroupMultiplicity);
        ((IntAttribute)_att_pointGroupMultiplicity).setCMLValue(value);
    }
    /** add atom element.
    *
    * @param electron electron child to add

    */
    public void addElectron(AbstractElectron electron) {
        electron.detach();
        this.appendChild(electron);
    }
    /** get atom child elements .
    *
    * @return CMLElements<CMLElectron>
    */
    public CMLElements<CMLElectron> getElectronElements() {
        Elements elements = this.getChildElements("electron", CML_NS);
        return new CMLElements<CMLElectron>(elements);
    }
    /** add atom element.
    *
    * @param matrix matrix child to add

    */
    public void addMatrix(AbstractMatrix matrix) {
        matrix.detach();
        this.appendChild(matrix);
    }
    /** get atom child elements .
    *
    * @return CMLElements<CMLMatrix>
    */
    public CMLElements<CMLMatrix> getMatrixElements() {
        Elements elements = this.getChildElements("matrix", CML_NS);
        return new CMLElements<CMLMatrix>(elements);
    }
    /** add atom element.
    *
    * @param vector3 vector3 child to add

    */
    public void addVector3(AbstractVector3 vector3) {
        vector3.detach();
        this.appendChild(vector3);
    }
    /** get atom child elements .
    *
    * @return CMLElements<CMLVector3>
    */
    public CMLElements<CMLVector3> getVector3Elements() {
        Elements elements = this.getChildElements("vector3", CML_NS);
        return new CMLElements<CMLVector3>(elements);
    }
    /** add atom element.
    *
    * @param atomType atomType child to add

    */
    public void addAtomType(AbstractAtomType atomType) {
        atomType.detach();
        this.appendChild(atomType);
    }
    /** get atom child elements .
    *
    * @return CMLElements<CMLAtomType>
    */
    public CMLElements<CMLAtomType> getAtomTypeElements() {
        Elements elements = this.getChildElements("atomType", CML_NS);
        return new CMLElements<CMLAtomType>(elements);
    }
    /** add atom element.
    *
    * @param label label child to add

    */
    public void addLabel(AbstractLabel label) {
        label.detach();
        this.appendChild(label);
    }
    /** get atom child elements .
    *
    * @return CMLElements<CMLLabel>
    */
    public CMLElements<CMLLabel> getLabelElements() {
        Elements elements = this.getChildElements("label", CML_NS);
        return new CMLElements<CMLLabel>(elements);
    }
    /** add atom element.
    *
    * @param atomParity atomParity child to add

    */
    public void addAtomParity(AbstractAtomParity atomParity) {
        atomParity.detach();
        this.appendChild(atomParity);
    }
    /** get atom child elements .
    *
    * @return CMLElements<CMLAtomParity>
    */
    public CMLElements<CMLAtomParity> getAtomParityElements() {
        Elements elements = this.getChildElements("atomParity", CML_NS);
        return new CMLElements<CMLAtomParity>(elements);
    }
    /** add atom element.
    *
    * @param particle particle child to add

    */
    public void addParticle(AbstractParticle particle) {
        particle.detach();
        this.appendChild(particle);
    }
    /** get atom child elements .
    *
    * @return CMLElements<CMLParticle>
    */
    public CMLElements<CMLParticle> getParticleElements() {
        Elements elements = this.getChildElements("particle", CML_NS);
        return new CMLElements<CMLParticle>(elements);
    }
    /** add atom element.
    *
    * @param name name child to add

    */
    public void addName(AbstractName name) {
        name.detach();
        this.appendChild(name);
    }
    /** get atom child elements .
    *
    * @return CMLElements<CMLName>
    */
    public CMLElements<CMLName> getNameElements() {
        Elements elements = this.getChildElements("name", CML_NS);
        return new CMLElements<CMLName>(elements);
    }
    /** add atom element.
    *
    * @param scalar scalar child to add

    */
    public void addScalar(AbstractScalar scalar) {
        scalar.detach();
        this.appendChild(scalar);
    }
    /** get atom child elements .
    *
    * @return CMLElements<CMLScalar>
    */
    public CMLElements<CMLScalar> getScalarElements() {
        Elements elements = this.getChildElements("scalar", CML_NS);
        return new CMLElements<CMLScalar>(elements);
    }
    /** add atom element.
    *
    * @param array array child to add

    */
    public void addArray(AbstractArray array) {
        array.detach();
        this.appendChild(array);
    }
    /** get atom child elements .
    *
    * @return CMLElements<CMLArray>
    */
    public CMLElements<CMLArray> getArrayElements() {
        Elements elements = this.getChildElements("array", CML_NS);
        return new CMLElements<CMLArray>(elements);
    }
    /** overrides addAttribute(Attribute).
    *
    * reroutes calls to setFoo()

    * @param att  attribute

    */
    public void addAttribute(Attribute att) {
        String name = att.getLocalName();
        String value = att.getValue();
        if (name == null) {
        } else if (name.equals("id")) {
            setId(value);
        } else if (name.equals("convention")) {
            setConvention(value);
        } else if (name.equals("dictRef")) {
            setDictRef(value);
        } else if (name.equals("ref")) {
            setRef(value);
        } else if (name.equals("count")) {
            setCount(value);
        } else if (name.equals("elementType")) {
            setElementType(value);
        } else if (name.equals("formalCharge")) {
            setFormalCharge(value);
        } else if (name.equals("hydrogenCount")) {
            setHydrogenCount(value);
        } else if (name.equals("isotope")) {
            setIsotope(value);
        } else if (name.equals("isotopeNumber")) {
            setIsotopeNumber(value);
        } else if (name.equals("isotopeRef")) {
            setIsotopeRef(value);
        } else if (name.equals("isotopeListRef")) {
            setIsotopeListRef(value);
        } else if (name.equals("occupancy")) {
            setOccupancy(value);
        } else if (name.equals("spinMultiplicity")) {
            setSpinMultiplicity(value);
        } else if (name.equals("x2")) {
            setX2(value);
        } else if (name.equals("y2")) {
            setY2(value);
        } else if (name.equals("x3")) {
            setX3(value);
        } else if (name.equals("y3")) {
            setY3(value);
        } else if (name.equals("z3")) {
            setZ3(value);
        } else if (name.equals("xFract")) {
            setXFract(value);
        } else if (name.equals("yFract")) {
            setYFract(value);
        } else if (name.equals("zFract")) {
            setZFract(value);
        } else if (name.equals("title")) {
            setTitle(value);
        } else if (name.equals("role")) {
            setRole(value);
        } else if (name.equals("spaceGroupMultiplicity")) {
            setSpaceGroupMultiplicity(value);
        } else if (name.equals("pointGroupMultiplicity")) {
            setPointGroupMultiplicity(value);
        } else {
            super.addAttribute(att);
        }
    }
}
