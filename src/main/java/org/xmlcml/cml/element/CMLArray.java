package org.xmlcml.cml.element;

import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;

import nu.xom.Attribute;
import nu.xom.Element;
import nu.xom.Node;

import org.xmlcml.cml.base.CMLElements;
import org.xmlcml.cml.base.CMLException;
import org.xmlcml.cml.base.CMLRuntimeException;
import org.xmlcml.euclid.EuclidException;
import org.xmlcml.euclid.IntArray;
import org.xmlcml.euclid.RealArray;
import org.xmlcml.euclid.Util;

/**
 * user-modifiable class supporting array. * autogenerated from schema use as a
 * shell which can be edited
 * 
 */
public class CMLArray extends AbstractArray 
    implements HasUnits, HasArraySize {

    static Logger logger = Logger.getLogger(CMLArray.class.getName());
	/** namespaced element name.*/
	public final static String NS = C_E+TAG;

    /**
     * constructor.
     */
    public CMLArray() {
        init();
    }

    private void init() {
        setXMLContent(S_EMPTY);
    }

    /**
     * constructor.
     * 
     * @param old
     */
    public CMLArray(CMLArray old) {
        super((AbstractArray) old);

    }

    /**
     * constructor.
     * copies metadat from tableHeaderCell
     * @param tableHeaderCell
     * @param delimiter
     */
    public CMLArray(CMLTableHeaderCell tableHeaderCell, String delimiter) {
        this();
        if (tableHeaderCell.getTitleAttribute() != null) {
            this.setTitle(tableHeaderCell.getTitle());
        }
        if (tableHeaderCell.getIdAttribute() != null) {
            this.setId(tableHeaderCell.getId());
        }
        if (tableHeaderCell.getDictRefAttribute() != null) {
            this.setDictRef(tableHeaderCell.getDictRef());
        }
        if (tableHeaderCell.getConventionAttribute() != null) {
            this.setConvention(tableHeaderCell.getConvention());
        }
        if (tableHeaderCell.getConstantToSIAttribute() != null) {
            this.setConstantToSI(tableHeaderCell.getConstantToSI());
        }
        if (tableHeaderCell.getMultiplierToSIAttribute() != null) {
            this.setMultiplierToSI(tableHeaderCell.getMultiplierToSI());
        }
        if (tableHeaderCell.getDataTypeAttribute() != null) {
            this.setDataType(tableHeaderCell.getDataType());
        }
        if (tableHeaderCell.getUnitTypeAttribute() != null) {
            this.setUnitType(tableHeaderCell.getUnitType());
        }
        if (tableHeaderCell.getUnitsAttribute() != null) {
            this.setUnits(tableHeaderCell.getUnits());
        }
        this.setDelimiter((delimiter == S_EMPTY) ? S_WHITEREGEX : delimiter);
    }

    /**
     * copy node .
     * 
     * @return Node
     */
    public Node copy() {
        return new CMLArray(this);

    }

    /**
     * create new instance in context of parent, overridable by subclasses.
     * 
     * @param parent
     *            parent of element to be constructed (ignored by default)
     * @return CMLArray
     */
    public static CMLArray makeElementInContext(Element parent) {
        return new CMLArray();

    }

    /**
     * check array is OK.
     * 
     * @param parent
     *            element
     */
    public void finishMakingElement(Element parent) {
        int ll = -1;
        int size = -1;
        if (this.getSizeAttribute() != null) {
            String aa = super.getAttributeValue("size");
            size = Integer.parseInt(aa);
        }
        String dataType = this.getDataType();
        if (dataType.equals(XSD_STRING)) {
            String[] ss = this.getStrings();
            ll = ss.length;
        } else if (dataType.equals(XSD_DOUBLE)) {
            try {
                double[] ss = this.getDoubles();
                ll = ss.length;
            } catch (CMLRuntimeException e) {
                throw new CMLRuntimeException("cannot parse as doubles: "
                        + this.getXMLContent());
            }
        } else if (dataType.equals(XSD_INTEGER)) {
            try {
                int[] ss = this.getInts();
                ll = ss.length;
            } catch (CMLRuntimeException e) {
                throw new CMLRuntimeException("cannot parse as ints: "
                        + this.getXMLContent());
            }
        } else if (dataType.equals(CML_DATATYPETYPE)) {
            String[] ss = this.getStrings();
            ll = ss.length;
        } else if (dataType.equals(CML_NAMESPACEREFTYPE)) {
            String[] ss = this.getStrings();
            ll = ss.length;
        } else if (dataType.equals(CML_UNITSTYPE)) {
            String[] ss = this.getStrings();
            ll = ss.length;
        } else {
            throw new CMLRuntimeException("array does  not support dataType: "
                    + dataType);
        }
        if (size != -1 && ll != size) {
            throw new CMLRuntimeException("Size attribute: " + size
                    + " incompatible with content: " + ll);
        }
        if (size != -1) {
            this.resetSize(ll);
        } else {
            this.removeAttribute("size");
        }
    }

    // =========================== additional constructors
    // ========================

    /**
     * formed from components. size is extracted from array dimensions sets
     * dataType to xsd:string cannot use default delimiter (S_SPACE) if strings
     * contain whitespace, so choose another delimiter
     * 
     * @param array
     * @throws CMLRuntimeException
     *             strings must not contain whitespace
     */
    public CMLArray(String[] array) throws CMLRuntimeException {
        this.setArray(array);
    }

    /**
     * formed from components. size is extracted from array dimensions sets
     * dataType to xsd:string cannot use delimiter if strings contain it, so
     * choose another delimiter
     * 
     * @param array
     * @param delimiter
     * @throws CMLException
     *             strings must not contain delimiter
     */
    public CMLArray(String[] array, String delimiter) throws CMLException {
        setDelimiter(delimiter);
        this.setArray(array);
    }

    /**
     * formed from components. size is extracted from array dimensions sets
     * dataType to xsd:double
     * 
     * @param array
     */
    public CMLArray(double[] array) {
        this.setArray(array);
    }

    /**
     * formed from components. size is extracted from array dimensions sets
     * dataType to xsd:double cannot use delimiter if strings contain it, so
     * choose another delimiter
     * 
     * @param array
     * @param delimiter
     * @throws CMLException
     *             strings must not contain delimiter
     */
    public CMLArray(double[] array, String delimiter) throws CMLException {
        setDelimiter(delimiter);
        this.setArray(array);
    }

    /**
     * formed from components. size is extracted from array dimensions sets
     * dataType to xsd:integer
     * 
     * @param array
     */
    public CMLArray(int[] array) {
        this.setArray(array);
    }

    /**
     * formed from components. size is extracted from array dimensions sets
     * dataType to xsd:integer cannot use delimiter if strings contain it, so
     * choose another delimiter
     * 
     * @param array
     * @param delimiter
     * @throws CMLException
     *             doubles must not contain delimiter
     */
    public CMLArray(int[] array, String delimiter) throws CMLException {
        setDelimiter(delimiter);
        this.setArray(array);
    }

    // ====================== housekeeping methods =====================

    /** get size of array.
     * @return size
     */
    public int getArraySize() {
        return this.getSize();
    }
    
    /** returns array of primitive types based on dataType.
     * @return double[], int[], String[] or null
     */
    public Object getPrimitiveArray() {
        Object primitiveArray = null;
        if (XSD_DOUBLE.equals(this.getDataType())) {
            primitiveArray = this.getDoubles();
        } else if (XSD_INTEGER.equals(this.getDataType())) {
            primitiveArray = this.getInts();
        } else if (XSD_STRING.equals(this.getDataType())) {
            primitiveArray = this.getStrings();
        } else {
            primitiveArray = this.getStrings();
        } 
        return primitiveArray;
    }
    
    /**
     * get strings.
     * 
     * @return strings
     */
    public String[] getStrings() {
        String[] ss = null;
        if (this.getDataType().equals(XSD_STRING)) {
            ss = getSplitContent();
        }
        return ss;
    }

    /**
     * splits content into tokens. if delimiter is whitespace, trims content and
     * splits at whitespace (however long) else assume starts and ends with
     * delimiter
     * 
     * @return the tokens
     * @throws CMLRuntimeException
     *             if size attribute is inconsistent
     */
    private String[] getSplitContent() throws CMLRuntimeException {
        String content = this.getXMLContent().trim();
        String delim = this.getDelimiter();
        String[] ss = new String[0];
        content = content.trim();
        if (content.length() > 0) {
            // space separated
            if (delim.trim().length() == 0) {
                ss = content.split(S_WHITEREGEX);
            } else {
                if (content.startsWith(delim)) {
                    content = content.substring(delim.length());
                }
                if (content.endsWith(delim)) {
                    content = content.substring(0, content.length()
                            - delim.length());
                }
                String delim1 = getEscapedDelimiter(delim);
                ss = content.trim().split(delim1);
            }
        }
        int size = -1;
        if (this.getSizeAttribute() == null) {
            size = ss.length;
            setSize(size);
        } else {
            size = super.getSize();
            if (ss.length != size) {
                // FIXME this is not yet working
                // throw new CMLRuntime("Bad array length: "+size+" incompatible
                // with elements: "+ss.length);
            }
        }
        return ss;
    }

    /**
     * adds escape for regex metacharacters. e.g. '|' transforms to '\\|'
     * 
     * @param delim
     * @return the escaped string
     */
    static String getEscapedDelimiter(String delim) {
        String delim1 = delim;
        // FIXME - need to add other regex characters
        if (delim.equals("|")) {
            delim1 = "\\" + delim;
        }
        return delim1;

    }

    /**
     * get doubles.
     * 
     * @return doubles
     * @throws CMLRuntimeException
     */
    public double[] getDoubles() throws CMLRuntimeException {
        double[] dd = null;
        if (this.getDataType().equals(XSD_DOUBLE)) {
            String[] ss = getSplitContent();
            dd = new double[ss.length];
            for (int i = 0; i < dd.length; i++) {
                try {
                    dd[i] = new Double(ss[i]).doubleValue();
                } catch (NumberFormatException nfe) {
                    throw new CMLRuntimeException("Bad double :" + ss[i]
                            + " at position: " + i);
                }
            }
        }
        return dd;
    }

    /**
     * get ints.
     * 
     * @return ints
     * @throws CMLRuntimeException
     */
    public int[] getInts() throws CMLRuntimeException {
        int[] ii = null;
        if (this.getDataType().equals(XSD_INTEGER)) {
            String[] ss = getSplitContent();
            ii = new int[ss.length];
            for (int i = 0; i < ii.length; i++) {
                try {
                    ii[i] = new Integer(ss[i]).intValue();
                } catch (NumberFormatException nfe) {
                    throw new CMLRuntimeException("Bad int :" + ss[i] + " at position: "
                            + i);
                }
            }
        }
        return ii;
    }

    /**
     * returns the String value of the array. convenience method to avoid
     * repeated accesses i.e. converts int and double to string
     * 
     * @return strings
     */
    public List<String> getStringValues() {
        List<String> values = new ArrayList<String>();
        if (this.getDataType().equals(XSD_INTEGER)) {
            int[] ints = this.getInts();
            for (int i : ints) {
                values.add(S_EMPTY + i);
            }
        } else if (this.getDataType().equals(XSD_DOUBLE)) {

            double[] doubles = this.getDoubles();
            for (double d : doubles) {
                values.add(S_EMPTY + d);
            }
        } else if (this.getDataType().equals(XSD_STRING)) {
            String[] strings = this.getStrings();
            for (String s : strings) {
                values.add(s);
            }
        }
        return values;
    }

    // ====================== subsidiary accessors =====================

    /**
     * sets components.
     * 
     * @param array
     * @throws CMLRuntimeException
     */
    public void setArray(String[] array) throws CMLRuntimeException {
        resetDataType(XSD_STRING);
        for (String s : array) {
            checkDelimiter(s, this.getDelimiter());
        }
        String delim = getDelimiter();
        setXMLContent(Util.concatenate(array, delim), delim);
        resetSize(array.length);
    }

    private void resetDataType(String type) {
        Attribute a = (this.getAttribute("dataType"));
        if (a != null) {
            this.removeAttribute(a);
        }
        super.setDataType(type);
    }

    private void resetSize(int size) {
        Attribute a = (this.getAttribute("size"));
        if (a != null) {
            this.removeAttribute(a);
        }
        super.setSize(size);
    }

    /**
     * set text content. if delimiter is not whitespace, prepend and append it
     * 
     * @param s
     * @param delim
     */
    private void setXMLContent(String s, String delim) {
        if (delim.trim().length() > 0) {
            s = delim + s + delim;
        }
        setXMLContent(s);
    }

    /**
     * append to text content. if delimiter is not whitespace, prepend and
     * append it
     * 
     * @param s
     *            previous string
     * @param snew
     *            to append
     * @param delim
     */
    private void appendXMLContent(String s, String delim, String snew) {
        if (delim.trim().length() > 0) {
            s += (snew + delim);
        } else {
            s += (delim + snew);
        }
        setXMLContent(s);
    }

    /**
     * checks that components does not clash with delimiter.
     * 
     * @param s
     *            string to check
     * @param d
     *            delimiter
     * @throws CMLRuntimeException
     *             if d is part of s
     */
    private void checkDelimiter(String s, String d) throws CMLRuntimeException {
        if (s.contains(d)) {
            throw new CMLRuntimeException("cannot delimit {" + s + "} with {" + d + S_RCURLY);
        }
    }

    /**
     * sets components.
     * 
     * @param array
     */
    public void setArray(double[] array) {
        resetDataType(XSD_DOUBLE);
        String delim = getDelimiter();
        setXMLContent(Util.concatenate(array, delim), delim);
        resetSize(array.length);
    }

    /**
     * sets components.
     * 
     * @param array
     */
    public void setArray(int[] array) {
        resetDataType(XSD_INTEGER);
        String delim = getDelimiter();
        setXMLContent(Util.concatenate(array, delim), delim);
        resetSize(array.length);
    }

    /**
     * gets size of array.
     * 
     * @return int size of array
     */
    public int getSize() {
        int size = -1;
        if (this.getSizeAttribute() != null) {
            size = super.getSize();
        } else {
            String[] array = this.getSplitContent();
            size = array.length;
        }
        return size;
    }

    /**
     * get delimiter. if none, use default S_SPACE.
     * 
     * @return delimiter
     */
    public String getDelimiter() {
        String delim = super.getDelimiter();
        if (delim == null || delim.equals(S_EMPTY)) {
            delim = S_SPACE;
        }
        return delim;
    }

    /**
     * get dataType. if attribute not set, reset to String.
     * 
     * @return dataType (default XSD_STRING)
     */
    public String getDataType() {
        String dataType = super.getDataType();
        if (dataType == null) {
            dataType = XSD_STRING;
            super.setDataType(dataType);
        }
        return dataType;
    }

    /**
     * set dataType.
     * 
     * sets dataType. Cannot reset after array is populated
     * 
     * @param dType
     *            (default XSD_STRING)
     * @throws CMLRuntimeException
     *             attempt to reset datatype
     */
    public void setDataType(String dType) {
        if (this.getDataTypeAttribute() != null) {
            throw new CMLRuntimeException("Cannot reset dataType");
        }
        super.setDataType(dType);
    }

    /**
     * set delimiter.
     * 
     * sets delimiter. Cannot reset after array is populated.
     * if delimiter is whitespace, removes the attribute
     * 
     * @param delim
     * @throws CMLRuntimeException
     *             attempt to reset datatype
     */
    public void setDelimiter(String delim) {
        if (delim == null || delim.trim().equals(S_EMPTY)) {
            this.removeAttribute("delimiter");
        } else if (this.getDelimiterAttribute() != null) {
            throw new CMLRuntimeException("Cannot reset delimiter");
        } else {
            super.setDelimiter(delim);
        }
    }

    /**
     * set size.
     * 
     * @deprecated not user-accesible - throws CMLRuntime sets delimiter. Cannot
     *             reset after array is populated if delimiter is whitespace,
     *             removes the attribute
     * @param s
     *            the size
     * @throws CMLRuntimeException
     *             attempt to reset datatype
     */
    public void setSize(int s) {
        if (this.getSizeAttribute() != null) {
            throw new CMLRuntimeException("user cannot reset size");
        }
        super.setSize(s);
    }

    // ====================== functionality =====================

    /**
     * can two arrays be used for arithmetic. checks that both arrays are
     * numeric and of same dataType and of same size
     * 
     * @param array
     *            the array to test; can have different owner
     * @throws CMLException
     *             if not of same numeric data type and size
     */
    public void checkNumericConformability(CMLArray array) throws CMLException {
        if (this.getDataType().equals(XSD_STRING)
                || !this.getDataType().equals(array.getDataType())
                || this.getSize() != array.getSize()) {
            throw new CMLException(
                    "Unsuitable dataTypes for numeric operations / "
                            + this.getDataType() + S_SLASH + this.getSize() + S_SLASH
                            + array.getDataType() + S_SLASH + array.getSize());
        }
    }

    /**
     * subtract an array from this..
     * 
     * result = this - array, owner document = this does not alter this only
     * works if both arrays are numeric and of same dataType
     * 
     * @param array
     *            the array to subtract; can have different owner
     * @throws CMLException
     *             inappropriate dataTypes, unequal arrays
     * @return new array
     */
    public CMLArray subtract(CMLArray array) throws CMLException {
        checkNumericConformability(array);
        CMLArray resultArray = null;
        try {
            if (this.getDataType().equals(XSD_DOUBLE)) {
                // FIXME this appears to be wrong in euclid
                // RealArray result = new RealArray(this.getDoubles()).
                // subtract(new RealArray(array.getDoubles()));
                RealArray result = new RealArray(array.getDoubles())
                        .subtract(new RealArray(this.getDoubles()));
                resultArray = new CMLArray(result.getArray());
            } else if (this.getDataType().equals(XSD_INTEGER)) {
                // FIXME this appears to be wrong in euclid
                // IntArray result = new IntArray(this.getInts()).
                // subtract(new IntArray(array.getInts()));
                IntArray result = new IntArray(array.getInts())
                        .subtract(new IntArray(this.getInts()));
                resultArray = new CMLArray(result.getArray());
            }
        } catch (EuclidException je) {
            throw new CMLException(S_EMPTY + je);
        }
        return resultArray;
    }

    /**
     * add an array to this..
     * 
     * result is this + array, owner document = this does not alter this
     * 
     * only works if both arrays are numeric and of same dataType
     * 
     * @param array
     *            the array to add; can have different owner
     * @throws CMLException
     *             inappropriate dataTypes, unequal arrays
     * 
     * @return the new array
     */
    public CMLArray plus(CMLArray array) throws CMLException {
        checkNumericConformability(array);
        CMLArray resultArray = null;
        try {
            if (this.getDataType().equals(XSD_DOUBLE)) {
                RealArray result = new RealArray(this.getDoubles())
                        .plus(new RealArray(array.getDoubles()));
                resultArray = new CMLArray(result.getArray());
            } else if (this.getDataType().equals(XSD_INTEGER)) {
                IntArray result = new IntArray(this.getInts())
                        .plus(new IntArray(array.getInts()));
                resultArray = new CMLArray(result.getArray());
            }
        } catch (EuclidException je) {
            throw new CMLException(S_EMPTY + je);
        }
        return resultArray;
    }

    /**
     * add a string.
     * 
     * datatype must be unset or have been set to XSD_STRING
     * 
     * @param s
     *            String to add
     * 
     * @throws CMLRuntimeException
     *             dataType not XSD_STRING
     */
    public void append(String s) throws CMLRuntimeException {
        int size = (this.getSizeAttribute() == null) ? 0 : this.getSize();
        String dataType = this.getDataType();
        if (!XSD_STRING.equals(dataType)) {
            throw new CMLRuntimeException("Cannot add string ("+s+") to array of: " + dataType);
        }
        String delim = this.getDelimiter();
        checkDelimiter(s, delim);
        appendXMLContent(getXMLContent(), delim, s);
        resetSize(size + 1);
    }

    /**
     * add a double.
     * 
     * datatype must have been set to XSD_DOUBLE
     * 
     * @param d
     *            double to add
     * 
     * @throws CMLRuntimeException
     *             dataType not XSD_DOUBLE
     */
    public void append(double d) throws CMLRuntimeException {
        int size = (this.getSizeAttribute() == null) ? 0 : this.getSize();
        String dataType = this.getDataType();
        if (!XSD_DOUBLE.equals(dataType)) {
            throw new CMLRuntimeException("Cannot add double to array of: " + dataType);
        }
        checkDelimiter(S_EMPTY + d, this.getDelimiter());
        appendXMLContent(getXMLContent(), this.getDelimiter(), S_EMPTY + d);
        resetSize(size+1);
    }

    /**
     * add an integer.
     * 
     * datatype must have been set to XSD_INTEGER
     * 
     * @param i
     *            integer to add
     * 
     * @throws CMLRuntimeException
     *             dataType not XSD_INTEGER
     */
    public void append(int i) throws CMLRuntimeException {
        int size = (this.getSizeAttribute() == null) ? 0 : this.getSize();
        String dataType = this.getDataType();
        if (!XSD_INTEGER.equals(dataType)) {
            throw new CMLRuntimeException("Cannot add int to array of: " + dataType);
        }
        checkDelimiter(S_EMPTY + i, this.getDelimiter());
        appendXMLContent(getXMLContent(), this.getDelimiter(), S_EMPTY + i);
        resetSize(size + 1);
    }

    /**
     * gets unit for array.
     * 
     * @param unitListMap
     * @return the unit (null if none)
     */
    public CMLUnit getUnit(NamespaceToUnitListMap unitListMap) {
        UnitAttribute unitsAttribute = (UnitAttribute) this.getUnitsAttribute();
        CMLUnit unit = null;
        if (unitsAttribute != null) {
            unit = unitListMap.getUnit(unitsAttribute);
        }
        return unit;
    }

    /**
     * converts a real array to SI. only affects array with units attribute and
     * dataType='xsd:double' replaces the values with the converted values and
     * the units with the SI Units
     * 
     * @param unitListMap
     *            map to resolve the units attribute
     */
    public void convertToSI(NamespaceToUnitListMap unitListMap) {
        CMLUnit unit = this.getUnit(unitListMap);
        if (unit != null && XSD_DOUBLE.equals(this.getDataType())
                && unit.getMultiplierToSIAttribute() != null) {
            CMLUnit siUnit = unit.getParentSIUnit();
            if (siUnit != null) {
                double[] array = this.getDoubles();
                RealArray realArray = new RealArray(array);
                if (unit.getMultiplierToSIAttribute() != null) {
                    // multiply current value by unit multiplier
                    double multiplier = unit.getMultiplierToSI();
                    realArray = realArray.multiplyBy(multiplier);
                }
                if (unit.getConstantToSIAttribute() != null) {
                    // add constant
                    double constant = unit.getConstantToSI();
                    realArray = realArray.addScalar(constant);
                }
                this.setArray(realArray.getArray());
                siUnit.setUnitsOn(this);
            }
        }
    }

    /**
     * sets units attribute. requires namespace for unit to be in scope.
     * 
     * @param prefix for namespace
     * @param id for unit
     * @param namespaceURI sets units namespace if not present already
     */
    public void setUnits(String prefix, String id, String namespaceURI) {
        NamespaceRefAttribute.setUnits((HasUnits)this, prefix, id, namespaceURI);
    }

    /** adds the array as a column to the tableRows.
     * 
     * @param tableRows
     */
    public void addColumnElementsTo(CMLElements<CMLTableRow> tableRows) {
        if (this.getSize() != tableRows.size()) {
            throw new CMLRuntimeException("inconsistent column size: "+
                    this.getSize()+" expected "+tableRows.size());
        }
        String dataType = this.getDataType();
        if (XSD_DOUBLE.equals(dataType)) {
            double[] dd = this.getDoubles();
            int j = 0;
            for (double d : dd) {
                tableRows.get(j++).appendChild(new CMLTableCell(d));
            }
        } else if (XSD_INTEGER.equals(dataType)) {
            int[] ii = this.getInts();
            int j = 0;
            for (int i : ii) {
                tableRows.get(j++).appendChild(new CMLTableCell(i));
            }
        } else if (XSD_STRING.equals(dataType) ||
                dataType == null) {
            String[] ss = this.getStrings();
            int j = 0;
            for (String s : ss) {
                tableRows.get(j++).appendChild(new CMLTableCell(s));
            }
        } else {
            throw new CMLRuntimeException("unknown datatype: "+dataType);
        }
    }
    
    
}
