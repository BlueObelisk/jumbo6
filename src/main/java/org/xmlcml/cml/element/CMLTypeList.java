package org.xmlcml.cml.element;

import java.util.HashMap;
import java.util.Map;

import org.xmlcml.cml.base.CMLException;
import org.xmlcml.cml.base.CMLType;

/** NON-modifiable class supporting CMLTypeList.
*
* autogenerated from schema
* DO  NOT EDIT!!

*/
public class CMLTypeList {

// fields;
    /** map of types by type name*/
    public static Map<String, CMLType> typeMap = new HashMap<String, CMLType>();
    /** ??*/
    public static CMLType subt = null;
    /** ??*/
    public static CMLType st = null;
    /** ??*/
    public static String namex = null;
    /** ??*/
    public static CMLType[] subTypes = null;

    /** lookup CMLTypes by name.
    *
    * @param name to lookup
    * @return CMLType
    */
    public static CMLType getType(String name) {
        return (CMLType) typeMap.get(name);
    }
    static {
        try {
        if (1 == 2) throw new CMLException("dummy");
        //----type-------actionOrderType----------
        st = new CMLType();
        namex = "actionOrderType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.actionOrderType");
        st.setSummary("Describes whether child elements are sequential or parallel.");
        st.setDescription("There is no default.");
        st.setEnumeration(new String[] {
        "sequential",
        "parallel",
        });
        typeMap.put("actionOrderType", st);
        //----type-------alternativeTypeType----------
        st = new CMLType();
        namex = "alternativeTypeType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.alternativeTypeType");
        st.setSummary("The type of an alternative.");
        st.setDescription("");
        typeMap.put("alternativeTypeType", st);
        //----type-------angleUnitsType----------
        st = new CMLType();
        namex = "angleUnitsType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.angleUnitsType");
        st.setSummary("An enumeration of allowed angle units.");
        st.setDescription("May be obsolete.");
        st.setEnumeration(new String[] {
        "degrees",
        "radians",
        });
        typeMap.put("angleUnitsType", st);
        //----type-------atomIDType----------
        st = new CMLType();
        namex = "atomIDType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.atomIDType");
        st.setSummary("An identifier for an atom.");
        st.setDescription("\n Of the form prefix:suffix where prefix and suffix\n are purely alphanumeric (with _ and -) and prefix\n is optional. This is similar to XML IDs (and we promote\n this as good practice for atomIDs. Other punctuation and \nwhitespace is forbidden, so IDs from (say) PDB files are\n not satisfactory.\n The prefix is intended to form a pseudo-namespace so that\n atom IDs in different molecules may have identical suffixes. \nIt is also useful if the prefix is the ID for the molecule\n (though this clearly has its limitation). Atom IDs should not\n be typed as XML IDs since they may not validate.");
        st.setPattern("[A-Za-z_][A-Za-z0-9_\\-]*(:[A-Za-z0-9_\\-]+)?");
        typeMap.put("atomIDType", st);
        //----type-------atomRefArrayType----------
        st = new CMLType();
        namex = "atomRefArrayType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.atomRefArrayType");
        st.setSummary("An array of atomRefs.");
        st.setDescription("The atomRefs\n cannot be schema- or schematron-validated. Instances of this type will\n be used in array-style representation of bonds and atomParitys.\n It can also be used for arrays of atomIDTypes such as in complex stereochemistry,\n geometrical definitions, atom groupings, etc.");
        st.setIsList(true);
        typeMap.put("atomRefArrayType", st);
        //----type-------atomRefType----------
        st = new CMLType();
        namex = "atomRefType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.atomRefType");
        st.setSummary("A reference to an existing atom.");
        st.setDescription("");
        typeMap.put("atomRefType", st);
        //----type-------atomRefs2Type----------
        st = new CMLType();
        namex = "atomRefs2Type";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.atomRefs2Type");
        st.setSummary("A reference to two distinct existing atoms in order.");
        st.setDescription("");
        st.setIsList(true);
        st.setListLength(2);
        typeMap.put("atomRefs2Type", st);
        //----type-------atomRefs3Type----------
        st = new CMLType();
        namex = "atomRefs3Type";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.atomRefs3Type");
        st.setSummary("A reference to three distinct existing atoms in order.");
        st.setDescription("");
        st.setIsList(true);
        st.setListLength(3);
        typeMap.put("atomRefs3Type", st);
        //----type-------atomRefs4Type----------
        st = new CMLType();
        namex = "atomRefs4Type";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.atomRefs4Type");
        st.setSummary("A reference to four distinct existing atoms in order.");
        st.setDescription("");
        st.setIsList(true);
        st.setListLength(4);
        typeMap.put("atomRefs4Type", st);
        //----type-------bondRefArrayType----------
        st = new CMLType();
        namex = "bondRefArrayType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.bondRefArrayType");
        st.setSummary("An array of references to bonds.");
        st.setDescription("The references cannot (yet)\n cannot be schema- or schematron-validated. Instances of this type will\n be used in array-style representation of electron counts, etc.\n It can also be used for arrays of bondIDTypes such as in complex stereochemistry,\n geometrical definitions, bond groupings, etc.");
        st.setIsList(true);
        typeMap.put("bondRefArrayType", st);
        //----type-------bondRefType----------
        st = new CMLType();
        namex = "bondRefType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.bondRefType");
        st.setSummary("A reference to an existing bond.");
        st.setDescription("");
        st.setPattern("[A-Za-z0-9_\\-]+(:[A-Za-z0-9_\\-]+)?");
        typeMap.put("bondRefType", st);
        //----type-------box3Type----------
        st = new CMLType();
        namex = "box3Type";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.box3Type");
        st.setSummary("A box in 3-space.");
        st.setDescription("Defined by 6 real numbers \n(x1 y1 z1 x2 y2 z2). By default these are Cartesian coordinates (with units \nspecified elsewhere - responsibility of schema creator.) If there is a means \nof specifying oblique axes (e.g. crystallographic cell) the box may be a \nparallelipiped. The components are grouped in threes ans separated by a semicolon \nto avoid problems of guessing the convention.");
        st.setIsList(true);
        st.setListLength(6);
        typeMap.put("box3Type", st);
        //----type-------cellParameterType----------
        st = new CMLType();
        namex = "cellParameterType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.cellParameterType");
        st.setSummary("enumerated type of cellParameter.");
        st.setDescription("");
        st.setEnumeration(new String[] {
        "length",
        "angle",
        });
        typeMap.put("cellParameterType", st);
        //----type-------chiralityType----------
        st = new CMLType();
        namex = "chiralityType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.chiralityType");
        st.setSummary("The chirality of a system or molecule.");
        st.setDescription("This is being actively investigated by a IUPAC committee (2002) so the convention is likely to change. No formal default.");
        st.setEnumeration(new String[] {
        "enantiomer",
        "racemate",
        "unknown",
        "other",
        });
        typeMap.put("chiralityType", st);
        //----type-------complexType----------
        st = new CMLType();
        namex = "complexType";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.complexType");
        st.setSummary("A pair of floats representing a complex number.");
        st.setDescription("");
        st.setIsList(true);
        st.setListLength(2);
        typeMap.put("complexType", st);
        //----type-------coordinate2Type----------
        st = new CMLType();
        namex = "coordinate2Type";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.coordinate2Type");
        st.setSummary("An x/y coordinate pair.");
        st.setDescription("An x/y coordinate pair consisting of \ntwo real numbers, separated by whitespace or a comma.\n In arrays and matrices, it may be useful to set a separate delimiter");
        st.setIsList(true);
        st.setListLength(2);
        typeMap.put("coordinate2Type", st);
        //----type-------coordinate3Type----------
        st = new CMLType();
        namex = "coordinate3Type";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.coordinate3Type");
        st.setSummary("An x/y/z coordinate triple.");
        st.setDescription("An x/y/z coordinate triple consisting of three real \nnumbers, separated by whitespace or commas. In arrays and matrices, it may be \nuseful to set a separate delimiter.");
        st.setIsList(true);
        st.setListLength(3);
        typeMap.put("coordinate3Type", st);
        //----type-------coordinateComponentArrayType----------
        st = new CMLType();
        namex = "coordinateComponentArrayType";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.coordinateComponentArrayType");
        st.setSummary("An array of coordinateComponents for a single coordinate.");
        st.setDescription("An array of coordinateComponents for a single coordinate \nwhere these all refer to an X-coordinate (NOT x,y,z).Instances of this type will be \nused in array-style representation of 2-D or 3-D coordinates. Currently no machine \nvalidation. Currently not used in STMML, but re-used by CML (see example).");
        st.setIsList(true);
        typeMap.put("coordinateComponentArrayType", st);
        //----type-------countArrayType----------
        st = new CMLType();
        namex = "countArrayType";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.countArrayType");
        st.setSummary("Array of counts.");
        st.setDescription("Normally, but not always, integers. can be used with a number of elements");
        st.setIsList(true);
        typeMap.put("countArrayType", st);
        //----type-------countType----------
        st = new CMLType();
        namex = "countType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.countType");
        st.setSummary("A count multiplier for an object.");
        st.setDescription("Many elements represent objects which can occur an arbitrary number of times in a scientific context. Examples are action, object or molecules.");
        typeMap.put("countType", st);
        //----type-------dataTypeType----------
        st = new CMLType();
        namex = "dataTypeType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.dataTypeType");
        st.setSummary("an enumerated type for all dataTypes in STM.");
        st.setDescription("Note: the attribute xsi:type might be used to enforce the type-checking but I haven't worked this through yet.");
        typeMap.put("dataTypeType", st);
        //----type-------delimiterType----------
        st = new CMLType();
        namex = "delimiterType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.delimiterType");
        st.setSummary("A single non-whitespace character to separate components in arrays.");
        st.setDescription("\n Some STMML elements (such as array) have\n content representing concatenated values. The default separator is\n whitespace (which can be normalised) and this should be used whenever\n possible. However in some cases the values are empty, or contain whitespace or other\n problematic punctuation, and a delimiter is required.\n Note that the content string MUST start and end with the delimiter so\n there is no ambiguity as to what the components are. Only printable\n characters from the ASCII character set should be used, and character\n entities should be avoided.\n When delimiters are used to separate precise whitespace this should always\n consist of spaces and not the other allowed whitespace characters \n(newline, tabs, etc.). If the latter are important it is probably best to redesign\n the application.\n At present there is a controlled pattern of characters selected so as not to collide with common usage in XML document");
        st.setPattern("[!%\\^\\*@~;#,|/]");
        typeMap.put("delimiterType", st);
        //----type-------dictionaryPrefixType----------
        st = new CMLType();
        namex = "dictionaryPrefixType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.dictionaryPrefixType");
        st.setSummary("A dictionaryPrefix.");
        st.setDescription("\n The dictionary prefix must conform to XSD.\n ");
        st.setPattern("[A-Za-z][A-Za-z0-9_\\.\\-]*");
        typeMap.put("dictionaryPrefixType", st);
        //----type-------dimensionType----------
        st = new CMLType();
        namex = "dimensionType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.dimensionType");
        st.setSummary("An angl.");
        st.setDescription("(formally dimensionless, but useful to have units).");
        st.setEnumeration(new String[] {
        "mass",
        "length",
        "time",
        "current",
        "amount",
        "luminosity",
        "temperature",
        "dimensionless",
        "angle",
        });
        typeMap.put("dimensionType", st);
        //----type-------eigenOrientationType----------
        st = new CMLType();
        namex = "eigenOrientationType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.eigenOrientationType");
        st.setSummary("The columns are the eigenvectors.");
        st.setDescription("\n Specifies whether the rows or columns of the (square) matrix\n correspond to the eigenvectors. For example, in molecular orbitals\n the vectors are normally represented as columns, and each column\n would correspond to a different eigenvalue\n ");
        typeMap.put("eigenOrientationType", st);
        //----type-------elementTypeArrayType----------
        st = new CMLType();
        namex = "elementTypeArrayType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.elementTypeArrayType");
        st.setSummary("An array of elementTypes.");
        st.setDescription("Instances of this type will be used in array-style representation of atoms.");
        st.setIsList(true);
        typeMap.put("elementTypeArrayType", st);
        //----type-------elementTypeType----------
        st = new CMLType();
        namex = "elementTypeType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.elementTypeType");
        st.setSummary("A point at which an atom or group might be attached.");
        st.setDescription("\n Examples are abbreviated organic functional groups, Markush representations, polymers, unknown atoms, etc. Semantics may be determined by the role attribute on the atom. ");
        typeMap.put("elementTypeType", st);
        //----type-------errorBasisType----------
        st = new CMLType();
        namex = "errorBasisType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.errorBasisType");
        st.setSummary("The basis of an error value.");
        st.setDescription("Errors in values can be of several types and this simpleType\n provides a small controlled vocabulary.");
        typeMap.put("errorBasisType", st);
        //----type-------errorValueArrayType----------
        st = new CMLType();
        namex = "errorValueArrayType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.errorValueArrayType");
        st.setSummary("Array of error estimate values.");
        st.setDescription("An observed or calculated estimate of the error in the value of a numeric quantity. It should be ignored for dataTypes such as URL, date or string. The statistical basis of the errorValueType is not defined - it could be a range, an estimated standard deviation, an observed standard error, etc. This information can be added through _errorBasisType_.");
        st.setIsList(true);
        typeMap.put("errorValueArrayType", st);
        //----type-------errorValueType----------
        st = new CMLType();
        namex = "errorValueType";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.errorValueType");
        st.setSummary("An estimate of the error in the value of a quantity.");
        st.setDescription("An observed or calculated estimate of the error in the value of a numeric quantity. It should be ignored for dataTypes such as URL, date or string. The statistical basis of the errorValueType is not defined - it could be a range, an estimated standard deviation, an observed standard error, etc. This information can be added through _errorBasisType_.");
        typeMap.put("errorValueType", st);
        //----type-------floatArrayType----------
        st = new CMLType();
        namex = "floatArrayType";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.floatArrayType");
        st.setSummary("OBSOLETE An array of floats.");
        st.setDescription("An array of floats or other real numbers. \nNot used in STM Schema, but re-used by CML and other languages.");
        st.setIsList(true);
        typeMap.put("floatArrayType", st);
        //----type-------formalChargeArrayType----------
        st = new CMLType();
        namex = "formalChargeArrayType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.formalChargeArrayType");
        st.setSummary("Array of formalCharges.");
        st.setDescription("Used for electron-bookeeping. This has no relation to its calculated (fractional) charge or oxidation state.");
        st.setIsList(true);
        typeMap.put("formalChargeArrayType", st);
        //----type-------formalChargeType----------
        st = new CMLType();
        namex = "formalChargeType";
        st.setName(namex);
        st.setBase("xsd:integer");
        st.setId("st.formalChargeType");
        st.setSummary("The formal charge on an object.");
        st.setDescription("Used for electron-bookeeping. This has no relation to its calculated (fractional) charge or oxidation state.");
        typeMap.put("formalChargeType", st);
        //----type-------formatType----------
        st = new CMLType();
        namex = "formatType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.formatType");
        st.setSummary("Two dimensional spectrum with different axe.");
        st.setDescription("Data are represented by non-square _matrix_ with independent axes. A typical example is a \"2D 1H 13C NMR spectrum\". The dependent variable is represented by the matrix elements. .");
        typeMap.put("formatType", st);
        //----type-------formulaType----------
        st = new CMLType();
        namex = "formulaType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.formulaType");
        st.setSummary("A concise representation for a molecular formula.");
        st.setDescription("This MUST adhere to a whitespaced syntax so that it is trivially \nmachine-parsable. Each element is followed by its count (which may be decimal), \nand the string is optionally ended by a formal charge (of form d or -d, i.e. no '+')\n NO brackets or other nesting is allowed.");
        st.setPattern("\\s*([A-Z][a-z]?\\s+(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]*))?\\s*)+(\\s+[\\-|+]?[0-9]+)?\\s*");
        typeMap.put("formulaType", st);
        //----type-------ftType----------
        st = new CMLType();
        namex = "ftType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.ftType");
        st.setSummary("This was not known to be an FT experiment. (It may have been, but the author or abstracter omitted to mention it).");
        st.setDescription("Indicates whether a spectrum is raw FID or has been transforme.");
        typeMap.put("ftType", st);
        //----type-------headType----------
        st = new CMLType();
        namex = "headType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.headType");
        st.setSummary("The head linker in a polymeric repeat unit.");
        st.setDescription("\n A polymeric chain may be described by liniing the head of one repeat\n unit to the tail or head of another. The head attribute indicates the atom\n id (normally on an atom of elementType=\"R\") which acts as the head\n ");
        st.setPattern("[A-z][A-z0-9_]*");
        typeMap.put("headType", st);
        //----type-------hydrogenCountArrayType----------
        st = new CMLType();
        namex = "hydrogenCountArrayType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.hydrogenCountArrayType");
        st.setSummary("Array of hydrogenCounts.");
        st.setDescription("The total number of hydrogen atoms bonded to an atom or contained in a molecule, whether explicitly included as atoms or not. It is an error to have hydrogen count less than the explicit hydrogen count. There is no default value and no assumptions about hydrogen Count can be made if it is not given. If hydrogenCount is given on every atom, then the values can be summed to give the total hydrogenCount for the (sub)molecule. Because of this hydrogenCount should not be used where hydrogen atoms bridge 2 or more atoms.");
        st.setIsList(true);
        typeMap.put("hydrogenCountArrayType", st);
        //----type-------hydrogenCountType----------
        st = new CMLType();
        namex = "hydrogenCountType";
        st.setName(namex);
        st.setBase("xsd:integer");
        st.setId("st.hydrogenCountType");
        st.setSummary("The total number of hydrogen atoms bonded to an object.");
        st.setDescription("The total number of hydrogen atoms bonded to an atom or contained in a molecule, whether explicitly included as atoms or not. It is an error to have hydrogen count less than the explicit hydrogen count. There is no default value and no assumptions about hydrogen Count can be made if it is not given. If hydrogenCount is given on every atom, then the values can be summed to give the total hydrogenCount for the (sub)molecule. Because of this hydrogenCount should not be used where hydrogen atoms bridge 2 or more atoms.");
        st.setMinInclusive(0);
        typeMap.put("hydrogenCountType", st);
        //----type-------idArrayType----------
        st = new CMLType();
        namex = "idArrayType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.idArrayType");
        st.setSummary("An array of ids or idRefs.");
        st.setDescription("See idType.");
        st.setIsList(true);
        typeMap.put("idArrayType", st);
        //----type-------idType----------
        st = new CMLType();
        namex = "idType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.idType");
        st.setSummary("A unique ID for an element.");
        st.setDescription("\n This is not formally of type ID (an XML NAME which must start with a letter and contain only letters, digits and .-_:). It is recommended that IDs start with a letter, and contain no punctuation or whitespace. The function in XSLT will generate semantically void unique IDs.\n It is difficult to ensure uniqueness when documents are merged. We suggest\n namespacing IDs, perhaps using the containing elements as the base.\n Thus mol3:a1 could be a useful unique ID. \nHowever this is still experimental.");
        st.setPattern("[A-Za-z][A-Za-z0-9\\.\\-_]*");
        typeMap.put("idType", st);
        //----type-------inheritType----------
        st = new CMLType();
        namex = "inheritType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.inheritType");
        st.setSummary("Components of this element will de deleted if they exist.");
        st.setDescription("The merging is element-specific with the intention that information from the current element will replace the existing information.");
        st.setEnumeration(new String[] {
        "merge",
        "replace",
        "delete",
        });
        typeMap.put("inheritType", st);
        //----type-------integerArrayType----------
        st = new CMLType();
        namex = "integerArrayType";
        st.setName(namex);
        st.setBase("xsd:integer");
        st.setId("st.integerArrayType");
        st.setSummary("An array of integers.");
        st.setDescription("An array of integers; for re-use by other schemas. Not machine-validatable.");
        st.setIsList(true);
        typeMap.put("integerArrayType", st);
        //----type-------isotopeType----------
        st = new CMLType();
        namex = "isotopeType";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.isotopeType");
        st.setSummary("The numeric representation of an isotope.");
        st.setDescription("\n In core CML this represents a single number; either the \ncombined proton/neutron count or a more accurate estimate of the \nnuclear mass. This is admittedly fuzzy, and requires a more complex\n object (which can manage conventions, lists of isotopic masses, etc.)\n See isotope.\n The default is \"natural abundance\" - whatever that can be interpreted\n as.\n Delta values (i.e. deviations from the most abundant istopic mass)\n are never allowed.");
        typeMap.put("isotopeType", st);
        //----type-------isotopicSpinType----------
        st = new CMLType();
        namex = "isotopicSpinType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.isotopicSpinType");
        st.setSummary("A fractional representation of the spin of the nucleus.");
        st.setDescription("");
        st.setPattern("\\d{1,}(/\\d)?");
        typeMap.put("isotopicSpinType", st);
        //----type-------latticeType----------
        st = new CMLType();
        namex = "latticeType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.latticeType");
        st.setSummary("User-defined lattice-type.");
        st.setDescription("This definition must be by reference to a namespaced dictionary entry.");
        typeMap.put("latticeType", st);
        //----type-------line3Type----------
        st = new CMLType();
        namex = "line3Type";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.line3Type");
        st.setSummary("An unbounded line in 3-space.");
        st.setDescription("Defined by 6 real numbers, conventionally an arbitrary \npoint on the line and a vector3. There is no significance to the point \n(i.e. it is not the \"end of the line\") and there are an infinite number of \nways of representing the line. DANGER. Line3 now uses the point3 and vector3 attributes\n and the line3Type may be OBSOLETED.");
        st.setIsList(true);
        st.setListLength(6);
        typeMap.put("line3Type", st);
        //----type-------linkTypeType----------
        st = new CMLType();
        namex = "linkTypeType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.linkTypeType");
        st.setSummary("A labelled link.");
        st.setDescription("");
        st.setEnumeration(new String[] {
        "extended",
        "locator",
        "arc",
        });
        typeMap.put("linkTypeType", st);
        //----type-------lmType----------
        st = new CMLType();
        namex = "lmType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.lmType");
        st.setSummary("symbolic represention of l amd m.");
        st.setDescription("takes avlues of s, p, px, dxy, dx2y2, f, etc.");
        st.setEnumeration(new String[] {
        "s",
        "p",
        "px",
        "py",
        "pz",
        "d",
        "dxy",
        "dyz",
        "dxz",
        "dx2y2",
        "dz2",
        "f",
        "g",
        });
        typeMap.put("lmType", st);
        //----type-------matrix44Type----------
        st = new CMLType();
        namex = "matrix44Type";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.matrix44Type");
        st.setSummary("A 4x4 transformation matrix.");
        st.setDescription("This is the base for extending the transform3 element.\n ");
        st.setIsList(true);
        st.setListLength(16);
        typeMap.put("matrix44Type", st);
        //----type-------matrixType----------
        st = new CMLType();
        namex = "matrixType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.matrixType");
        st.setSummary("User-defined matrix-type.");
        st.setDescription("This definition must be by reference to a namespaced dictionary entry.");
        typeMap.put("matrixType", st);
        //----type-------maxType----------
        st = new CMLType();
        namex = "maxType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.maxType");
        st.setSummary("The maximum INCLUSIVE value of a quantity.");
        st.setDescription("\n The maximum INCLUSIVE value of a sortable quantity such as\n numeric, date or string. It should be ignored for dataTypes such as URL. \nThe use of min and\n max attributes can be used to give a range for the quantity.\n The statistical basis of this range is not defined. The value of max \nis usually an observed \nquantity (or calculated from observations). To restrict a value, the \nmaxExclusive type in a dictionary should be used.\n The type of the maximum is the same as the quantity to which it refers - numeric,\n date and string are currently allowed");
        typeMap.put("maxType", st);
        //----type-------measurementType----------
        st = new CMLType();
        namex = "measurementType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.measurementType");
        st.setSummary("Data are absorbanc.");
        st.setDescription("so \"peaks\" are normally peaks.");
        typeMap.put("measurementType", st);
        //----type-------metadataType----------
        st = new CMLType();
        namex = "metadataType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.metadataType");
        st.setSummary("The name of the metadata.");
        st.setDescription("details include.");
        typeMap.put("metadataType", st);
        //----type-------minType----------
        st = new CMLType();
        namex = "minType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.minType");
        st.setSummary("The minimum INCLUSIVE value of a quantity.");
        st.setDescription("\n The minimum INCLUSIVE value of a sortable quantity such as\n numeric, date or string. It should be ignored for dataTypes such as URL. \nThe use of min and\n min attributes can be used to give a range for the quantity.\n The statistical basis of this range is not defined. The value of min \nis usually an observed \nquantity (or calculated from observations). To restrict a value, the \nminExclusive type in a dictionary should be used.\n The type of the minimum is the same as the quantity to which it refers - numeric,\n date and string are currently allowed");
        typeMap.put("minType", st);
        //----type-------moleculeIDType----------
        st = new CMLType();
        namex = "moleculeIDType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.moleculeIDType");
        st.setSummary("An identifier for an molecule.");
        st.setDescription("\n Of the form prefix:suffix where prefix and suffix\n are purely alphanumeric (with _ and -) and prefix\n is optional. This is similar to XML IDs (and we promote\n this as good practice for moleculeIDs. Other punctuation and \nwhitespace is forbidden, so IDs from (say) PDB files are\n not satisfactory.\n The prefix is intended to form a pseudo-namespace so that\n molecule IDs in different molecules may have identical suffixes. \nIt is also useful if the prefix is the ID for the molecule\n (though this clearly has its limitation). molecule IDs should not\n be typed as XML IDs since they may not validate.");
        st.setPattern("[A-Za-z_][A-Za-z0-9_\\-]*(:[A-Za-z0-9_\\-]+)?");
        typeMap.put("moleculeIDType", st);
        //----type-------moleculeRefArrayType----------
        st = new CMLType();
        namex = "moleculeRefArrayType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.moleculeRefArrayType");
        st.setSummary("An array of moleculeRefs.");
        st.setDescription("Typical applications are the annotation of \npeaks in chromatograms and mapping reactions. The context of the \nid resolution is the childOrSibling concept.");
        st.setIsList(true);
        typeMap.put("moleculeRefArrayType", st);
        //----type-------moleculeRefType----------
        st = new CMLType();
        namex = "moleculeRefType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.moleculeRefType");
        st.setSummary("A reference to an existing molecule.");
        st.setDescription("");
        typeMap.put("moleculeRefType", st);
        //----type-------moleculeRefs2Type----------
        st = new CMLType();
        namex = "moleculeRefs2Type";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.moleculeRefs2Type");
        st.setSummary("At present used for joining molecules or fragments(with join).");
        st.setDescription("");
        st.setIsList(true);
        st.setListLength(2);
        typeMap.put("moleculeRefs2Type", st);
        //----type-------namespaceArrayType----------
        st = new CMLType();
        namex = "namespaceArrayType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.namespaceArrayType");
        st.setSummary("An array of namespaceURIs with required protocol.");
        st.setDescription("\n used to identify dictionaries, units, conventions or other metadata.\n ");
        st.setIsList(true);
        typeMap.put("namespaceArrayType", st);
        //----type-------namespaceRefType----------
        st = new CMLType();
        namex = "namespaceRefType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.namespaceRefType");
        st.setSummary("An XML QName with required prefix.");
        st.setDescription("\n The namespace prefix must start with an alpha character\n and can only contain alphanumeric and '_'. The suffix can \nhave characters from the XML ID specification \n(alphanumeric, '_', '.' and '-'");
        st.setPattern("[A-Za-z][A-Za-z0-9_]*:[A-Za-z][A-Za-z0-9_\\.\\-]*");
        typeMap.put("namespaceRefType", st);
        //----type-------namespaceType----------
        st = new CMLType();
        namex = "namespaceType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.namespaceType");
        st.setSummary("A namespaceURI with required protocol.");
        st.setDescription("\n The namespace prefix must start with a protocol.\n ");
        st.setPattern("http://[A-Za-z][A-Za-z0-9_\\.\\-]*(/[A-Za-z0-9_\\.\\-]+)+");
        typeMap.put("namespaceType", st);
        //----type-------nonHydrogenCountType----------
        st = new CMLType();
        namex = "nonHydrogenCountType";
        st.setName(namex);
        st.setBase("xsd:integer");
        st.setId("st.nonHydrogenCountType");
        st.setSummary("The number of non-hydrogen atoms attached to an atom.");
        st.setDescription("Obsolete in core CML. Only useful in CML queries.");
        st.setMinInclusive(0);
        typeMap.put("nonHydrogenCountType", st);
        //----type-------nonNegativeAngleType----------
        st = new CMLType();
        namex = "nonNegativeAngleType";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.nonNegativeAngleType");
        st.setSummary("A non-signed angle.");
        st.setDescription("Re-used by _angle_. Note that we also provide \npositiveAngleType (e.g. for cell angles) and torsionAngleType for _torsion_.");
        typeMap.put("nonNegativeAngleType", st);
        //----type-------nonNegativeNumberType----------
        st = new CMLType();
        namex = "nonNegativeNumberType";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.nonNegativeNumberType");
        st.setSummary("");
        st.setDescription("Note that we also provide positiveNumber to avoid inclusive zero. The maximum number is 1.0E+999 since 'unbounded' is more difficult to implement. This is greater than Eddington's estimate of the number of particles in the universe so it should work for most people.");
        typeMap.put("nonNegativeNumberType", st);
        //----type-------occupancyArrayType----------
        st = new CMLType();
        namex = "occupancyArrayType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.occupancyArrayType");
        st.setSummary("Array of atomic occupancies.");
        st.setDescription("Primarily for crystallography. Values outside 0-1 are not allowed.");
        st.setIsList(true);
        typeMap.put("occupancyArrayType", st);
        //----type-------occupancyType----------
        st = new CMLType();
        namex = "occupancyType";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.occupancyType");
        st.setSummary("A floating point number between 0 and 1 inclusive.");
        st.setDescription("Originally for crystallographic occupancy but re-usable \nfor fractional yield, etc.");
        typeMap.put("occupancyType", st);
        //----type-------orderArrayType----------
        st = new CMLType();
        namex = "orderArrayType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.orderArrayType");
        st.setSummary("An array of bond orders.");
        st.setDescription("See order.");
        st.setIsList(true);
        typeMap.put("orderArrayType", st);
        //----type-------orderType----------
        st = new CMLType();
        namex = "orderType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.orderType");
        st.setSummary("Aromatic bond.");
        st.setDescription("Could be used for a transition state or a delocalised system.");
        typeMap.put("orderType", st);
        //----type-------peakMultiplicityType----------
        st = new CMLType();
        namex = "peakMultiplicityType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.peakMultiplicityType");
        st.setSummary("Several maxima (not necessarily equal) within the peak rang.");
        st.setDescription("Uses a semi-controlled vocabulary.");
        typeMap.put("peakMultiplicityType", st);
        //----type-------peakShapeType----------
        st = new CMLType();
        namex = "peakShapeType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.peakShapeType");
        st.setSummary("User contributed vocabulary of type foo:bar.");
        st.setDescription("Semi-controlled vocabulary such as \nbroad or sharp.");
        typeMap.put("peakShapeType", st);
        //----type-------peakStructureTypeType----------
        st = new CMLType();
        namex = "peakStructureTypeType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.peakStructureTypeType");
        st.setSummary("User contributed vocabulary.");
        st.setDescription("Semi-controlled vocabulary such as \ncoupling or splitting.");
        typeMap.put("peakStructureTypeType", st);
        //----type-------peakWidthType----------
        st = new CMLType();
        namex = "peakWidthType";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.peakWidthType");
        st.setSummary("The width of a peak.");
        st.setDescription("At present we allow a peakWidth to be positive \nor exactly zero (to signal that the peak should not be integrated).");
        typeMap.put("peakWidthType", st);
        //----type-------plane3Type----------
        st = new CMLType();
        namex = "plane3Type";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.plane3Type");
        st.setSummary("An unbounded plane in 3-space.");
        st.setDescription("Defined by 4 real numbers, conventionally a vector3 \nnormal to the plane and a signed scalar representing the distance to the origin. \nThe vector must not be of zero length (and need not be normalized.");
        st.setIsList(true);
        st.setListLength(4);
        typeMap.put("plane3Type", st);
        //----type-------point3Type----------
        st = new CMLType();
        namex = "point3Type";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.point3Type");
        st.setSummary("A point in 3-space.");
        st.setDescription("The 3 components can have any signed value.");
        st.setIsList(true);
        st.setListLength(3);
        typeMap.put("point3Type", st);
        //----type-------positiveAngleType----------
        st = new CMLType();
        namex = "positiveAngleType";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.positiveAngleType");
        st.setSummary("A non-signed angle such as a cell angle.");
        st.setDescription("Re-used by _crystal_. Note that we also provide \nnonNegativeAngleType (e.g. for bond angles).");
        typeMap.put("positiveAngleType", st);
        //----type-------positiveNumberType----------
        st = new CMLType();
        namex = "positiveNumberType";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.positiveNumberType");
        st.setSummary("A positive number.");
        st.setDescription("Note that we also provide nonNegativeNumber with inclusive zero. The maximum number is (quite large) since 'unbounded' is more difficult to implement.");
        typeMap.put("positiveNumberType", st);
        //----type-------reactionFormatType----------
        st = new CMLType();
        namex = "reactionFormatType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.reactionFormatType");
        st.setSummary("The format of the reaction.");
        st.setDescription("");
        typeMap.put("reactionFormatType", st);
        //----type-------reactionRoleType----------
        st = new CMLType();
        namex = "reactionRoleType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.reactionRoleType");
        st.setSummary("The role of the reaction within a reactionList.");
        st.setDescription("Semantics are semi-controlled.");
        typeMap.put("reactionRoleType", st);
        //----type-------reactionStepListTypeType----------
        st = new CMLType();
        namex = "reactionStepListTypeType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.reactionStepListTypeType");
        st.setSummary("The two or more independent reaction/List children proceed independently.");
        st.setDescription("By default the reactions in a reactionStepList are assumed to take place in sequence (e.g. one or more products of reaction n are used in reaction n+1 or later. However there are cases where it is known that reactions take place in parallel (e.g. if there is no overlap of molecular identities). Alternatively there are points at which there are two or more competing reactions which may depend on conditions or concentrations. A small semi-controlled vocabulary is suggested.");
        typeMap.put("reactionStepListTypeType", st);
        //----type-------reactionTypeType----------
        st = new CMLType();
        namex = "reactionTypeType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.reactionTypeType");
        st.setSummary("The semantic type of the reaction.");
        st.setDescription("");
        typeMap.put("reactionTypeType", st);
        //----type-------refType----------
        st = new CMLType();
        namex = "refType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.refType");
        st.setSummary("A reference to an existing object.");
        st.setDescription("The semantic of reference are normally identical to \nan idType (e.g. \"a123b\"). Howevere there are some cases where compound references\n are required, such as \"a123b:pq456\". It is likely that this will be superseded at\n by RDF or Xpointer, but as long as we have non-uniqueIds this is a problem");
        st.setPattern("([A-Za-z_][A-Za-z0-9_\\.\\-]*:)?[A-Za-z_][A-Za-z0-9_\\.\\-]*");
        typeMap.put("refType", st);
        //----type-------relatedEntryTypeType----------
        st = new CMLType();
        namex = "relatedEntryTypeType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.relatedEntryTypeType");
        st.setSummary("Type of relatedEntry.");
        st.setDescription("Type represents a the type of relationship in a relatedEntry element.");
        typeMap.put("relatedEntryTypeType", st);
        //----type-------repeatType----------
        st = new CMLType();
        namex = "repeatType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.repeatType");
        st.setSummary("instruction to create repeat of the object.");
        st.setDescription("The attribute contains an index, its start value\n (normally 1) and its end value as in \"i 3 10\" which would make 8 repeat\n of the object. In selected attribute values the string _i_ acts as a macro and\n would be replaced by the value of i. EXPERIMENTAL. It can also have variables \nas the values.");
        st.setPattern("[A-z]+ [A-z0-9_\\-\\+]+ [A-z0-9_\\-\\+]+");
        typeMap.put("repeatType", st);
        //----type-------schemeType----------
        st = new CMLType();
        namex = "schemeType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.schemeType");
        st.setSummary("The two or more independent reaction/List children proceed independently. This can be extended to synthetic chemistry where two parts of the synthesis are conducted in parallel.");
        st.setDescription("By default the reactions in a reactionStepList are assumed to take place in sequence (e.g. one or more products of reaction n are used in reaction n+1 or later. However there are cases where it is known that reactions take place in parallel (e.g. if there is no overlap of molecular identities). Alternatively there are points at which there are two or more competing reactions which may depend on conditions or concentrations. A small semi-controlled vocabulary is suggested.");
        typeMap.put("schemeType", st);
        //----type-------shapeType----------
        st = new CMLType();
        namex = "shapeType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.shapeType");
        st.setSummary("User-defined arrayList-type.");
        st.setDescription("This definition must be by reference to a namespaced dictionary entry.");
        typeMap.put("shapeType", st);
        //----type-------sizeType----------
        st = new CMLType();
        namex = "sizeType";
        st.setName(namex);
        st.setBase("xsd:integer");
        st.setId("st.sizeType");
        st.setSummary("The size of an array.");
        st.setDescription("The size of an array. Redundant, but serves as a check for processing software (useful if delimiters are used).");
        st.setMinInclusive(0);
        typeMap.put("sizeType", st);
        //----type-------spaceType----------
        st = new CMLType();
        namex = "spaceType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.spaceType");
        st.setSummary("User-defined space-type.");
        st.setDescription("No obvious possibilities, but who know.");
        typeMap.put("spaceType", st);
        //----type-------spectrumTypeType----------
        st = new CMLType();
        namex = "spectrumTypeType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.spectrumTypeType");
        st.setSummary("A spectrum somewhere in the UV VIS region of the spectrum.");
        st.setDescription("The measurement should denote transmittance or absorbance.");
        typeMap.put("spectrumTypeType", st);
        //----type-------sphere3Type----------
        st = new CMLType();
        namex = "sphere3Type";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.sphere3Type");
        st.setSummary("A sphere in 3-space.");
        st.setDescription("Defined by 4 real numbers, conventionally a point3 at \nthe centre of the sphere and a nonNegative scalar for the radius.");
        st.setIsList(true);
        st.setListLength(4);
        typeMap.put("sphere3Type", st);
        //----type-------stateType----------
        st = new CMLType();
        namex = "stateType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.stateType");
        st.setSummary("State of a substance or property.");
        st.setDescription("The state(s) of matter appropriate to a substance or property. It follows a partially controlled vocabulary. It can be extended through namespace codes to dictionaries.");
        typeMap.put("stateType", st);
        //----type-------stereoType----------
        st = new CMLType();
        namex = "stereoType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.stereoType");
        st.setSummary("empty or missing.");
        st.setDescription("This is purely conventional. There is no default value. \nThe emptyString attribute can be used to indicate a bond of \nunknown or unspecified type. The interpretation of this is outside\n the scope of CML-based algorithms. It may be accompanied by a convention\n attribute which links to a dictionary.");
        st.setEnumeration(new String[] {
        "C",
        "T",
        "W",
        "H",
        "",
        });
        typeMap.put("stereoType", st);
        //----type-------stringArrayType----------
        st = new CMLType();
        namex = "stringArrayType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.stringArrayType");
        st.setSummary("An array of strings, separated by whitespace.");
        st.setDescription("An array of strings, separated by whitespace. If the strings have embedded whitespace or may be empty (zero-length), a non-whitespace single-character delimiter must be used. At present no machine validation");
        st.setIsList(true);
        typeMap.put("stringArrayType", st);
        //----type-------substanceListTypeType----------
        st = new CMLType();
        namex = "substanceListTypeType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.substanceListTypeType");
        st.setSummary("Type of the substanceList.");
        st.setDescription("Extension is allowed through the \"other\" value.");
        st.setEnumeration(new String[] {
        "solution",
        "mixture",
        "other",
        });
        typeMap.put("substanceListTypeType", st);
        //----type-------tableTypeType----------
        st = new CMLType();
        namex = "tableTypeType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.tableTypeType");
        st.setSummary("User-defined table-type.");
        st.setDescription("This definition must be by reference to a namespaced dictionary entry.");
        typeMap.put("tableTypeType", st);
        //----type-------tailType----------
        st = new CMLType();
        namex = "tailType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.tailType");
        st.setSummary("The tail linker in a polymeric repeat unit.");
        st.setDescription("\n A polymeric chain may be described by liniing the tail of one repeat\n unit to the head or tail of another. The tail attribute indicates the atom\n id (normally on an atom of elementType=\"R\") which acts as the tail\n ");
        st.setPattern("[A-z][A-z0-9_]*");
        typeMap.put("tailType", st);
        //----type-------torsionAngleType----------
        st = new CMLType();
        namex = "torsionAngleType";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.torsionAngleType");
        st.setSummary("The type of a torsion angle.");
        st.setDescription("");
        typeMap.put("torsionAngleType", st);
        //----type-------unitListTypeType----------
        st = new CMLType();
        namex = "unitListTypeType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.unitListTypeType");
        st.setSummary("Type of unitList.");
        st.setDescription("child elements are unitType");
        st.setEnumeration(new String[] {
        "unit",
        "unitType",
        });
        typeMap.put("unitListTypeType", st);
        //----type-------unitsType----------
        st = new CMLType();
        namex = "unitsType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.unitsType");
        st.setSummary("Scientific units.");
        st.setDescription("These will be linked to dictionaries of \nunits with conversion information, using namespaced references \n(e.g. si:m). Distinguish carefully from _unitType_ \nwhich is an element describing a type of a unit in a \n_unitList_.");
        typeMap.put("unitsType", st);
        //----type-------vector3Type----------
        st = new CMLType();
        namex = "vector3Type";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.vector3Type");
        st.setSummary("A vector in 3-space.");
        st.setDescription("No constraints on magnitude (i.e. could be zero.");
        st.setIsList(true);
        st.setListLength(3);
        typeMap.put("vector3Type", st);
        //----type-------versionType----------
        st = new CMLType();
        namex = "versionType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.versionType");
        st.setSummary("Version of a document or code.");
        st.setDescription("Forms include 1, 0.9, 1.1.3, 1.2alpha, etc.");
        st.setPattern("[0-9]+(\\.[0-9]+[A-Za-z0-9\\.\\-_]*)*");
        typeMap.put("versionType", st);
        //----type-------xmlElementType----------
        st = new CMLType();
        namex = "xmlElementType";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.xmlElementType");
        st.setSummary("The name of an XMLElement.");
        st.setDescription("\n (Distinguish from a chemical element as in elementTypeType). \nCurrently used for assigning XMLElement types to references (e.g. to='a1' toType='atom'). \nSemantics are not controlled and in principle elements outside the CML tagSet \ncould be used. Implementers cannot assume that namespace prefixes can be resolved \nand default usage is probably the local name.");
        typeMap.put("xmlElementType", st);
        //----type-------xsd:QName----------
        st = new CMLType();
        namex = "xsd:QName";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.QNameType");
        st.setSummary("");
        st.setDescription("");
        st.setPattern("[A-Za-z][A-Za-z0-9_]*:[A-Za-z][A-Za-z0-9_\\.\\-]*");
        typeMap.put("xsd:QName", st);
        //----type-------xsd:anyURI----------
        st = new CMLType();
        namex = "xsd:anyURI";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.AnyURI");
        st.setSummary("");
        st.setDescription("");
        st.setPattern("[a-z]*:.*");
        typeMap.put("xsd:anyURI", st);
        //----type-------xsd:boolean----------
        st = new CMLType();
        namex = "xsd:boolean";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.booleanType");
        st.setSummary("");
        st.setDescription("");
        st.setEnumeration(new String[] {
        "true",
        "false",
        });
        typeMap.put("xsd:boolean", st);
        //----type-------xsd:double----------
        st = new CMLType();
        namex = "xsd:double";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.doubleType");
        st.setSummary("");
        st.setDescription("");
        typeMap.put("xsd:double", st);
        //----type-------xsd:float----------
        st = new CMLType();
        namex = "xsd:float";
        st.setName(namex);
        st.setBase("xsd:double");
        st.setId("st.FloatType");
        st.setSummary("");
        st.setDescription("");
        typeMap.put("xsd:float", st);
        //----type-------xsd:integer----------
        st = new CMLType();
        namex = "xsd:integer";
        st.setName(namex);
        st.setBase("xsd:integer");
        st.setId("st.integerType");
        st.setSummary("");
        st.setDescription("");
        typeMap.put("xsd:integer", st);
        //----type-------xsd:nonNegativeInteger----------
        st = new CMLType();
        namex = "xsd:nonNegativeInteger";
        st.setName(namex);
        st.setBase("xsd:integer");
        st.setId("st.NonNegativeIntegerType");
        st.setSummary("");
        st.setDescription("");
        st.setMinInclusive(0);
        typeMap.put("xsd:nonNegativeInteger", st);
        //----type-------xsd:positiveInteger----------
        st = new CMLType();
        namex = "xsd:positiveInteger";
        st.setName(namex);
        st.setBase("xsd:integer");
        st.setId("st.PositiveIntegerType");
        st.setSummary("");
        st.setDescription("");
        st.setMinExclusive(0);
        typeMap.put("xsd:positiveInteger", st);
        //----type-------xsd:string----------
        st = new CMLType();
        namex = "xsd:string";
        st.setName(namex);
        st.setBase("xsd:string");
        st.setId("st.stringType");
        st.setSummary("");
        st.setDescription("");
        typeMap.put("xsd:string", st);
        } catch (CMLException e) {
            System.err.println("bug"+e);
        }
    };
}
