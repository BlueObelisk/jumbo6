package org.xmlcml.cml.element;

import java.util.HashMap;
import java.util.Map;

import nu.xom.Attribute;

import org.xmlcml.cml.base.CMLAttribute;
import org.xmlcml.cml.base.CMLException;
import org.xmlcml.cml.base.DoubleArrayAttribute;
import org.xmlcml.cml.base.DoubleAttribute;
import org.xmlcml.cml.base.IntAttribute;
import org.xmlcml.cml.base.StringArrayAttribute;
import org.xmlcml.cml.base.StringAttribute;

/** user-modifiable class supporting CMLAttributeList.
*
* autogenerated from schema
* use as a shell which can be edited

*/
public class CMLAttributeList {

// fields;
    /** map of types by type name*/
    public static Map<String, CMLAttribute> attributeMap = new HashMap<String, CMLAttribute>();
    /** ??*/
    public static CMLAttribute cmlAttribute = null;
    /** ??*/
    public static String attributeName = null;
    /** ??*/
    public static String attributeGroupName = null;

    /** lookup CMLAttributes by name.
    *
    * @param name to lookup
    * @return CMLAttribute
    */
    public static CMLAttribute getAttribute(String name) {
        return (CMLAttribute) attributeMap.get(name);
    }
    static {
        try {
        if (1 == 2) throw new CMLException("dummy");
        attributeGroupName = "abbreviation";
        attributeName = "abbreviation";
        cmlAttribute = new StringAttribute("abbreviation");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Abbreviation.");
        cmlAttribute.setDescription("Abbreviation for units, terms, etc.");
        
        attributeGroupName = "actionOrder";
        attributeName = "order";
        cmlAttribute = new StringAttribute("order");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("actionOrderType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Describes whether child elements are sequential or parallel.");
        cmlAttribute.setDescription("There is no default.");
        
        attributeGroupName = "alternativeType";
        attributeName = "type";
        cmlAttribute = new StringAttribute("type");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("alternativeTypeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The type of an alternative.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "angleUnits";
        attributeName = "units";
        cmlAttribute = new StringAttribute("units");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("angleUnitsType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Restricts units to radians or degrees.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "atomIDArray";
        attributeName = "atomID";
        cmlAttribute = new StringArrayAttribute("atomID");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("atomRefArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("An array of atom IDs.");
        cmlAttribute.setDescription("Normally an attribute of an array-based element.");
        
        attributeGroupName = "atomMap";
        attributeName = "atomMap";
        cmlAttribute = new StringAttribute("atomMap");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("idType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A reference to a map providing mappings between atoms.");
        cmlAttribute.setDescription("The map will normally be contained within the same document and referenced by its ID. It will contain a list of links with from and to attributes linking atoms. The topology of the linking is defined by the application - it could be overlay of molecular fragments, reactant/product mapping, etc. The reserved phrase \"USE_IDS\" assume that the sets of atoms are of equal size and have 1:1 mapping between each id. This is another way of saying that the atoms mapped by a given ID are \"the same atom\". ");
        
        attributeGroupName = "atomRef";
        attributeName = "atomRef";
        cmlAttribute = new StringAttribute("atomRef");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("atomRefType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A reference to an atom.");
        cmlAttribute.setDescription("Used by bond, electron, etc.");
        
        attributeGroupName = "atomRef1Array";
        attributeName = "atomRef1";
        cmlAttribute = new StringArrayAttribute("atomRef1");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("atomRefArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The first atoms in each bond.");
        cmlAttribute.setDescription("Currently only used in bondArray in CML2 array mode.");
        
        attributeGroupName = "atomRef2Array";
        attributeName = "atomRef2";
        cmlAttribute = new StringArrayAttribute("atomRef2");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("atomRefArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The second atoms in each bond.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "atomRefArray";
        attributeName = "atomRefArray";
        cmlAttribute = new StringArrayAttribute("atomRefArray");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("atomRefArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("An array of references to atoms.");
        cmlAttribute.setDescription("Typical use would be to atoms defining a plane.");
        
        attributeGroupName = "atomRefGroup";
        attributeName = "atomRefGroup";
        cmlAttribute = new StringAttribute("atomRefGroup");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("atomIDType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "atomRefs";
        attributeName = "atomRefs";
        cmlAttribute = new StringArrayAttribute("atomRefs");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("atomRefArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A reference to a list of atoms.");
        cmlAttribute.setDescription("Used by bonds, electrons, atomSets, etc.");
        
        attributeGroupName = "atomRefs2";
        attributeName = "atomRefs2";
        cmlAttribute = new StringArrayAttribute("atomRefs2");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("atomRefs2Type"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("References to two different atoms.");
        cmlAttribute.setDescription("Available for any reference to atoms but normally will be the normal reference attribute on the bond element. The order of atoms is preserved and may matter for some conventions (e.g. wedge/hatch or donor bonds.");
        
        attributeGroupName = "atomRefs3";
        attributeName = "atomRefs3";
        cmlAttribute = new StringArrayAttribute("atomRefs3");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("atomRefs3Type"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A list of three references to atoms.");
        cmlAttribute.setDescription("Typically used for defining angles, \nbut could also be used to define a three-centre bond.");
        
        attributeGroupName = "atomRefs4";
        attributeName = "atomRefs4";
        cmlAttribute = new StringArrayAttribute("atomRefs4");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("atomRefs4Type"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A list of 4 references to atoms.");
        cmlAttribute.setDescription("Typically used for defining torsions and atomParities, \nbut could also be used to define a four-centre bond.");
        
        attributeGroupName = "atomSetRef";
        attributeName = "atomSetRef";
        cmlAttribute = new StringAttribute("atomSetRef");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("refType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("An atomSet describing the region.");
        cmlAttribute.setDescription("Any point falling within atomOffset of any atom in the set lies within the region. This means the region could consist of disjoint fragments.");
        
        attributeGroupName = "bondIDArray";
        attributeName = "bondID";
        cmlAttribute = new StringArrayAttribute("bondID");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("bondRefArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The IDs for an array of bond.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "bondMap";
        attributeName = "bondMap";
        cmlAttribute = new StringAttribute("bondMap");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:QName"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A reference to a map providing mappings between bonds.");
        cmlAttribute.setDescription("The map will normally be contained within the same document and referenced by its ID. It will contain a list of links with from and to attributes linking bonds. The topology of the linking is defined by the application - it could be overlay of molecular fragments, reactant/product mapping, etc. The reserved phrase \"USE_IDS\" assume that the sets of bonds are of equal size and have 1:1 mapping between each id. This is another way of saying that the bonds mapped by a given ID are \"the same bond\". ");
        
        attributeGroupName = "bondRef";
        attributeName = "bondRef";
        cmlAttribute = new StringAttribute("bondRef");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("bondRefType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A reference to a bond.");
        cmlAttribute.setDescription("used by electron, etc.");
        
        attributeGroupName = "bondRefs";
        attributeName = "bondRefs";
        cmlAttribute = new StringArrayAttribute("bondRefs");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("bondRefArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A reference to a list of bonds.");
        cmlAttribute.setDescription("Used by electrons, bondSets, etc.");
        
        attributeGroupName = "box3";
        attributeName = "box3";
        cmlAttribute = new DoubleArrayAttribute("box3");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("box3Type"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A parallelipiped box.");
        cmlAttribute.setDescription("By default the box uses isometric Cartesians axes but can also be linked to lattice Vector. Any point falling within the box or on a boundary is within the regio.");
        
        attributeGroupName = "builtin";
        attributeName = "builtin";
        cmlAttribute = new StringAttribute("builtin");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("builtin children.");
        cmlAttribute.setDescription("CML1-only - now deprecated.");
        
        attributeGroupName = "cellParameterError";
        attributeName = "error";
        cmlAttribute = new DoubleArrayAttribute("error");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("vector3Type"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Error array for cellParameter.");
        cmlAttribute.setDescription("3 numbers giving error limits on paremters.");
        
        attributeGroupName = "cellParameterType";
        attributeName = "type";
        cmlAttribute = new StringAttribute("type");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The type of a cellParameter.");
        cmlAttribute.setDescription("length or angle");
        
        attributeGroupName = "chirality";
        attributeName = "chirality";
        cmlAttribute = new StringAttribute("chirality");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("chiralityType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The chirality of a system or molecule.");
        cmlAttribute.setDescription("This is being actively investigated by a IUPAC committee (2002) so the convention is likely to change. No formal default.");
        
        attributeGroupName = "columns";
        attributeName = "columns";
        cmlAttribute = new IntAttribute("columns");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("sizeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Number of columns.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "concise";
        attributeName = "concise";
        cmlAttribute = new StringAttribute("concise");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("formulaType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A concise formula.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "constantToData";
        attributeName = "constantToData";
        cmlAttribute = new DoubleAttribute("constantToData");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The constant to add to the raw data.");
        cmlAttribute.setDescription(" add *after* applying any multiplier.");
        
        attributeGroupName = "constantToSI";
        attributeName = "constantToSI";
        cmlAttribute = new DoubleAttribute("constantToSI");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Additive constant to generate SI equivalent.");
        cmlAttribute.setDescription("The amount to add to a quantity in non-SI units to convert its representation to SI Units. This is applied *after* multiplierToSI. It is necessarily zero for SI units.");
        
        attributeGroupName = "constraint";
        attributeName = "constraint";
        cmlAttribute = new StringAttribute("constraint");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Constraint on a parameter.");
        cmlAttribute.setDescription("Semantics not yet finalised. We anticipate \"fixed\", \n\"none\" and symbolic relationships to other parameters.");
        
        attributeGroupName = "content";
        attributeName = "content";
        cmlAttribute = new StringAttribute("content");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("content of metadata.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "convention";
        attributeName = "convention";
        cmlAttribute = new StringAttribute("convention");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("refType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A reference to a convention.");
        cmlAttribute.setDescription("There is no controlled vocabulary for conventions, but the author must ensure that the semantics are openly available and that there are mechanisms for implementation. The convention is inherited by all the subelements, \nso that a convention for molecule would by default extend to its bond and atom children. This can be overwritten\n if necessary by an explicit convention.\n It may be useful to create conventions with namespaces (e.g. iupac:name).\n Use of convention will normally require non-STMML semantics, and should be used with\n caution. We would expect that conventions prefixed with \"ISO\" would be useful,\n such as ISO8601 for dateTimes.\n There is no default, but the conventions of STMML or the related language (e.g. CML) will be assumed.");
        
        attributeGroupName = "conventionValue";
        attributeName = "conventionValue";
        cmlAttribute = new StringAttribute("conventionValue");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The value of an element with a _convention_.");
        cmlAttribute.setDescription("When convention is used this attribute must be present and element content must be empty.");
        
        attributeGroupName = "count";
        attributeName = "count";
        cmlAttribute = new DoubleAttribute("count");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("positiveNumberType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The count of the object.");
        cmlAttribute.setDescription("No fixed semantics or default, normally integers. \nIt is presumed that the element can be multiplied by the count value.");
        
        attributeGroupName = "countArray";
        attributeName = "count";
        cmlAttribute = new DoubleArrayAttribute("count");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("countArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Array of object counts.");
        cmlAttribute.setDescription("No fixed semantics or default, normally integral. It is presumed that the element can be multiplied by the count value.");
        
        attributeGroupName = "countExpression";
        attributeName = "countExpression";
        cmlAttribute = new StringAttribute("countExpression");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("General formula for the repeat count of the element.");
        cmlAttribute.setDescription("Experimental.\n No fixed semantics or default. ");
        
        attributeGroupName = "dataType";
        attributeName = "dataType";
        cmlAttribute = new StringAttribute("dataType");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("dataTypeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The data type of the object.");
        cmlAttribute.setDescription("Normally applied to scalar/array \nobjects but may extend to more complex one.");
        
        attributeGroupName = "default";
        attributeName = "default";
        cmlAttribute = new StringAttribute("default");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("default value in an enumeration.");
        cmlAttribute.setDescription("A non-whitespace string (value is irrelevant) indicates that the content of this enumeration is the default value (usually of a scalar). It is an error to have more than one default. If the scalar in an instance document has no value (i.e. is empty or contains only whitespace) its value is given by the default. If the scalar in the instance is empty and no enumerations have a default attribute, an application may throw an error.");
        
        attributeGroupName = "delete";
        attributeName = "delete";
        cmlAttribute = new StringAttribute("delete");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("2006-05-21: PMR added attribute.");
        cmlAttribute.setDescription("An element containg this attribute may only have a transient existence\n (e.g. a template to create other elements) and this attribute shows that \nthe element can be deleted at the appropriate stage. The time at which this\n is called is application dependent. At present the presence of the attribute\n is sufficient to trigger this; later a controlled vocabulary will be developed.");
        
        attributeGroupName = "delimiter";
        attributeName = "delimiter";
        cmlAttribute = new StringAttribute("delimiter");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("delimiterType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A delimiter character for arrays and matrices.");
        cmlAttribute.setDescription("By default array components ('elements' in the non-XML sense) are whitespace-separated. This fails for components with embedded whitespace or missing completely:\n \nExample:\n In the protein database ' CA' and 'CA' are different atom types, and and array could be:\n <array delimiter=\"/\" dictRef=\"pdb:atomTypes\">/ N/ CA/CA/ N/</array> \n\nNote that the array starts and ends with the delimiter, which must be chosen to avoid accidental use. There is currently no syntax for escaping delimiters.");
        
        attributeGroupName = "dictRef";
        attributeName = "dictRef";
        cmlAttribute = new StringAttribute("dictRef");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("namespaceRefType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A reference to a dictionary entry.");
        cmlAttribute.setDescription("Elements in data instances such as _scalar_ may have a dictRef attribute to point to an entry in a dictionary. To avoid excessive use of (mutable) filenames and URIs we recommend a namespace prefix, mapped to a namespace URI in the normal manner. In this case, of course, the namespace URI must point to a real XML document containing _entry_ elements and validated against STMML Schema.\n Where there is concern about the dictionary becoming separated from the document the dictionary entries can be physically included as part of the data instance and the normal XPointer addressing mechanism can be used.\n This attribute can also be used on _dictionary_ elements to define the namespace prefix");
        
        attributeGroupName = "dictionaryPrefix";
        attributeName = "dictionaryPrefix";
        cmlAttribute = new StringAttribute("dictionaryPrefix");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("dictionaryPrefixType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The namespacePrefix for a data item.");
        cmlAttribute.setDescription("The dictionaryPrefix is associated with elements \nsuch as dictionaries and units and allows them to be referenced namespaces.\n The dictionaryPrefix is normally unbound but it may be necessary to hardcode them\n occasionally. Thus if a value is fixed (e.g. \"xsd:double\") the prefix must\n be identified and fixed.");
        
        attributeGroupName = "dimensionBasis";
        attributeName = "dimensionBasis";
        cmlAttribute = new StringAttribute("dimensionBasis");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("dimensionType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The basis of the dimension.");
        cmlAttribute.setDescription("Normally taken from the seven SI types but possibly expandable.");
        
        attributeGroupName = "dimensionality";
        attributeName = "dimensionality";
        cmlAttribute = new IntAttribute("dimensionality");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:positiveInteger"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Dimensionality of a coordinate system.");
        cmlAttribute.setDescription("Note that this means that coordinates of higher dimensionality \nare ignored or an error is flagged. Thus z3 and dimensionality='2' are incompatible. \nAt present higher dimensionalities than 3 (cf. Wondratschek) are not supported. \nThe labelling of the axes id not controlled. ?? should we have an explicit \nattribute for labelling convention?.");
        
        attributeGroupName = "duration";
        attributeName = "duration";
        cmlAttribute = new StringAttribute("duration");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The duration of the action.");
        cmlAttribute.setDescription("Semantics undefined.");
        
        attributeGroupName = "eigenOrientation";
        attributeName = "orientation";
        cmlAttribute = new StringAttribute("orientation");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("eigenOrientationType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The orientation of the eigenvector matrix.");
        cmlAttribute.setDescription("Describes whether the vectors are columns or \nrows. No default, so effectively mandatory unless you want to make implementers\n guess and break applications.");
        
        attributeGroupName = "electronMap";
        attributeName = "electronMap";
        cmlAttribute = new StringAttribute("electronMap");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("idType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A reference to a map providing mappings between electrons.");
        cmlAttribute.setDescription("The map will normally be contained within the same document and referenced by its ID. It will contain a list of links with from and to attributes linking electrons. The topology of the linking is defined by the application - it could be reactant/product mapping, etc. The reserved phrase \"USE_IDS\" assume that the sets of electrons are of equal size and have 1:1 mapping between each id. This is another way of saying that the electrons mapped by a given ID are \"the same electron\". ");
        
        attributeGroupName = "elementType";
        attributeName = "elementType";
        cmlAttribute = new StringAttribute("elementType");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("elementTypeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The identity of a chemical element.");
        cmlAttribute.setDescription("Normally mandatory on _atom_, _isotope_, etc.");
        
        attributeGroupName = "elementTypeArray";
        attributeName = "elementType";
        cmlAttribute = new StringArrayAttribute("elementType");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("elementTypeArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The identity of a chemical element.");
        cmlAttribute.setDescription("Normally mandatory on _atom_, _isotope_, etc.");
        
        attributeGroupName = "end";
        attributeName = "end";
        cmlAttribute = new StringAttribute("end");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The end value.");
        cmlAttribute.setDescription("The end value in any allowable XSD representation \nof data.");
        
        attributeGroupName = "endCondition";
        attributeName = "endCondition";
        cmlAttribute = new StringAttribute("endCondition");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The end condition.");
        cmlAttribute.setDescription("\n At present a human-readable string describing some condition when the\n ac tion should end. As XML develops it may be possible to add machine-processable\n semantics in this field.");
        
        attributeGroupName = "errorBasis";
        attributeName = "errorBasis";
        cmlAttribute = new StringAttribute("errorBasis");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("errorBasisType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Basis of the error estimate.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "errorValue";
        attributeName = "errorValue";
        cmlAttribute = new DoubleAttribute("errorValue");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("errorValueType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Value of the error.");
        cmlAttribute.setDescription("Reports the author's estimate of the error in a scalar value. Only meaningful for dataTypes mapping to real number.");
        
        attributeGroupName = "errorValueArray";
        attributeName = "errorValueArray";
        cmlAttribute = new StringArrayAttribute("errorValueArray");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("errorValueArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Array of error values.");
        cmlAttribute.setDescription("Reports the author's estimate of \nthe error in an array of values. Only meaningful for \ndataTypes mapping to real number.");
        
        attributeGroupName = "eval";
        attributeName = "eval";
        cmlAttribute = new StringAttribute("eval");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("2006-05-21: PMR added attribute.");
        cmlAttribute.setDescription("This is still experimental. if eval=\"_ijk_+3\" and\n the value of the ijk was 2, this would change the value of the arg to 5. \nOnly + and - are currently allowed");
        
        attributeGroupName = "fileId";
        attributeName = "fileId";
        cmlAttribute = new StringAttribute("fileId");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Information identifying the name of a file or other resource.");
        cmlAttribute.setDescription("This allows an element (such as cml) to carry limited\n information about provenance such as the name of the document used to provide the\n content. It is not a complete solution but can help to protect a document becoming\n separated from its external metadata. It is restricted to the basic XML character set\n (printable ANSI) and whitespace (which should anyway be discouraged) is normalized to\n single space (attribute values cannot carry newlines). \nQuotation marks and other horrors (as used in some OS)\n should be avoided. ");
        
        attributeGroupName = "form";
        attributeName = "form";
        cmlAttribute = new StringAttribute("form");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("namespaceRefType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A reference to a functional form.");
        cmlAttribute.setDescription("Currently used for potential.");
        
        attributeGroupName = "formalCharge";
        attributeName = "formalCharge";
        cmlAttribute = new IntAttribute("formalCharge");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("formalChargeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The formalCharge on the object.");
        cmlAttribute.setDescription("NOT the calculated charge or oxidation state. No formal default, but assumed to be zero if omitted. It may become good practice to include it.");
        
        attributeGroupName = "formalChargeArray";
        attributeName = "formalCharge";
        cmlAttribute = new StringArrayAttribute("formalCharge");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("formalChargeArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("An array of formalCharges.");
        cmlAttribute.setDescription("Used in CML2 Array mode. NOT the calculated charge or oxidation state. No formal defaults, but assumed to be zero if omitted. It may become good practice to include it.");
        
        attributeGroupName = "format";
        attributeName = "format";
        cmlAttribute = new StringAttribute("format");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("formatType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Format of a spectrum.");
        cmlAttribute.setDescription("The data structure of the spectrum. (Not the format of the data). This describes how the data structure is to be interpreted.");
        
        attributeGroupName = "formula";
        attributeName = "formula";
        cmlAttribute = new StringAttribute("formula");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("formulaType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Simple chemical formula.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "fractionDigits";
        attributeName = "fractionDigits";
        cmlAttribute = new IntAttribute("fractionDigits");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:nonNegativeInteger"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Number of digits after the point.");
        cmlAttribute.setDescription("This is used in dictionaries to define precision. However it might be replaced by xsd:facet.");
        
        attributeGroupName = "from";
        attributeName = "from";
        cmlAttribute = new StringAttribute("from");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("refType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The base of one or more links.");
        cmlAttribute.setDescription("On link elements the value is the single id of an element within the document or context specified in map@fromRef attributes. It must identify the element uniquely. The reserved value 'null' implies that no mapping has been provided for the object(s) in the 'to' attribute. This implies no semantics but may be used by software to keep count of which elements have been mapped. For multiple targets use 'fromSet'.");
        
        attributeGroupName = "fromContext";
        attributeName = "fromContext";
        cmlAttribute = new StringAttribute("fromContext");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("idType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The context for the 'from' links in a map.");
        cmlAttribute.setDescription("A reference to the unique 'id' attribute of an element defining the context for links in a map. This may be required when id attributes may not be unique within a document. The id should either reference an element uniquely or should be taken as the first ancestor (of the map) with such an id.\n This is fairly horrid but may be required when documents are assembled without establishing unique ids (e.g. concatenation of files). As an example a map referencing linked atoms in two molecules might use the containing 'reaction' element as its uniquifying context.\n ");
        
        attributeGroupName = "fromSet";
        attributeName = "fromSet";
        cmlAttribute = new StringArrayAttribute("fromSet");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("idArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A set of ids representing the base of a link.");
        cmlAttribute.setDescription("For a partial mapping where a number of 'from' elements are known to link to a number of 'to' elements it can be useful to aggregate these into a single attribute value. The primary use is to assert that n links exist between a set of n 'from' elements and n 'to' elements but that the precise links are unknown. The semantics of the reference are the same as for 'from' and all the elements must be of the same type (which can be specified with 'fromType' either on the link or the containing map). No order information is implied. In general there will be the same number of idRefs in the 'toSet' and all implicit links will share the same attributes (e.g. 'role'). In many cases the sets will be later split into discrete links thorugh further calculation or experiment (e.g. peak assignment). Sets should never be used as a lazy or concise alternative where the all the links are explicitly known. \n");
        
        attributeGroupName = "fromType";
        attributeName = "fromType";
        cmlAttribute = new StringAttribute("fromType");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xmlElementType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The type of the base of a link.");
        cmlAttribute.setDescription("The local tagname of the referenced element (e.g. 'molecule' or 'peakGroup'). This acts as a partial check on the integrity of the link. Software can assume that the referenced element is of a given tytpe and can create an object supporting that type. \nThis attribute can be attached to the 'map' attribute and requires all contained links to be of this type. This can be overridden by a 'toType' attribute on indivdual links, but it may also be useful to split the map into maps od different link types.\n ");
        
        attributeGroupName = "ft";
        attributeName = "ft";
        cmlAttribute = new StringAttribute("ft");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("ftType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Domain of an FT spectrum.");
        cmlAttribute.setDescription("Indicates whether a spectrum is raw FID or has been transforme.");
        
        attributeGroupName = "href";
        attributeName = "href";
        cmlAttribute = new StringAttribute("href");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:anyURI"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("address of a resource.");
        cmlAttribute.setDescription("Links to another element in the same or other file. For dictionary/@dictRef requires the prefix and the physical URI \naddress to be contained within the same file. We can anticipate that\n better mechanisms will arise - perhaps through XMLCatalogs.\n At least it works at present.");
        
        attributeGroupName = "hydrogenCount";
        attributeName = "hydrogenCount";
        cmlAttribute = new IntAttribute("hydrogenCount");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("hydrogenCountType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Number of hydrogens.");
        cmlAttribute.setDescription("The total number of hydrogens bonded to the atom or molecule. It is preferable to include hydrogens explicitly, and where this is done their count represents the minimum (and may thus override this attribute). It is dangerous to use this attribute for electron-deficient molecules (e.g. diborane) or hydrogen bonds. There is NO DEFAULT and the absence of this attribute must not be given any meaning.");
        
        attributeGroupName = "hydrogenCountArray";
        attributeName = "hydrogenCount";
        cmlAttribute = new StringArrayAttribute("hydrogenCount");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("hydrogenCountArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Array of hydrogenCounts.");
        cmlAttribute.setDescription("Normally used in CML2 array mode. The total number of hydrogens bonded to the atom or molecule. It is preferable to include hydrogens explicitly, and where this is done their count represents the minimum (and may thus override this attribute). It is dangerous to use this attribute for electron-deficient molecules (e.g. diborane) or hydrogen bonds. There is NO DEFAULT and the absence of this attribute must not be given any meaning.");
        
        attributeGroupName = "id";
        attributeName = "id";
        cmlAttribute = new StringAttribute("id");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("idType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A unique ID for an element.");
        cmlAttribute.setDescription("Id is used for machine identification of elements and\n in general should not have application semantics. It is similar to the XML ID type\n as containing only alphanumerics, '_', ',' and '-' and and must start with an\n alphabetic character. Ids are case sensitive. Ids should be unique within local scope,\n thus all atoms within a molecule should have unique ids, but separated molecules within a \ndocument (such as a published article) might have identical ids. Software\n should be able to search local scope (e.g. all atoms within a molecule). \nHowever this is under constant review.");
        
        attributeGroupName = "idgen";
        attributeName = "idgen";
        cmlAttribute = new StringAttribute("idgen");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Allows a referring element to generate a unique id.");
        cmlAttribute.setDescription("idgen can hold a unique identifier which is copied into the id\n attribute of the referenced element. This avoids multiple copies of the referenced \nobject with duplicate ids. EXPERIMENTAL\n ");
        
        attributeGroupName = "inherit";
        attributeName = "inherit";
        cmlAttribute = new StringAttribute("inherit");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("inheritType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Inheritance mechanism.");
        cmlAttribute.setDescription("A reference to an existing element can be used to supplement values such as coordinates. The inheritance attribute determines whether the values are supplemented, overwritten or deleted. In the example:\n\n<molecule id=\"m1\" view=\"initial\">\n <atomArray>\n <atom id=\"a1\" x3=\"0.1\"/>\n </atomArray>\n</molecule>\n<!-- this adds more information -->\n<molecule ref=\"m1\" view=\"initial\" inherit=\"supplement\">\n <atomArray>\n <atom id=\"a1\" hydrogenCount=\"1\"/>\n </atomArray>\n</molecule>\n<!-- this will overwrite the previous values -->\n<molecule ref=\"m1\" inherit=\"overwrite\" view=\"final\"\n id=\"m2\">\n <atomArray>\n <atom id=\"a1\" x3=\"0.1\"/>\n </atomArray>\n</molecule>\n<!-- this will delete the previous values -->\n<molecule ref=\"m1\" inherit=\"delete\" view=\"restart\">\n <atomArray>\n <atom id=\"a1\" hydrogenCount=\"\"/>\n </atomArray>\n</molecule>\n\n\n The first molecule/@ref adds complementary information, the second\n changes the values. Software is allowed to generate two independent copies of the molecule and reference them by different IDs (m1 and m2).\n \nThis mechanism is necessary to manage the implied inheritance of partial information during minimisations and dynamics. It requires careful software implementation.\n ");
        
        attributeGroupName = "inline";
        attributeName = "inline";
        cmlAttribute = new StringAttribute("inline");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("An inline representation of the object.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "integral";
        attributeName = "integral";
        cmlAttribute = new StringAttribute("integral");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Area under a peak.");
        cmlAttribute.setDescription("Unfortunately units are usually arbitrary and not related to the x- and y- axis units, and in this case _peakUnits_ should be use.");
        
        attributeGroupName = "irreducibleRepresentation";
        attributeName = "irreducibleRepresentation";
        cmlAttribute = new StringAttribute("irreducibleRepresentation");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A symmetry species.");
        cmlAttribute.setDescription("No fixed semantics, though we may provide a controlled-extensible list in the future.");
        
        attributeGroupName = "isSI";
        attributeName = "isSI";
        cmlAttribute = new StringAttribute("isSI");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:boolean"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("indicates whether a unit is an SI or derived SI unit.");
        cmlAttribute.setDescription("required on SI unit elements with value 'true'. \nOptional on other units with attribute 'false'. A unitList should contain either\n SI units or non-SI units but not both.");
        
        attributeGroupName = "isotope";
        attributeName = "isotope";
        cmlAttribute = new DoubleAttribute("isotope");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The isotope for an element.");
        cmlAttribute.setDescription("A real number describing the isotope. Probably obsolet.");
        
        attributeGroupName = "isotopeListRef";
        attributeName = "isotopeListRef";
        cmlAttribute = new StringAttribute("isotopeListRef");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("idType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Reference to a description of the isotopic composition of an atom.");
        cmlAttribute.setDescription("Used when more than one atom shares the same isotopic composition (e.g. when H/D have been scrambled over some or all of the atoms in a molecule..");
        
        attributeGroupName = "isotopeNumber";
        attributeName = "isotopeNumber";
        cmlAttribute = new IntAttribute("isotopeNumber");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:positiveInteger"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The integer number for an isotope.");
        cmlAttribute.setDescription("The number representing the isotope. By default it does not point to a fuller description of the isotope (use isotopeRef).");
        
        attributeGroupName = "isotopeRef";
        attributeName = "isotopeRef";
        cmlAttribute = new StringAttribute("isotopeRef");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("refType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Reference to a fuller description of the isotope.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "kpoint";
        attributeName = "kpoint";
        cmlAttribute = new DoubleArrayAttribute("kpoint");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("vector3Type"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The k vector.");
        cmlAttribute.setDescription("The k-vector with 3 components.");
        
        attributeGroupName = "kpointRef";
        attributeName = "kpointRef";
        cmlAttribute = new StringAttribute("kpointRef");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("refType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A reference to a kpoint.");
        cmlAttribute.setDescription("Used by band, etc.");
        
        attributeGroupName = "l";
        attributeName = "l";
        cmlAttribute = new IntAttribute("l");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:nonNegativeInteger"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The secondary quantum number.");
        cmlAttribute.setDescription("takes values 0, 1, etc.");
        
        attributeGroupName = "label";
        attributeName = "label";
        cmlAttribute = new StringAttribute("label");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A label.");
        cmlAttribute.setDescription("The semantics of label are not defined in the schema but are normally commonly used standard or semi-standard text strings. This attribute has the the same semantics as the more common _label_ element.");
        
        attributeGroupName = "latticeType";
        attributeName = "latticeType";
        cmlAttribute = new StringAttribute("latticeType");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("latticeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The primitivity of a lattice.");
        cmlAttribute.setDescription("No default. The semantics of this are software-dependent (i.e. this Schema does not check for consistency between spacegroups, symmetry operators, etc.");
        
        attributeGroupName = "length";
        attributeName = "length";
        cmlAttribute = new IntAttribute("length");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:nonNegativeInteger"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Length of a scalar.");
        cmlAttribute.setDescription("Probably will be replaced with xsd:schema tool.");
        
        attributeGroupName = "linkType";
        attributeName = "linkType";
        cmlAttribute = new StringAttribute("linkType");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("linkTypeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The type of the link.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "list";
        attributeName = "list";
        cmlAttribute = new StringAttribute("list");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A list of values.");
        cmlAttribute.setDescription("Normally for iterations.");
        
        attributeGroupName = "lm";
        attributeName = "lm";
        cmlAttribute = new StringAttribute("lm");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("lmType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("symbolic represention of l amd m.");
        cmlAttribute.setDescription("takes avlues of s, p, px, dxy, dx2y2, f, etc.");
        
        attributeGroupName = "m";
        attributeName = "m";
        cmlAttribute = new IntAttribute("m");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:integer"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The azimuthal quantum number.");
        cmlAttribute.setDescription("takes values -1, 0, 1, etc.");
        
        attributeGroupName = "mandatoryId";
        attributeName = "id";
        cmlAttribute = new StringAttribute("id");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("idType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("An attribute providing a mandatory unique ID for an element.");
        cmlAttribute.setDescription("This is a horrible hack. It should be possible to add 'required' to\n the attributeGroup where used... (Maybe it is and I am still fighting Schema Wars.");
        
        attributeGroupName = "matrixType";
        attributeName = "matrixType";
        cmlAttribute = new StringAttribute("matrixType");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("matrixType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Type of matrix.");
        cmlAttribute.setDescription("Mainly square, but extensible through the _xsd:union_ mechanis.");
        
        attributeGroupName = "max";
        attributeName = "max";
        cmlAttribute = new StringAttribute("max");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("maxType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Maximum value allowed for an element or attribute.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "maxExclusive";
        attributeName = "maxExclusive";
        cmlAttribute = new DoubleAttribute("maxExclusive");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("maximum exclusive value.");
        cmlAttribute.setDescription("by analogy with xsd:schema.");
        
        attributeGroupName = "maxInclusive";
        attributeName = "maxInclusive";
        cmlAttribute = new DoubleAttribute("maxInclusive");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("minimum inclusive value.");
        cmlAttribute.setDescription("by analogy with xsd:schem.");
        
        attributeGroupName = "maxLength";
        attributeName = "maxLength";
        cmlAttribute = new IntAttribute("maxLength");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:positiveInteger"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("maximum length of a scalar.");
        cmlAttribute.setDescription("by analogy with xsd:schem.");
        
        attributeGroupName = "maxValueArray";
        attributeName = "maxValueArray";
        cmlAttribute = new DoubleArrayAttribute("maxValueArray");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("floatArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Maximum values for numeric _matrix_ or _array.");
        cmlAttribute.setDescription("A whitespace-separated list of the same length as the array in the parent element.");
        
        attributeGroupName = "measurement";
        attributeName = "measurement";
        cmlAttribute = new StringAttribute("measurement");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("measurementType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Type of spectral measurement.");
        cmlAttribute.setDescription("The nature of the measured data. This is not an exhaustive list and should only be used if it affects the storage or immediate processing.");
        
        attributeGroupName = "metadataType";
        attributeName = "name";
        cmlAttribute = new StringAttribute("name");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("metadataType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The metadata type.");
        cmlAttribute.setDescription("This is likely to be the Dublin Core \nname or something similar. The use of \"type\" is an infelicitous \nmisnomer and we shall try to remove it.");
        
        attributeGroupName = "min";
        attributeName = "min";
        cmlAttribute = new StringAttribute("min");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("minType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The minimum value allowed for an element or attribute.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "minExclusive";
        attributeName = "minExclusive";
        cmlAttribute = new DoubleAttribute("minExclusive");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("minimum exclusive value.");
        cmlAttribute.setDescription("by analogy with xsd:schema.");
        
        attributeGroupName = "minInclusive";
        attributeName = "minInclusive";
        cmlAttribute = new DoubleAttribute("minInclusive");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("minimum inclusive value.");
        cmlAttribute.setDescription("by analogy with xsd:schema.");
        
        attributeGroupName = "minLength";
        attributeName = "minLength";
        cmlAttribute = new IntAttribute("minLength");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:nonNegativeInteger"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("minimum length of a scalar.");
        cmlAttribute.setDescription("by analogy with xsd:schema.");
        
        attributeGroupName = "minValueArray";
        attributeName = "minValueArray";
        cmlAttribute = new DoubleArrayAttribute("minValueArray");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("floatArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Minimum values for numeric _matrix_ or _array.");
        cmlAttribute.setDescription("A whitespace-separated lists of the same length as the array in the parent element.");
        
        attributeGroupName = "moleculeRef";
        attributeName = "moleculeRef";
        cmlAttribute = new StringAttribute("moleculeRef");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("moleculeRefType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A reference to a molecule.");
        cmlAttribute.setDescription("Used by spectrum, etc.");
        
        attributeGroupName = "moleculeRefs";
        attributeName = "moleculeRefs";
        cmlAttribute = new StringArrayAttribute("moleculeRefs");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("moleculeRefArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A reference to one or more molecules.");
        cmlAttribute.setDescription("Uses the id attribute as the target identification. \nThe order of molecules is preserved. It is not necessarily an error to have repeated \nreferences to the same molecule");
        
        attributeGroupName = "moleculeRefs2";
        attributeName = "moleculeRefs2";
        cmlAttribute = new StringArrayAttribute("moleculeRefs2");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("moleculeRefs2Type"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("References to two different molecules.");
        cmlAttribute.setDescription("Available for any reference to molecules but \nnormally will be the normal reference attribute on the join element. \nThe order of molecules is preserved and may matter.");
        
        attributeGroupName = "multiplierToData";
        attributeName = "multiplierToData";
        cmlAttribute = new DoubleAttribute("multiplierToData");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The scale by which to multiply raw data or a unit.");
        cmlAttribute.setDescription("The scale is applied *before* adding any constant.\n The attribute may be found on a data item (scalar, array, matrix, etc.) or \na user-defined unit.");
        
        attributeGroupName = "multiplierToSI";
        attributeName = "multiplierToSI";
        cmlAttribute = new DoubleAttribute("multiplierToSI");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Multiplier to generate SI equivalent.");
        cmlAttribute.setDescription("The factor by which the non-SI unit should be multiplied to convert a quantity to its representation in SI Units. This is applied *before* _constantToSI_. Necessarily unity for SI unit.");
        
        attributeGroupName = "n";
        attributeName = "n";
        cmlAttribute = new IntAttribute("n");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:nonNegativeInteger"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The principal quantum number.");
        cmlAttribute.setDescription("Takes values 1, 2, 3, etc.");
        
        attributeGroupName = "name";
        attributeName = "name";
        cmlAttribute = new StringAttribute("name");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Name of the object.");
        cmlAttribute.setDescription("A string by which the object is known. Often a required attribute. The may or may not be a semi-controlled vocabulary.");
        
        attributeGroupName = "namespace";
        attributeName = "namespace";
        cmlAttribute = new StringAttribute("namespace");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("namespaceType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The namespace for a data item.");
        cmlAttribute.setDescription("The namespace is associated with elements such as dictionaries\n and units and allows them to be referenced through free namespace prefixes.");
        
        attributeGroupName = "number";
        attributeName = "number";
        cmlAttribute = new IntAttribute("number");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:nonNegativeInteger"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A number determined by context.");
        cmlAttribute.setDescription("Used for isotope number in isotope, and rotational symmetry number in symmetry for calculation of entropy, etc.");
        
        attributeGroupName = "objectClass";
        attributeName = "objectClass";
        cmlAttribute = new StringAttribute("objectClass");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The class of an object.");
        cmlAttribute.setDescription("The type of this information. This is not controlled, but examples might include:\n \nlabel\n summary\n note\n usage\n qualifier\n \nIt might be used to control display or XSL filtering.");
        
        attributeGroupName = "occupancy";
        attributeName = "occupancy";
        cmlAttribute = new DoubleAttribute("occupancy");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("occupancyType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Occupancy for an atom.");
        cmlAttribute.setDescription("Normally only found in crystallography. Defaults to 1.0. The occupancy is required to calculate the molecular formaula from the atoms.");
        
        attributeGroupName = "occupancyArray";
        attributeName = "occupancy";
        cmlAttribute = new StringArrayAttribute("occupancy");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("occupancyArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Array of occupancies.");
        cmlAttribute.setDescription("Normally only found in crystallography. Defaults to 1.0. The occupancy is required to calculate the molecular formula from the atoms.");
        
        attributeGroupName = "order";
        attributeName = "order";
        cmlAttribute = new StringAttribute("order");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("orderType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The order of the bond.");
        cmlAttribute.setDescription("There is NO default. This order is for bookkeeping only and is not related to length, QM calculations or other experimental or theoretical calculations.");
        
        attributeGroupName = "orderArray";
        attributeName = "order";
        cmlAttribute = new StringArrayAttribute("order");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("orderArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The order of the bond.");
        cmlAttribute.setDescription("There is NO default. This order is for bookkeeping only and is not related to length, QM calculations or other experimental or theoretical calculations.");
        
        attributeGroupName = "parameterName";
        attributeName = "parameterName";
        cmlAttribute = new StringAttribute("parameterName");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("2006-06-09: PMR added attribute.");
        cmlAttribute.setDescription("This is still experimental.");
        
        attributeGroupName = "parentAttribute";
        attributeName = "parentAttribute";
        cmlAttribute = new StringAttribute("parentAttribute");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("2006-06-09: PMR added attribute.");
        cmlAttribute.setDescription("This is still experimental. Creates, overwriting\n if necessary, an attribute on parent. Example:\n \n<foo>\n <arg parentAttribute=\"bar\">zubbo</arg>\n \nwill create an attribute bar=\"zubbo\" on <foo> \n");
        
        attributeGroupName = "parentSI";
        attributeName = "parentSI";
        cmlAttribute = new StringAttribute("parentSI");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("namespaceRefType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A dictRef-like reference to the id of the parent SI unit.");
        cmlAttribute.setDescription("This parent should occur in this or another dictionary \nand be accessible through the dictRef mechanism. This attribute is forbidden \nfor SI Units themselves. The mechanism holds for base SI units (7) and \nall compound (derived) units made by combinations of base Units.");
        
        attributeGroupName = "pattern";
        attributeName = "pattern";
        cmlAttribute = new StringAttribute("pattern");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Pattern constraint.");
        cmlAttribute.setDescription("Based on xsd:schema.");
        
        attributeGroupName = "peakHeight";
        attributeName = "peakHeight";
        cmlAttribute = new DoubleAttribute("peakHeight");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Height of a peak.");
        cmlAttribute.setDescription("For 1-dimensional data \n(e.g. y vs x) hould use the same units as the appropriate \naxis (e.g. y).");
        
        attributeGroupName = "peakMultiplicity";
        attributeName = "peakMultiplicity";
        cmlAttribute = new StringAttribute("peakMultiplicity");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("peakMultiplicityType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Multiplicity of a peak.");
        cmlAttribute.setDescription("Uses a semi-controlled vocabulary.");
        
        attributeGroupName = "peakShape";
        attributeName = "peakShape";
        cmlAttribute = new StringAttribute("peakShape");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("peakShapeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Shape of a peak.");
        cmlAttribute.setDescription("Semi-controlled vocabulary such as broad or sharp.");
        
        attributeGroupName = "peakStructureType";
        attributeName = "type";
        cmlAttribute = new StringAttribute("type");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("peakStructureTypeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Type of this structure.");
        cmlAttribute.setDescription("Semi-controlled vocabulary such as coupling \nor splitting.");
        
        attributeGroupName = "peakUnits";
        attributeName = "peakUnits";
        cmlAttribute = new StringAttribute("peakUnits");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("unitsType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Units for a peak or peak integral.");
        cmlAttribute.setDescription("For 2-dimensional spectra the units represent the observation. For an integral they are usually arbitrary and not related to the x- and y- axis units. Thus NMR spectra may use hydrogen count as the units for the peak area.");
        
        attributeGroupName = "periodic";
        attributeName = "periodic";
        cmlAttribute = new StringAttribute("periodic");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:boolean"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Is the axis periodic.");
        cmlAttribute.setDescription("Any or all of the axes may be periodic or aperiodic. An example could be a surface where 2 periodic axes (not necessarily orthogonal) are used to describe the coordinates in the surface, perhaps representing lattice vectors of a 3D crystal or 2D layer. The third vector is orthogonal and represents coordinates normal to the surface. In this case only the direction, not the magnitude of the vector is important.");
        
        attributeGroupName = "periodicity";
        attributeName = "periodicity";
        cmlAttribute = new IntAttribute("periodicity");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:positiveInteger"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("This represents the number of dimensions (or coordinate axes) along periodic behaviour occurs and can be supported by symmetry operators or other transformations. Periodicity must never exceed dimensionality.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "point3";
        attributeName = "point3";
        cmlAttribute = new DoubleArrayAttribute("point3");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("point3Type"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A point in 3 dimensions.");
        cmlAttribute.setDescription("can be used for any complex \ngeometrical object, such as line.");
        
        attributeGroupName = "pointGroup";
        attributeName = "pointGroup";
        cmlAttribute = new StringAttribute("pointGroup");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A point group.");
        cmlAttribute.setDescription("No fixed semantics, though Schoenflies is recommended over Hermann-Mauguin. We may provide a controlled-extensible list in the future.");
        
        attributeGroupName = "pointGroupMultiplicity";
        attributeName = "pointGroupMultiplicity";
        cmlAttribute = new IntAttribute("pointGroupMultiplicity");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:positiveInteger"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("SpaceGroup multiplicity.");
        cmlAttribute.setDescription("Normally for an atom. This attribute gives the pointGroup multiplicity of the molecule and is independent of any atomic information. No default, and it may take any positive integer value \n(though values are normally between 1 and 60 (for icosahedral). It represents the number of symmetry operations\n (without any translations) that transform the atom into itself. \nThus an atom on a centre of symmetry can have a pointGroupMultiplicity of 2.\n The pointGroupMultiplicity can be deduced from a knowledge of the\n coordinates and the pointGroup operators and so is formally redundant but this is a\n useful convenience operator. \nDistinguish carefully from occupancy which represents incomplete occupation of a \nsite.");
        
        attributeGroupName = "power";
        attributeName = "power";
        cmlAttribute = new DoubleAttribute("power");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The power to which a dimension should be raised.");
        cmlAttribute.setDescription("Normally an integer. Must be included, even if unity.");
        
        attributeGroupName = "powerRequired";
        attributeName = "power";
        cmlAttribute = new DoubleAttribute("power");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The power to which a dimension should be raised.");
        cmlAttribute.setDescription("Normally an integer. Must be included, even if unity.");
        
        attributeGroupName = "preserve";
        attributeName = "preserve";
        cmlAttribute = new StringAttribute("preserve");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:boolean"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Is the dimension preserved during algebra.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "process";
        attributeName = "process";
        cmlAttribute = new StringAttribute("process");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Keyword signifying how object is to be processed.");
        cmlAttribute.setDescription("Semantics depend on the parent element");
        
        attributeGroupName = "ratio";
        attributeName = "ratio";
        cmlAttribute = new DoubleAttribute("ratio");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("occupancyType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A ratio in the range 0 to 1.");
        cmlAttribute.setDescription("Currently used for ratios between brached reactions but re-usable for other concepts.");
        
        attributeGroupName = "reactionFormat";
        attributeName = "format";
        cmlAttribute = new StringAttribute("format");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("reactionFormatType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Format of the reaction component.");
        cmlAttribute.setDescription("Indicates how the components of reactionScheme, reactionStepList, etc. should be processed. No controlled vocabulary. One example is format=\"cmlSnap\" asserts that the processor can assume that the reactants and products can be rendered using the CMLSnap design. Note that the reaction can be interpreted without reference to the format, which is primarily a processing instruction.");
        
        attributeGroupName = "reactionRole";
        attributeName = "role";
        cmlAttribute = new StringAttribute("role");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("reactionRoleType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Role of the reaction.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "reactionStepListType";
        attributeName = "type";
        cmlAttribute = new StringAttribute("type");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("reactionStepListTypeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The sequence of steps in a reactionStepList.");
        cmlAttribute.setDescription("By default the reactions in a reactionStepList are assumed to take place in sequence (e.g. one or more products of reaction n are used in reaction n+1 or later. However there are cases where it is known that reactions take place in parallel (e.g. if there is no overlap of molecular identities). Alternatively there are points at which there are two or more competing reactions which may depend on conditions or concentrations. A small semi-controlled vocabulary is suggested.");
        
        attributeGroupName = "reactionType";
        attributeName = "type";
        cmlAttribute = new StringAttribute("type");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("reactionTypeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Type of the reaction.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "recommendedUnits";
        attributeName = "recommendedUnits";
        cmlAttribute = new StringAttribute("recommendedUnits");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("unitsType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Recommended unit.");
        cmlAttribute.setDescription("a facet on a numeric dictionary entry.");
        
        attributeGroupName = "ref";
        attributeName = "ref";
        cmlAttribute = new StringAttribute("ref");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("refType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A reference to an element of given type.");
        cmlAttribute.setDescription("ref modifies an element into a reference to an existing element of that type within the document. This is similar to a pointer and it can be thought of a strongly typed hyperlink. It may also be used for \"subclassing\" or \"overriding\" elements.\n When referring to an element most of the \"data\" such as attribute values and element content will be on the full instantiated element. Therefore ref (and possibly id) will normally be the only attributes on the pointing element. However there may be some attributes (title, count, etc.) which have useful semantics, but these are element-specific");
        
        attributeGroupName = "regionRefs";
        attributeName = "regionRefs";
        cmlAttribute = new StringAttribute("regionRefs");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("refType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A list of regions creating a union.");
        cmlAttribute.setDescription("The union of a series of regions produces a larger region (possibly disjoint). Any point belonging to any of the referenced regions is a member of this region.");
        
        attributeGroupName = "relatedEntryType";
        attributeName = "type";
        cmlAttribute = new StringAttribute("type");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("relatedEntryTypeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Type of relatedEntry.");
        cmlAttribute.setDescription("Type represents a the type of relationship in a relatedEntry element.");
        
        attributeGroupName = "role";
        attributeName = "role";
        cmlAttribute = new StringAttribute("role");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Role of the object.");
        cmlAttribute.setDescription("How the object functions or its position in the architecture. No controlled vocabulary.");
        
        attributeGroupName = "rows";
        attributeName = "rows";
        cmlAttribute = new IntAttribute("rows");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("sizeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Number of rows.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "scheme";
        attributeName = "scheme";
        cmlAttribute = new StringAttribute("scheme");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("schemeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The sequence of steps in a reactionList.");
        cmlAttribute.setDescription("By default the reactions in a reactionStepList are assumed to take place in sequence (e.g. one or more products of reaction n are used in reaction n+1 or later. However there are cases where it is known that reactions take place in parallel (e.g. if there is no overlap of molecular identities). Alternatively there are points at which there are two or more competing reactions which may depend on conditions or concentrations. A small semi-controlled vocabulary is suggested.");
        
        attributeGroupName = "serial";
        attributeName = "serial";
        cmlAttribute = new StringAttribute("serial");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Currently only on module. Modules with the same _role_ attribute can be distinguished by _serial_. This is often an integer but other schemes may be used.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "shape";
        attributeName = "shape";
        cmlAttribute = new StringAttribute("shape");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("shapeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("shape of object.");
        cmlAttribute.setDescription("Mainly square, but extensible through the _xsd:union_ mechanism.");
        
        attributeGroupName = "siNamespace";
        attributeName = "siNamespace";
        cmlAttribute = new StringAttribute("siNamespace");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("namespaceType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The namespace for SI Units dictionary.");
        cmlAttribute.setDescription("Main use is on unitList to identify the \ndictionary holding the SI Units.");
        
        attributeGroupName = "siNamespaceArray";
        attributeName = "siNamespaceArray";
        cmlAttribute = new StringArrayAttribute("siNamespaceArray");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("namespaceArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Array of namespaces locating SI Units dictionaries.");
        cmlAttribute.setDescription("Main use is on unitList to identify the \ndictionaries holding the SI Units.");
        
        attributeGroupName = "size";
        attributeName = "size";
        cmlAttribute = new IntAttribute("size");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("sizeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The size of an array or matrix.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "spaceGroup";
        attributeName = "spaceGroup";
        cmlAttribute = new StringAttribute("spaceGroup");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A space group.");
        cmlAttribute.setDescription("No fixed semantics, though Hermann-Mauguin or Hall is recommended over Schoenflies. We may provide a controlled-extensible list in the future.");
        
        attributeGroupName = "spaceGroupMultiplicity";
        attributeName = "spaceGroupMultiplicity";
        cmlAttribute = new IntAttribute("spaceGroupMultiplicity");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:positiveInteger"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("SpaceGroup multiplicity.");
        cmlAttribute.setDescription("Normally for an atom. This attribute gives the spaceGroup multiplicity of the molecule and is independent of any atomic information. No default, and it may take any positive integer value \n(though values are normally between 1 and 192. It represents the number of symmetry operations\n (without cell translations) that transform the atom into itself. \nThus an atom on a centre of symmetry can have a spaceGroupMultiplicity of 2.\n The spaceGroupMultiplicity can be deduced from a knowledge of the\n coordinates and the spaceGroup operators and so is formally redundant but this is a\n useful convenience operator. Some crystallographic experiments report this attribute\n as, for example, the IUCr CIF item 'atom_site_symmetry_multiplicity'.\n Distinguish carefully from occupancy which represents incomplete occupation of a \nsite.");
        
        attributeGroupName = "spaceType";
        attributeName = "spaceType";
        cmlAttribute = new StringAttribute("spaceType");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("spaceType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The spaceType of the lattice.");
        cmlAttribute.setDescription("Usually real or reciprocal. No default. The semantics of this are software-dependent (i.e. this Schema does not check for consistency for unitTypes, etc.");
        
        attributeGroupName = "spectrumType";
        attributeName = "type";
        cmlAttribute = new StringAttribute("type");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("spectrumTypeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The type of the spectrum.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "sphere3";
        attributeName = "sphere3";
        cmlAttribute = new DoubleArrayAttribute("sphere3");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("sphere3Type"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A sphere.");
        cmlAttribute.setDescription("Currently describes a region. Any point falling within the sphere or on its surface is within the region.");
        
        attributeGroupName = "spin";
        attributeName = "spin";
        cmlAttribute = new StringAttribute("spin");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("isotopicSpinType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The spin of a system.");
        cmlAttribute.setDescription("Supports fractional values. Currently the spin of a nucleus. The normal fraction representing the spin of the isotope.");
        
        attributeGroupName = "spinMultiplicity";
        attributeName = "spinMultiplicity";
        cmlAttribute = new IntAttribute("spinMultiplicity");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:positiveInteger"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Spin multiplicity.");
        cmlAttribute.setDescription("Normally for a molecule. This attribute gives the spin multiplicity of the molecule and is independent of any atomic information. No default, and it may take any positive integer value (though values are normally between 1 and 5.");
        
        attributeGroupName = "start";
        attributeName = "start";
        cmlAttribute = new StringAttribute("start");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The start value.");
        cmlAttribute.setDescription("The start value in any allowable \nXSD representation ");
        
        attributeGroupName = "startCondition";
        attributeName = "startCondition";
        cmlAttribute = new StringAttribute("startCondition");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The start condition.");
        cmlAttribute.setDescription("This can describe the condition(s) that has to be met before an action can begin, such as in a recipe. Semantics are unexplored but could be used to control robotic operations.");
        
        attributeGroupName = "state";
        attributeName = "state";
        cmlAttribute = new StringAttribute("state");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("stateType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The physical state of the substance.");
        cmlAttribute.setDescription("No fixed semantics or default.");
        
        attributeGroupName = "step";
        attributeName = "step";
        cmlAttribute = new StringAttribute("step");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The step value.");
        cmlAttribute.setDescription("The step value in any allowable \nXSD representation ");
        
        attributeGroupName = "substanceListType";
        attributeName = "type";
        cmlAttribute = new StringAttribute("type");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("substanceListTypeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Type of the substanceList.");
        cmlAttribute.setDescription("Extension is allowed through the \"other\" value.");
        
        attributeGroupName = "substitute";
        attributeName = "substitute";
        cmlAttribute = new StringAttribute("substitute");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("2006-05-21: PMR added attribute.");
        cmlAttribute.setDescription("This is still experimental. The value may be an \nXPath expression, at present\n all attributes (\".//@*\") are processed. If an attribute contains _ijk_ where the\n name of the arg is 'ijk' this string is replaced by the value of ijk,\n e.g. if arg with name ijk has a value of 2 then 'm_ijk__z3' becomes\n 'm2_z3'. substitute=\".\" replaces this element by its value");
        
        attributeGroupName = "symbol";
        attributeName = "symbol";
        cmlAttribute = new StringAttribute("symbol");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A symbol.");
        cmlAttribute.setDescription("No semantics. However it should contain only \nASCII characters and we may have to develop an escaping mechanism.\n Used on _atomicBasisFunction_, _unit_, etc.");
        
        attributeGroupName = "symmetryOriented";
        attributeName = "symmetryOriented";
        cmlAttribute = new StringAttribute("symmetryOriented");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:boolean"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Is the molecule oriented to the symmetry.");
        cmlAttribute.setDescription("No formal default, but a molecule is assumed to be oriented according to any _symmetry_ children. This is required for crystallographic data, but some systems for isolated molecules allow specification of arbitrary Cartesian or internal coordinates, which must be fitted or refined to a prescribed symmetry. In this case the attribute value is false.");
        
        attributeGroupName = "tableType";
        attributeName = "tableType";
        cmlAttribute = new StringAttribute("tableType");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("tableTypeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("type of table.");
        cmlAttribute.setDescription("controls content");
        
        attributeGroupName = "tautomeric";
        attributeName = "tautomeric";
        cmlAttribute = new StringAttribute("tautomeric");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Indicates whether the structure is a tautomer.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "term";
        attributeName = "term";
        cmlAttribute = new StringAttribute("term");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A term in a dictionary.");
        cmlAttribute.setDescription("The term should be a noun or nounal phrase, with a separate definition and further description.");
        
        attributeGroupName = "test";
        attributeName = "test";
        cmlAttribute = new StringAttribute("test");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The test condition on an if element.");
        cmlAttribute.setDescription("No controlled format yet.");
        
        attributeGroupName = "title";
        attributeName = "title";
        cmlAttribute = new StringAttribute("title");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A title on an element.");
        cmlAttribute.setDescription("No controlled value.");
        
        attributeGroupName = "to";
        attributeName = "to";
        cmlAttribute = new StringAttribute("to");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("refType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("On link elements the value is the single id of an element within the document or context specified in map@toContext attributes. It must identify the element uniquely. The reserved value 'null' implies that no mapping has been provided for the object(s) in the 'from' attribute. This implies no semantics but may be used by software to keep count of which elements have been mapped. For multiple targets use 'toSet'.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "toContext";
        attributeName = "toContext";
        cmlAttribute = new StringAttribute("toContext");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("idType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The context for the 'from' links in a map.");
        cmlAttribute.setDescription("A reference to the unique 'id' attribute of an element defining the context for links in a map. This may be required when id attributes may not be unique within a document. The id should either reference an element uniquely or should be taken as the first ancestor (of the map) with such an id.\n This is fairly horrid but may be required when documents are assembled without establishing unique ids (e.g. concatenation of files). As an example a map referencing linked atoms in two molecules might use the containing 'reaction' element as its uniquifying context.\n ");
        
        attributeGroupName = "toSet";
        attributeName = "toSet";
        cmlAttribute = new StringArrayAttribute("toSet");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("idArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A set of ids representing the base of a link.");
        cmlAttribute.setDescription("For a partial mapping where a number of 'to' elements are known to link to a number of 'from' elements it can be useful to aggregate these into a single attribute value. The primary use is to assert that n links exist between a set of n 'to' elements and n 'from' elements but that the precise links are unknown. The semantics of the reference are the same as for 'to' and all the elements must be of the same type (which can be specified with 'toType' either on the link or the containing map). No order information is implied. In general there will be the same number of idRefs in the 'fromSet' and all implicit links will share the same attributes (e.g. 'role'). In many cases the sets will be later split into discrete links thorugh further calculation or experiment (e.g. peak assignment). Sets should never be used as a lazy or concise alternative where the all the links are explicitly known. \n");
        
        attributeGroupName = "toType";
        attributeName = "toType";
        cmlAttribute = new StringAttribute("toType");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xmlElementType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The type of the base of a link.");
        cmlAttribute.setDescription("\n The local tagname of the referenced element (e.g. 'molecule' or 'peakGroup'). This acts as a partial check on the integrity of the link. Software can assume that the referenced element is of a given tytpe and can create an object supporting that type.\n This attribute can be attached to the 'map' attribute and requires all contained links to be of this type. This can be overridden by a 'toType' attribute on indivdual links, but it may also be useful to split the map into maps od different link types.\n ");
        
        attributeGroupName = "totalDigits";
        attributeName = "totalDigits";
        cmlAttribute = new IntAttribute("totalDigits");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:positiveInteger"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("total digits in a scalar.");
        cmlAttribute.setDescription("based on xsd:schema.");
        
        attributeGroupName = "type";
        attributeName = "type";
        cmlAttribute = new StringAttribute("type");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Type of the object.");
        cmlAttribute.setDescription("A qualifier which may affect the semantics of the object.");
        
        attributeGroupName = "unitListType";
        attributeName = "type";
        cmlAttribute = new StringAttribute("type");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("unitListTypeType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A reference to the type of a unit.");
        cmlAttribute.setDescription("Needed to differentiate the rather unhappy\n polymorphism of unitList/unit and unitList/unitType.");
        
        attributeGroupName = "unitType";
        attributeName = "unitType";
        cmlAttribute = new StringAttribute("unitType");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A reference to the type of a unit.");
        cmlAttribute.setDescription("Used in defining the unit and doing \nsymbolic algebra on the dimensionality.");
        
        attributeGroupName = "units";
        attributeName = "units";
        cmlAttribute = new StringAttribute("units");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("unitsType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Scientific units on an element.");
        cmlAttribute.setDescription("These must be taken from a dictionary \nof units. There should be some mechanism for validating the type \nof the units against the possible values of the element.");
        
        attributeGroupName = "unitsRef";
        attributeName = "unitsRef";
        cmlAttribute = new StringAttribute("unitsRef");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("unitsRef attribute on CML1 elements.");
        cmlAttribute.setDescription("CML1-only - now deprecated.");
        
        attributeGroupName = "value";
        attributeName = "value";
        cmlAttribute = new StringAttribute("value");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Value of a scalar object.");
        cmlAttribute.setDescription("The value must be consistent with the dataType of the object.");
        
        attributeGroupName = "vector3";
        attributeName = "vector3";
        cmlAttribute = new DoubleArrayAttribute("vector3");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("vector3Type"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("A vector in 3 dimensions.");
        cmlAttribute.setDescription("can be used for any complex geometrical object,\n such as line.");
        
        attributeGroupName = "version";
        attributeName = "version";
        cmlAttribute = new StringAttribute("version");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The version of the element.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "weight";
        attributeName = "weight";
        cmlAttribute = new DoubleAttribute("weight");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Weight of the element.");
        cmlAttribute.setDescription("Currently the weight of the kPoint, derived from the symmetry such as the inverse of the multiplicity in real space. Thus a point at 0,0,0 in monoclinic space might be 0.25. The lowest value possible is probably 1/48.0 (in m3m).");
        
        attributeGroupName = "whiteSpace";
        attributeName = "whiteSpace";
        cmlAttribute = new StringAttribute("whiteSpace");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:string"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Whitespace.");
        cmlAttribute.setDescription("Attached to entry. This may be obsolete.");
        
        attributeGroupName = "x2";
        attributeName = "x2";
        cmlAttribute = new DoubleAttribute("x2");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("x2 coordinate for an object.");
        cmlAttribute.setDescription("Used for displaying the object in 2 dimensions. Unrelated to the 3-D coordinates for the object. The orientation of the axes matters as it can affect the chirality of object.");
        
        attributeGroupName = "x2Array";
        attributeName = "x2";
        cmlAttribute = new DoubleArrayAttribute("x2");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("coordinateComponentArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("array of x2 coordinate.");
        cmlAttribute.setDescription("Normally used in CML2 array mode. Used for displaying the object in 2 dimensions. Unrelated to the 3-D coordinates for the object. The orientation of the axes matters as it can affect the chirality of object.");
        
        attributeGroupName = "x3";
        attributeName = "x3";
        cmlAttribute = new DoubleAttribute("x3");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The x coordinate of a 3 dimensional object.");
        cmlAttribute.setDescription("The default units are Angstrom. (The provision \nfor other units is weak at present.) Objects are always described \nwith a right-handed coordinate system.");
        
        attributeGroupName = "x3Array";
        attributeName = "x3";
        cmlAttribute = new DoubleArrayAttribute("x3");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("coordinateComponentArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Normally used in CML2 array mode.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "xFract";
        attributeName = "xFract";
        cmlAttribute = new DoubleAttribute("xFract");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Fractional x coordinate.");
        cmlAttribute.setDescription("normally xFract, yFract and zFract should all be present or absent. If present a _crystal_ element should also occur.");
        
        attributeGroupName = "xFractArray";
        attributeName = "xFract";
        cmlAttribute = new DoubleArrayAttribute("xFract");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("coordinateComponentArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Array of fractional x coordinate.");
        cmlAttribute.setDescription("normally xFract, yFract and zFract should all be present or absent. If present a _crystal_ element should also occur.");
        
        attributeGroupName = "xMax";
        attributeName = "xMax";
        cmlAttribute = new DoubleAttribute("xMax");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Maximum xValue.");
        cmlAttribute.setDescription("Annotates x-axis data with a maximum \nvalue. This need not be algorithmically deducible from the data \nand is typically used for the extent of a _peak_ or _peakGroup_. \nIt uses xUnits or the same units as the data. There may or may not \nbe a _xMin_ attribute but if so xMax should be greater than or \nequals to it.");
        
        attributeGroupName = "xMin";
        attributeName = "xMin";
        cmlAttribute = new DoubleAttribute("xMin");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Minimum xValue.");
        cmlAttribute.setDescription("Annotates x-axis data with a minimum \nvalue. This need not be algorithmically deducible from the data \nand is typically used for the extent of a _peak_ or _peakGroup_. \nIt uses xUnits or the same units as the data. There may or may not \nbe a _xMax_ attribute but if so xMin should be less than or equals \nto it.");
        
        attributeGroupName = "xUnits";
        attributeName = "xUnits";
        cmlAttribute = new StringAttribute("xUnits");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("unitsType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Units for x axis.");
        cmlAttribute.setDescription("All x-axis data must have unambiguous units. Ideally the data and _xMin_ or _xValue_ should share the same units but different xUnits can be used as long as it is clear..");
        
        attributeGroupName = "xValue";
        attributeName = "xValue";
        cmlAttribute = new DoubleAttribute("xValue");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Value along an x axis.");
        cmlAttribute.setDescription("Annotates x-axis data with a value. It \nis typically used for the location of a _peak_ or _peakGroup_. It \nuses xUnits or the same units as the data.");
        
        attributeGroupName = "xWidth";
        attributeName = "xWidth";
        cmlAttribute = new DoubleAttribute("xWidth");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("An unsigned interval along an x axis.");
        cmlAttribute.setDescription("It is typically used for the width of \na _peak_ or _peakGroup_ but could be used for any range. It uses \nxUnits or the same units as the data.");
        
        attributeGroupName = "y2";
        attributeName = "y2";
        cmlAttribute = new DoubleAttribute("y2");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("y2 coordinate for an object.");
        cmlAttribute.setDescription("Used for displaying the object in 2 \ndimensions. Unrelated to the 3-D coordinates for the object. The \norientation of the axes matters as it can affect the chirality of \nobject.");
        
        attributeGroupName = "y2Array";
        attributeName = "y2";
        cmlAttribute = new DoubleArrayAttribute("y2");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("coordinateComponentArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("array of y2 coordinate.");
        cmlAttribute.setDescription("Normally used in CML2 array mode. Used for displaying the object in 2 dimensions. Unrelated to the 3-D coordinates for the object. The orientation of the axes matters as it can affect the chirality of object.");
        
        attributeGroupName = "y3";
        attributeName = "y3";
        cmlAttribute = new DoubleAttribute("y3");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The y coordinate of a 3 dimensional object.");
        cmlAttribute.setDescription("The default units are Angstrom. (The \nprovision for other units is weak at present.) Objects are always \ndescribed with a right-handed coordinate system.");
        
        attributeGroupName = "y3Array";
        attributeName = "y3";
        cmlAttribute = new DoubleArrayAttribute("y3");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("coordinateComponentArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Normally used in CML2 array mode.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "yFract";
        attributeName = "yFract";
        cmlAttribute = new DoubleAttribute("yFract");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Fractional y coordinate.");
        cmlAttribute.setDescription("normally xFract, yFract and zFract \nshould all be present or absent. If present a _crystal_ element \nshould also occur.");
        
        attributeGroupName = "yFractArray";
        attributeName = "yFract";
        cmlAttribute = new DoubleArrayAttribute("yFract");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("coordinateComponentArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Array of fractional y coordinate.");
        cmlAttribute.setDescription("normally xFract, yFract and zFract should all be present or absent. If present a _crystal_ element should also occur.");
        
        attributeGroupName = "yMax";
        attributeName = "yMax";
        cmlAttribute = new DoubleAttribute("yMax");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Maximum yValue.");
        cmlAttribute.setDescription("Annotates y-axis data with a maximum \nvalue. This need not be algorithmically deducible from the data \nand is typically used for the extent of a _peak_ or _peakGroup_. \nIt uses yUnits or the same units as the data. There may or may not \nbe a _yMin_ attribute but if so yMax should be greater than or \nequals to it.");
        
        attributeGroupName = "yMin";
        attributeName = "yMin";
        cmlAttribute = new DoubleAttribute("yMin");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Minimum yValue.");
        cmlAttribute.setDescription("Annotates y-axis data with a minimum \nvalue. This need not be algorithmically deducible from the data \nand is typically used for the extent of a _peak_ or _peakGroup_. \nIt uses yUnits or the same units as the data. There may or may \nnot be a _yMax_ attribute but if so yMin should be less than or \nequal to it.");
        
        attributeGroupName = "yUnits";
        attributeName = "yUnits";
        cmlAttribute = new StringAttribute("yUnits");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("unitsType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Units for y axis.");
        cmlAttribute.setDescription("All y-axis data must have unambiguous units. Ideally the data and _yMin_ or _yValue_ should share the same units but different yUnits can be used as long as it is clear.");
        
        attributeGroupName = "yValue";
        attributeName = "yValue";
        cmlAttribute = new DoubleAttribute("yValue");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Value along a y axis.");
        cmlAttribute.setDescription("Annotates y-axis data with a value. It \nis typically used for the location of a _peak_ or _peakGroup_. It \nuses yUnits or the same units as the data.");
        
        attributeGroupName = "yWidth";
        attributeName = "yWidth";
        cmlAttribute = new DoubleAttribute("yWidth");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("An unsigned interval along a y axis.");
        cmlAttribute.setDescription("It is typically used for the width of \na _peak_ or _peakGroup_ but could be used for any range. It uses \nyUnits or the same units as the data.");
        
        attributeGroupName = "yield";
        attributeName = "yield";
        cmlAttribute = new DoubleAttribute("yield");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("occupancyType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Yield of a reaction or reactionStep.");
        cmlAttribute.setDescription("Yields can be given on either element. They should lie in the range 0 to 1 inclusive (i.e. percentages will need to be converted). Software may use yield to calculate amounts of substances created during a reaction or series of reactions.");
        
        attributeGroupName = "z";
        attributeName = "z";
        cmlAttribute = new IntAttribute("z");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:nonNegativeInteger"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The number of molecules per cell.");
        cmlAttribute.setDescription("Molecules are defined as the _molecule_ which directly contains the _crystal_ element.");
        
        attributeGroupName = "z3";
        attributeName = "z3";
        cmlAttribute = new DoubleAttribute("z3");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("The z coordinate of a 3 dimensional object.");
        cmlAttribute.setDescription("The default units are Angstrom. (The \nprovision for other units is weak at present.) Objects are always \ndescribed with a right-handed coordinate system.");
        
        attributeGroupName = "z3Array";
        attributeName = "z3";
        cmlAttribute = new DoubleArrayAttribute("z3");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("coordinateComponentArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Normally used in CML2 array mode.");
        cmlAttribute.setDescription("");
        
        attributeGroupName = "zFract";
        attributeName = "zFract";
        cmlAttribute = new DoubleAttribute("zFract");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("xsd:double"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Fractional y coordinate.");
        cmlAttribute.setDescription("normally xFract, yFract and zFract \nshould all be present or absent. If present a _crystal_ element \nshould also occur.");
        
        attributeGroupName = "zFractArray";
        attributeName = "zFract";
        cmlAttribute = new DoubleArrayAttribute("zFract");
        cmlAttribute.setAttributeGroupName(attributeGroupName);
        cmlAttribute.setSchemaType(CMLTypeList.getType("coordinateComponentArrayType"));
        attributeMap.put(attributeGroupName, cmlAttribute);
        cmlAttribute.setSummary("Array of fractional z coordinate.");
        cmlAttribute.setDescription("normally xFract, yFract and zFract should all be present or absent. If present a _crystal_ element should also occur.");
        
        } catch (CMLException e) {
        }
    };
    /** make CMLAttributes.
    *
    * @param attributeGroupName attributeGroup name
    * @param value attribute value
    * @param URI attribute URI
    * @throws CMLException bad attribute name/value
    * @return Attribute
    */
    public static Attribute makeAttributeFromGroupName(String attributeGroupName, String value, String URI) throws CMLException {
        CMLAttribute attribute =  CMLAttribute.createSubclassedAttribute(CMLAttributeList.getAttribute(attributeGroupName), value);
        if (attribute != null) {
            attribute.setCMLValue(value);
        }

        return attribute;

    }
    /** get summary.
    *
    * @return String
    */
    public String getSummary() {
        return "";

    }
}
